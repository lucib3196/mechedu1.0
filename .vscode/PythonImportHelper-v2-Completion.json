[
    {
        "label": "SQLAlchemy",
        "importPath": "flask_sqlalchemy",
        "description": "flask_sqlalchemy",
        "isExtraImport": true,
        "detail": "flask_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "FlaskForm",
        "importPath": "flask_wtf",
        "description": "flask_wtf",
        "isExtraImport": true,
        "detail": "flask_wtf",
        "documentation": {}
    },
    {
        "label": "StringField",
        "importPath": "wtforms",
        "description": "wtforms",
        "isExtraImport": true,
        "detail": "wtforms",
        "documentation": {}
    },
    {
        "label": "SubmitField",
        "importPath": "wtforms",
        "description": "wtforms",
        "isExtraImport": true,
        "detail": "wtforms",
        "documentation": {}
    },
    {
        "label": "MultipleFileField",
        "importPath": "flask_wtf.file",
        "description": "flask_wtf.file",
        "isExtraImport": true,
        "detail": "flask_wtf.file",
        "documentation": {}
    },
    {
        "label": "FileRequired",
        "importPath": "flask_wtf.file",
        "description": "flask_wtf.file",
        "isExtraImport": true,
        "detail": "flask_wtf.file",
        "documentation": {}
    },
    {
        "label": "FileField",
        "importPath": "flask_wtf.file",
        "description": "flask_wtf.file",
        "isExtraImport": true,
        "detail": "flask_wtf.file",
        "documentation": {}
    },
    {
        "label": "DataRequired",
        "importPath": "wtforms.validators",
        "description": "wtforms.validators",
        "isExtraImport": true,
        "detail": "wtforms.validators",
        "documentation": {}
    },
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Blueprint",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "session",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "redirect",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "url_for",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "flash",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Blueprint",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "session",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "redirect",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "url_for",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "flash",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Blueprint",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "session",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "redirect",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "url_for",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "flash",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Blueprint",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Blueprint",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "session",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "redirect",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "url_for",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "flash",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Blueprint",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "session",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "redirect",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "url_for",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "flash",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Blueprint",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "session",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "redirect",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "url_for",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "flash",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Blueprint",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "send_file",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "session",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "redirect",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "url_for",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Response",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "session",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "session",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Blueprint",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "send_file",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "session",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Blueprint",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "url_for",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "secure_filename",
        "importPath": "werkzeug.utils",
        "description": "werkzeug.utils",
        "isExtraImport": true,
        "detail": "werkzeug.utils",
        "documentation": {}
    },
    {
        "label": "secure_filename",
        "importPath": "werkzeug.utils",
        "description": "werkzeug.utils",
        "isExtraImport": true,
        "detail": "werkzeug.utils",
        "documentation": {}
    },
    {
        "label": "secure_filename",
        "importPath": "werkzeug.utils",
        "description": "werkzeug.utils",
        "isExtraImport": true,
        "detail": "werkzeug.utils",
        "documentation": {}
    },
    {
        "label": "generate_module",
        "importPath": "src.gestalt_module_generator.generate_gestalt_module",
        "description": "src.gestalt_module_generator.generate_gestalt_module",
        "isExtraImport": true,
        "detail": "src.gestalt_module_generator.generate_gestalt_module",
        "documentation": {}
    },
    {
        "label": "generate_module",
        "importPath": "src.gestalt_module_generator.generate_gestalt_module",
        "description": "src.gestalt_module_generator.generate_gestalt_module",
        "isExtraImport": true,
        "detail": "src.gestalt_module_generator.generate_gestalt_module",
        "documentation": {}
    },
    {
        "label": "generate_module",
        "importPath": "src.gestalt_module_generator.generate_gestalt_module",
        "description": "src.gestalt_module_generator.generate_gestalt_module",
        "isExtraImport": true,
        "detail": "src.gestalt_module_generator.generate_gestalt_module",
        "documentation": {}
    },
    {
        "label": "generate_module",
        "importPath": "src.gestalt_module_generator.generate_gestalt_module",
        "description": "src.gestalt_module_generator.generate_gestalt_module",
        "isExtraImport": true,
        "detail": "src.gestalt_module_generator.generate_gestalt_module",
        "documentation": {}
    },
    {
        "label": "process_lecture_content",
        "importPath": "src.gestalt_module_generator.generate_lecture",
        "description": "src.gestalt_module_generator.generate_lecture",
        "isExtraImport": true,
        "detail": "src.gestalt_module_generator.generate_lecture",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "ast",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ast",
        "description": "ast",
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "literal_eval",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "literal_eval",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "literal_eval",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "literal_eval",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "generateAdaptive",
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "isExtraImport": true,
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "run_generate_py",
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "isExtraImport": true,
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "run_generate",
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "isExtraImport": true,
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "read_file",
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "isExtraImport": true,
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "generateAdaptive",
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "isExtraImport": true,
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "run_generate_py",
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "isExtraImport": true,
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "run_generate",
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "isExtraImport": true,
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "read_file",
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "isExtraImport": true,
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "generateAdaptive",
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "isExtraImport": true,
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "run_generate_py",
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "isExtraImport": true,
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "run_generate",
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "isExtraImport": true,
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "read_file",
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "isExtraImport": true,
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "process_prairielearn_html",
        "importPath": "src.utils.plutilities",
        "description": "src.utils.plutilities",
        "isExtraImport": true,
        "detail": "src.utils.plutilities",
        "documentation": {}
    },
    {
        "label": "process_prairielearn_html",
        "importPath": "src.utils.plutilities",
        "description": "src.utils.plutilities",
        "isExtraImport": true,
        "detail": "src.utils.plutilities",
        "documentation": {}
    },
    {
        "label": "process_prairielearn_html",
        "importPath": "src.utils.plutilities",
        "description": "src.utils.plutilities",
        "isExtraImport": true,
        "detail": "src.utils.plutilities",
        "documentation": {}
    },
    {
        "label": "process_prairielearn_html",
        "importPath": "src.utils.plutilities",
        "description": "src.utils.plutilities",
        "isExtraImport": true,
        "detail": "src.utils.plutilities",
        "documentation": {}
    },
    {
        "label": "traceback",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "traceback",
        "description": "traceback",
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "zipfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "zipfile",
        "description": "zipfile",
        "detail": "zipfile",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "create_zip_file",
        "importPath": "src.utils.file_handler",
        "description": "src.utils.file_handler",
        "isExtraImport": true,
        "detail": "src.utils.file_handler",
        "documentation": {}
    },
    {
        "label": "save_files_temp",
        "importPath": "src.utils.file_handler",
        "description": "src.utils.file_handler",
        "isExtraImport": true,
        "detail": "src.utils.file_handler",
        "documentation": {}
    },
    {
        "label": "save_temp_dir_as_zip",
        "importPath": "src.utils.file_handler",
        "description": "src.utils.file_handler",
        "isExtraImport": true,
        "detail": "src.utils.file_handler",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "openai",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "openai",
        "description": "openai",
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "OpenAI",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "OpenAI",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "AsyncOpenAI",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "AsyncOpenAI",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "AsyncOpenAI",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "AsyncOpenAI",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "convert_from_path",
        "importPath": "pdf2image",
        "description": "pdf2image",
        "isExtraImport": true,
        "detail": "pdf2image",
        "documentation": {}
    },
    {
        "label": "fitz",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "fitz",
        "description": "fitz",
        "detail": "fitz",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "field_validator",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "validator",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BeautifulSoup",
        "importPath": "bs4",
        "description": "bs4",
        "isExtraImport": true,
        "detail": "bs4",
        "documentation": {}
    },
    {
        "label": "BeautifulSoup",
        "importPath": "bs4",
        "description": "bs4",
        "isExtraImport": true,
        "detail": "bs4",
        "documentation": {}
    },
    {
        "label": "BeautifulSoup",
        "importPath": "bs4",
        "description": "bs4",
        "isExtraImport": true,
        "detail": "bs4",
        "documentation": {}
    },
    {
        "label": "BeautifulSoup",
        "importPath": "bs4",
        "description": "bs4",
        "isExtraImport": true,
        "detail": "bs4",
        "documentation": {}
    },
    {
        "label": "BeautifulSoup",
        "importPath": "bs4",
        "description": "bs4",
        "isExtraImport": true,
        "detail": "bs4",
        "documentation": {}
    },
    {
        "label": "UUID",
        "importPath": "uuid",
        "description": "uuid",
        "isExtraImport": true,
        "detail": "uuid",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "src.logging_config.logging_config",
        "description": "src.logging_config.logging_config",
        "isExtraImport": true,
        "detail": "src.logging_config.logging_config",
        "documentation": {}
    },
    {
        "label": "aiohttp",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "aiohttp",
        "description": "aiohttp",
        "detail": "aiohttp",
        "documentation": {}
    },
    {
        "label": "base64",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "base64",
        "description": "base64",
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "importlib.util",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "importlib.util",
        "description": "importlib.util",
        "detail": "importlib.util",
        "documentation": {}
    },
    {
        "label": "execjs",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "execjs",
        "description": "execjs",
        "detail": "execjs",
        "documentation": {}
    },
    {
        "label": "Template",
        "importPath": "jinja2",
        "description": "jinja2",
        "isExtraImport": true,
        "detail": "jinja2",
        "documentation": {}
    },
    {
        "label": "Template",
        "importPath": "jinja2",
        "description": "jinja2",
        "isExtraImport": true,
        "detail": "jinja2",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "create_app",
        "importPath": "app",
        "description": "app",
        "isExtraImport": true,
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "EduModule",
        "kind": 6,
        "importPath": "app.db_models.models",
        "description": "app.db_models.models",
        "peekOfCode": "class EduModule(db.Model):\n    __tablename__ = \"edu_module\"\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(256), nullable=False)\n    folders = db.relationship(\"Folder\", backref=\"edu_module\", lazy=True)\n    def __repr__(self):\n        return f\"<EduModule {self.name}>\"\nclass Folder(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(256), nullable=False)",
        "detail": "app.db_models.models",
        "documentation": {}
    },
    {
        "label": "Folder",
        "kind": 6,
        "importPath": "app.db_models.models",
        "description": "app.db_models.models",
        "peekOfCode": "class Folder(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(256), nullable=False)\n    files = db.relationship('File', backref='folder', lazy=True)\n    module_id = db.Column(db.Integer, db.ForeignKey('edu_module.id'), nullable=False)\n    def __repr__(self):\n        return f\"<Folder {self.name}>\"\nclass File(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    filename = db.Column(db.String(256), nullable=False)",
        "detail": "app.db_models.models",
        "documentation": {}
    },
    {
        "label": "File",
        "kind": 6,
        "importPath": "app.db_models.models",
        "description": "app.db_models.models",
        "peekOfCode": "class File(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    filename = db.Column(db.String(256), nullable=False)\n    content = db.Column(db.String, nullable=False)\n    folder_id = db.Column(db.Integer, db.ForeignKey('folder.id'), nullable=False)\n    def __repr__(self):\n        return f\"<File {self.filename} in folder {self.folder_id}>\"",
        "detail": "app.db_models.models",
        "documentation": {}
    },
    {
        "label": "db",
        "kind": 5,
        "importPath": "app.db_models.models",
        "description": "app.db_models.models",
        "peekOfCode": "db = SQLAlchemy()\nclass EduModule(db.Model):\n    __tablename__ = \"edu_module\"\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(256), nullable=False)\n    folders = db.relationship(\"Folder\", backref=\"edu_module\", lazy=True)\n    def __repr__(self):\n        return f\"<EduModule {self.name}>\"\nclass Folder(db.Model):\n    id = db.Column(db.Integer, primary_key=True)",
        "detail": "app.db_models.models",
        "documentation": {}
    },
    {
        "label": "QuestionForm",
        "kind": 6,
        "importPath": "app.form.forms",
        "description": "app.form.forms",
        "peekOfCode": "class QuestionForm(FlaskForm):\n    \"\"\"\n    A FlaskForm for generating a question using a string input.\n    This form is used to input a question string, which will be processed to generate\n    content based on the user's input. It includes a text field for entering the question \n    and a submit button to initiate the generation process.\n    Attributes:\n        question (StringField): A text field where the user can input the question they want to generate.\n        submit (SubmitField): A button to submit the form and trigger the generation process.\n    Args:",
        "detail": "app.form.forms",
        "documentation": {}
    },
    {
        "label": "ImageForm",
        "kind": 6,
        "importPath": "app.form.forms",
        "description": "app.form.forms",
        "peekOfCode": "class ImageForm(FlaskForm):\n    \"\"\"\n    A FlaskForm for uploading multiple image files and submitting them for processing.\n    This form allows users to upload one or more image files, which can then be processed\n    based on the user's needs. It includes a file upload field for selecting multiple files\n    and a submit button to initiate the file processing.\n    Attributes:\n        files (MultipleFileField): A file upload field that allows the user to select and upload multiple files. \n                                   The field is validated to ensure that at least one file is selected.\n        submit (SubmitField): A button to submit the form and trigger the processing of the uploaded files.",
        "detail": "app.form.forms",
        "documentation": {}
    },
    {
        "label": "generate_image",
        "kind": 2,
        "importPath": "app.routes.content_generator.image_gen",
        "description": "app.routes.content_generator.image_gen",
        "peekOfCode": "def generate_image():\n    form = ImageForm()\n    print(form)\n    if form.validate_on_submit():\n        print(\"Passed validation\")\n        try:\n            file_paths = []\n            with tempfile.TemporaryDirectory() as tmpdir:\n                print(\"About to save files\")\n                # Save uploaded files to the temporary directory",
        "detail": "app.routes.content_generator.image_gen",
        "documentation": {}
    },
    {
        "label": "user_data",
        "kind": 5,
        "importPath": "app.routes.content_generator.image_gen",
        "description": "app.routes.content_generator.image_gen",
        "peekOfCode": "user_data = {\n        \"created_by\": \"lberm007@ucr.edu\",  # Replace with the actual creator identifier\n        \"code_language\": \"javascript\",\n    }\nimage_generator_bp = Blueprint('image_generator_bp', __name__)\n@image_generator_bp.route(\"/image-generator\", methods=['GET', 'POST'])\ndef generate_image():\n    form = ImageForm()\n    print(form)\n    if form.validate_on_submit():",
        "detail": "app.routes.content_generator.image_gen",
        "documentation": {}
    },
    {
        "label": "image_generator_bp",
        "kind": 5,
        "importPath": "app.routes.content_generator.image_gen",
        "description": "app.routes.content_generator.image_gen",
        "peekOfCode": "image_generator_bp = Blueprint('image_generator_bp', __name__)\n@image_generator_bp.route(\"/image-generator\", methods=['GET', 'POST'])\ndef generate_image():\n    form = ImageForm()\n    print(form)\n    if form.validate_on_submit():\n        print(\"Passed validation\")\n        try:\n            file_paths = []\n            with tempfile.TemporaryDirectory() as tmpdir:",
        "detail": "app.routes.content_generator.image_gen",
        "documentation": {}
    },
    {
        "label": "generate_lecture",
        "kind": 2,
        "importPath": "app.routes.content_generator.lecture_gen",
        "description": "app.routes.content_generator.lecture_gen",
        "peekOfCode": "def generate_lecture():\n    form = ImageForm()\n    print(form)\n    if form.validate_on_submit():\n        print(\"Passed validation\")\n        try:\n            file_paths = []\n            with tempfile.TemporaryDirectory() as tmpdir:\n                print(\"About to save files\")\n                # Save uploaded files to the temporary directory",
        "detail": "app.routes.content_generator.lecture_gen",
        "documentation": {}
    },
    {
        "label": "user_data",
        "kind": 5,
        "importPath": "app.routes.content_generator.lecture_gen",
        "description": "app.routes.content_generator.lecture_gen",
        "peekOfCode": "user_data = {\n        \"created_by\": \"lberm007@ucr.edu\",  # Replace with the actual creator identifier\n        \"code_language\": \"javascript\",\n    }\nlecture_generator_bp = Blueprint('lecture_generator_bp', __name__)\n@lecture_generator_bp.route(\"/lecture-generator\", methods=['GET', 'POST'])\ndef generate_lecture():\n    form = ImageForm()\n    print(form)\n    if form.validate_on_submit():",
        "detail": "app.routes.content_generator.lecture_gen",
        "documentation": {}
    },
    {
        "label": "lecture_generator_bp",
        "kind": 5,
        "importPath": "app.routes.content_generator.lecture_gen",
        "description": "app.routes.content_generator.lecture_gen",
        "peekOfCode": "lecture_generator_bp = Blueprint('lecture_generator_bp', __name__)\n@lecture_generator_bp.route(\"/lecture-generator\", methods=['GET', 'POST'])\ndef generate_lecture():\n    form = ImageForm()\n    print(form)\n    if form.validate_on_submit():\n        print(\"Passed validation\")\n        try:\n            file_paths = []\n            with tempfile.TemporaryDirectory() as tmpdir:",
        "detail": "app.routes.content_generator.lecture_gen",
        "documentation": {}
    },
    {
        "label": "generate_text",
        "kind": 2,
        "importPath": "app.routes.content_generator.text_gen",
        "description": "app.routes.content_generator.text_gen",
        "peekOfCode": "def generate_text():\n    form = QuestionForm()\n    if form.validate_on_submit():\n        session[\"question\"] = form.question.data\n        try:\n            print(f\"This is the user question to be generated: {session['question']}\")\n            # Create an event loop to run the function asynchronously\n            loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(loop)\n            generated_content = loop.run_until_complete(",
        "detail": "app.routes.content_generator.text_gen",
        "documentation": {}
    },
    {
        "label": "text_generator_bp",
        "kind": 5,
        "importPath": "app.routes.content_generator.text_gen",
        "description": "app.routes.content_generator.text_gen",
        "peekOfCode": "text_generator_bp = Blueprint(\"text_generator_bp\", __name__)\n# Should be changed later on to get user information\nuser_data = {\n        \"created_by\": \"lberm007@ucr.edu\",  # Replace with the actual creator identifier\n        \"code_language\": \"javascript\",\n    }\n@text_generator_bp.route(\"/text-generator\", methods=['GET', 'POST'])\ndef generate_text():\n    form = QuestionForm()\n    if form.validate_on_submit():",
        "detail": "app.routes.content_generator.text_gen",
        "documentation": {}
    },
    {
        "label": "user_data",
        "kind": 5,
        "importPath": "app.routes.content_generator.text_gen",
        "description": "app.routes.content_generator.text_gen",
        "peekOfCode": "user_data = {\n        \"created_by\": \"lberm007@ucr.edu\",  # Replace with the actual creator identifier\n        \"code_language\": \"javascript\",\n    }\n@text_generator_bp.route(\"/text-generator\", methods=['GET', 'POST'])\ndef generate_text():\n    form = QuestionForm()\n    if form.validate_on_submit():\n        session[\"question\"] = form.question.data\n        try:",
        "detail": "app.routes.content_generator.text_gen",
        "documentation": {}
    },
    {
        "label": "save_generated_content",
        "kind": 2,
        "importPath": "app.routes.content_generator.utils",
        "description": "app.routes.content_generator.utils",
        "peekOfCode": "def save_generated_content(generated_content, module_name=\"Module\"):\n    \"\"\"\n    Save the generated content to the database, including the module, folders, and files.\n    This function processes the generated content by:\n    1. Creating and saving an `EduModule` instance.\n    2. Iterating over the generated content to create and save corresponding `Folder` and `File` instances.\n    3. Temporarily storing files in a directory before saving their binary contents to the database.\n    Args:\n        generated_content (list of tuples): The content generated by the module, where each tuple contains:\n            - question_title (str): The title of the question (used as the folder name).",
        "detail": "app.routes.content_generator.utils",
        "documentation": {}
    },
    {
        "label": "home",
        "kind": 2,
        "importPath": "app.routes.generic_routes.routes",
        "description": "app.routes.generic_routes.routes",
        "peekOfCode": "def home():\n    return render_template(\"home.html\")\n@routes.route('/license')\ndef license():\n    return render_template('license.html')",
        "detail": "app.routes.generic_routes.routes",
        "documentation": {}
    },
    {
        "label": "license",
        "kind": 2,
        "importPath": "app.routes.generic_routes.routes",
        "description": "app.routes.generic_routes.routes",
        "peekOfCode": "def license():\n    return render_template('license.html')",
        "detail": "app.routes.generic_routes.routes",
        "documentation": {}
    },
    {
        "label": "routes",
        "kind": 5,
        "importPath": "app.routes.generic_routes.routes",
        "description": "app.routes.generic_routes.routes",
        "peekOfCode": "routes = Blueprint(\"routes\", __name__)\n@routes.route('/', methods=['GET', 'POST'])\n@routes.route('/home', methods=['GET', 'POST'])\ndef home():\n    return render_template(\"home.html\")\n@routes.route('/license')\ndef license():\n    return render_template('license.html')",
        "detail": "app.routes.generic_routes.routes",
        "documentation": {}
    },
    {
        "label": "view_modules",
        "kind": 2,
        "importPath": "app.routes.module_retrieval.module_retrieval",
        "description": "app.routes.module_retrieval.module_retrieval",
        "peekOfCode": "def view_modules():\n    \"\"\"Gets the modules from the database and returns the module data which is just the name \n    and the id for now\n    Returns:\n        renders the template\n    \"\"\"\n    modules = EduModule.query.all()\n    module_data = []\n    for module in modules:\n        module_data.append({",
        "detail": "app.routes.module_retrieval.module_retrieval",
        "documentation": {}
    },
    {
        "label": "view_module_details",
        "kind": 2,
        "importPath": "app.routes.module_retrieval.module_retrieval",
        "description": "app.routes.module_retrieval.module_retrieval",
        "peekOfCode": "def view_module_details(module_name,module_id):\n    module = EduModule.query.filter_by(id=module_id).first()\n    folder_data = []\n    for folder in module.folders:\n        folder_data.append({\n            'id': folder.id,\n            'folder_name': folder.name,\n        })\n    print(f\"This is the folder data {folder_data}\")\n    session[\"folder_data\"] = folder_data",
        "detail": "app.routes.module_retrieval.module_retrieval",
        "documentation": {}
    },
    {
        "label": "module_retrieval_bp",
        "kind": 5,
        "importPath": "app.routes.module_retrieval.module_retrieval",
        "description": "app.routes.module_retrieval.module_retrieval",
        "peekOfCode": "module_retrieval_bp = Blueprint('module_retrieval_bp', __name__)\n@module_retrieval_bp.route(\"/retrieve_modules\", methods=['GET', 'POST'])\ndef view_modules():\n    \"\"\"Gets the modules from the database and returns the module data which is just the name \n    and the id for now\n    Returns:\n        renders the template\n    \"\"\"\n    modules = EduModule.query.all()\n    module_data = []",
        "detail": "app.routes.module_retrieval.module_retrieval",
        "documentation": {}
    },
    {
        "label": "view_modules",
        "kind": 2,
        "importPath": "app.routes.module_retrieval.view_modules",
        "description": "app.routes.module_retrieval.view_modules",
        "peekOfCode": "def view_modules():\n    modules = EduModule.query.all()\n    module_data = []\n    for module in modules:\n        module_data.append({\n            'id': module.id,\n            'name': module.name,\n        })\n    # Debugging\n    print(module_data)",
        "detail": "app.routes.module_retrieval.view_modules",
        "documentation": {}
    },
    {
        "label": "view_module_details",
        "kind": 2,
        "importPath": "app.routes.module_retrieval.view_modules",
        "description": "app.routes.module_retrieval.view_modules",
        "peekOfCode": "def view_module_details(module_name,module_id):\n    module = EduModule.query.filter_by(id=module_id).first()\n    folder_data = []\n    for folder in module.folders:\n        files_data = []\n        for file in folder.files:\n            files_data.append({\n                'id': file.id,\n                'filename': file.filename,\n                'content': file.content.decode('utf-8', errors='ignore') if file.content else ''",
        "detail": "app.routes.module_retrieval.view_modules",
        "documentation": {}
    },
    {
        "label": "view_folder",
        "kind": 2,
        "importPath": "app.routes.module_retrieval.view_modules",
        "description": "app.routes.module_retrieval.view_modules",
        "peekOfCode": "def view_folder(folder_name, folder_id):\n    folder = Folder.query.filter_by(id=folder_id).first()\n    if not folder:\n        return \"<h1>Folder not found</h1>\", 404\n    files_data = [{\n        \"filename\": file.filename,\n        \"content\": file.content\n    } for file in folder.files]\n    print(\"This is the files data\", files_data)  # Debugging\n    file_names = {file.get(\"filename\") for file in files_data}",
        "detail": "app.routes.module_retrieval.view_modules",
        "documentation": {}
    },
    {
        "label": "view_adaptive_quiz",
        "kind": 2,
        "importPath": "app.routes.module_retrieval.view_modules",
        "description": "app.routes.module_retrieval.view_modules",
        "peekOfCode": "def view_adaptive_quiz(folder_name, folder_id):\n    files_data = session.get(\"files_data\")\n    if not files_data:\n        return \"<h1>No files data found in session</h1>\", 404\n    # Re-fetch file contents if needed\n    folder = Folder.query.filter_by(id=folder_id).first()\n    if not folder:\n        return \"<h1>Folder not found</h1>\", 404\n    # Retrieve full file data based on filenames stored in the session\n    full_files_data = [{",
        "detail": "app.routes.module_retrieval.view_modules",
        "documentation": {}
    },
    {
        "label": "determine_file_type",
        "kind": 2,
        "importPath": "app.routes.module_retrieval.view_modules",
        "description": "app.routes.module_retrieval.view_modules",
        "peekOfCode": "def determine_file_type(file_names):\n    adaptive_files = {'question.html', 'server.js', 'server.py', 'solution.html', 'info.json'}\n    nonadaptive_files = {'question.html', 'info.json'}\n    if file_names == nonadaptive_files:\n        return \"NonAdaptive\"\n    elif file_names == adaptive_files:\n        return \"Adaptive\"\n    else:\n        return \"Lecture\"\n#     # Question Module Files",
        "detail": "app.routes.module_retrieval.view_modules",
        "documentation": {}
    },
    {
        "label": "view_modules_bp",
        "kind": 5,
        "importPath": "app.routes.module_retrieval.view_modules",
        "description": "app.routes.module_retrieval.view_modules",
        "peekOfCode": "view_modules_bp = Blueprint('view_modules_bp', __name__)\n@view_modules_bp.route(\"/view_modules\", methods=['GET', 'POST'])\ndef view_modules():\n    modules = EduModule.query.all()\n    module_data = []\n    for module in modules:\n        module_data.append({\n            'id': module.id,\n            'name': module.name,\n        })",
        "detail": "app.routes.module_retrieval.view_modules",
        "documentation": {}
    },
    {
        "label": "render_adaptive_quiz",
        "kind": 2,
        "importPath": "app.routes.quiz_views.adaptive_questions",
        "description": "app.routes.quiz_views.adaptive_questions",
        "peekOfCode": "def render_adaptive_quiz():\n    try:\n        folder_id = session[\"folder_id\"]\n        folder_name, full_files_data = retrieve_files_folder(folder_id)\n        with tempfile.TemporaryDirectory() as tmpdir:\n            for file in full_files_data:\n                tempfile_path = os.path.join(tmpdir, file.get(\"filename\"))\n                content = file.get(\"content\", \"\")\n                if isinstance(content, str):\n                    content = content.encode('utf-8')  # Convert string to bytes",
        "detail": "app.routes.quiz_views.adaptive_questions",
        "documentation": {}
    },
    {
        "label": "adaptive_quiz_bp",
        "kind": 5,
        "importPath": "app.routes.quiz_views.adaptive_questions",
        "description": "app.routes.quiz_views.adaptive_questions",
        "peekOfCode": "adaptive_quiz_bp = Blueprint('adaptive_quiz_bp', __name__)\n@adaptive_quiz_bp.route(\"/quiz_overview/_adaptive\", methods=['GET', 'POST'])\ndef render_adaptive_quiz():\n    try:\n        folder_id = session[\"folder_id\"]\n        folder_name, full_files_data = retrieve_files_folder(folder_id)\n        with tempfile.TemporaryDirectory() as tmpdir:\n            for file in full_files_data:\n                tempfile_path = os.path.join(tmpdir, file.get(\"filename\"))\n                content = file.get(\"content\", \"\")",
        "detail": "app.routes.quiz_views.adaptive_questions",
        "documentation": {}
    },
    {
        "label": "determine_file_type",
        "kind": 2,
        "importPath": "app.routes.quiz_views.quiz_overview",
        "description": "app.routes.quiz_views.quiz_overview",
        "peekOfCode": "def determine_file_type(file_names:dict)->str:\n    adaptive_files = {'question.html', 'server.js', 'server.py', 'solution.html', 'info.json'}\n    nonadaptive_files = {'question.html', 'info.json'}\n    if file_names == nonadaptive_files:\n        return \"NonAdaptive\"\n    elif file_names == adaptive_files:\n        return \"Adaptive\"\n    else:\n        return \"Lecture\"\n@quiz_overview_bp.route(\"/quiz_overview/<folder_id>\", methods=['GET', 'POST'])",
        "detail": "app.routes.quiz_views.quiz_overview",
        "documentation": {}
    },
    {
        "label": "module_details",
        "kind": 2,
        "importPath": "app.routes.quiz_views.quiz_overview",
        "description": "app.routes.quiz_views.quiz_overview",
        "peekOfCode": "def module_details(folder_id):\n    folder = Folder.query.filter_by(id=folder_id).first()\n    if not folder:\n        return \"<h1>Quiz Not Found</h1>\", 404\n    # Get the name of the files\n    files_names = [{\n        \"filename\": file.filename,\n    }for file in folder.files]\n    # Store folder information  in session\n    session[\"folder_id\"] = folder.id",
        "detail": "app.routes.quiz_views.quiz_overview",
        "documentation": {}
    },
    {
        "label": "download_module",
        "kind": 2,
        "importPath": "app.routes.quiz_views.quiz_overview",
        "description": "app.routes.quiz_views.quiz_overview",
        "peekOfCode": "def download_module():\n    folder_id = session[\"folder_id\"]\n    print(folder_id)\n    folder_name, full_files_data = retrieve_files_folder(folder_id)\n    tempfile_paths = []\n    with tempfile.TemporaryDirectory() as tmpdir:\n        for file in full_files_data:\n            tempfile_path = os.path.join(tmpdir, file.get(\"filename\"))\n            content = file.get(\"content\", \"\")\n            # Ensure the content is in bytes, encoding if necessary",
        "detail": "app.routes.quiz_views.quiz_overview",
        "documentation": {}
    },
    {
        "label": "download_all_modules",
        "kind": 2,
        "importPath": "app.routes.quiz_views.quiz_overview",
        "description": "app.routes.quiz_views.quiz_overview",
        "peekOfCode": "def download_all_modules():\n    \"\"\"\n    Downloads a combined ZIP file containing ZIP files for all modules and folders in the session.\n    The function retrieves folder data from the session, processes each folder to create individual ZIP files, \n    and then combines these ZIP files into a single downloadable ZIP file.\n    Returns:\n        Response: A Flask response object that triggers the download of the combined ZIP file.\n    \"\"\"\n    folder_data = session.get(\"folder_data\", [])\n    print(\"Downloading all\")",
        "detail": "app.routes.quiz_views.quiz_overview",
        "documentation": {}
    },
    {
        "label": "quiz_overview_bp",
        "kind": 5,
        "importPath": "app.routes.quiz_views.quiz_overview",
        "description": "app.routes.quiz_views.quiz_overview",
        "peekOfCode": "quiz_overview_bp = Blueprint('quiz_overview_bp', __name__)\n# This needs to be fixed eventually with databases and the info.jsonm file \ndef determine_file_type(file_names:dict)->str:\n    adaptive_files = {'question.html', 'server.js', 'server.py', 'solution.html', 'info.json'}\n    nonadaptive_files = {'question.html', 'info.json'}\n    if file_names == nonadaptive_files:\n        return \"NonAdaptive\"\n    elif file_names == adaptive_files:\n        return \"Adaptive\"\n    else:",
        "detail": "app.routes.quiz_views.quiz_overview",
        "documentation": {}
    },
    {
        "label": "retrieve_files_session",
        "kind": 2,
        "importPath": "app.routes.quiz_views.utils",
        "description": "app.routes.quiz_views.utils",
        "peekOfCode": "def retrieve_files_session(module_name: str, folder_name: str, folder_id: int) -> Union[List[Dict[str, str]], tuple]:\n    \"\"\"\n    Retrieves file data from the session and filters it based on the folder content.\n    This function fetches the file data stored in the user's session. If the session does not contain\n    the expected data, it returns an error message and a 404 status code. The function then retrieves\n    the corresponding folder from the database, decodes the content of the files (assuming they are stored \n    as binary), and returns a list of dictionaries containing the filenames and their respective content.\n    Args:\n        module_name (str): The name of the module to which the files belong.\n        folder_name (str): The name of the folder containing the files.",
        "detail": "app.routes.quiz_views.utils",
        "documentation": {}
    },
    {
        "label": "retrieve_files_folder",
        "kind": 2,
        "importPath": "app.routes.quiz_views.utils",
        "description": "app.routes.quiz_views.utils",
        "peekOfCode": "def retrieve_files_folder(folder_id: int) -> Union[Tuple[str, List[Dict[str, str]]], str]:\n    \"\"\"\n    Retrieve the name of the current folder and its associated files from the database.\n    This function retrieves the folder ID from the current session, fetches the corresponding\n    folder from the database, and returns the folder's name along with the list of files contained\n    within the folder. Each file's data includes the filename and the content decoded as a UTF-8 string.\n    Returns:\n        Union[Tuple[str, List[Dict[str, str]]], str]: \n            - If successful, returns a tuple containing:\n                - folder_name (str): The name of the folder.",
        "detail": "app.routes.quiz_views.utils",
        "documentation": {}
    },
    {
        "label": "generate_from_text",
        "kind": 2,
        "importPath": "app.quiz_generator",
        "description": "app.quiz_generator",
        "peekOfCode": "def generate_from_text():\n    text = request.form.get(\"user_question\")\n    if not text:\n        return jsonify({\"error\": \"No text provided\"}), 400\n    try:\n        print(f\"This is the user question to be generated: {text}\")\n        # Use asyncio to run the generate function\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n        generated_content = loop.run_until_complete(generate_module(user_input=text, user_data=user_data))",
        "detail": "app.quiz_generator",
        "documentation": {}
    },
    {
        "label": "generate_from_image",
        "kind": 2,
        "importPath": "app.quiz_generator",
        "description": "app.quiz_generator",
        "peekOfCode": "def generate_from_image():\n    files = request.files.getlist('user_images')\n    if not files:\n        return jsonify({\"error\": \"No files provided\"}), 400\n    try:\n        with tempfile.TemporaryDirectory() as tmpdir:\n            file_paths = []\n            for file in files:\n                filename = secure_filename(file.filename)\n                file_path = os.path.join(tmpdir, filename)",
        "detail": "app.quiz_generator",
        "documentation": {}
    },
    {
        "label": "download_zip",
        "kind": 2,
        "importPath": "app.quiz_generator",
        "description": "app.quiz_generator",
        "peekOfCode": "def download_zip():\n    temp_dirs = session.get(\"temp_dir\",\"\")\n    print(\"These are teh temp dirs:,\",temp_dirs)\n    print(\"Going to download \\n\")\n    for temp_dir in temp_dirs:\n        zip_file = save_temp_dir_as_zip(temp_dir)\n        return send_file(zip_file, mimetype='application/zip', as_attachment=True, download_name='module.zip')\n    return jsonify(temp_dirs)",
        "detail": "app.quiz_generator",
        "documentation": {}
    },
    {
        "label": "user_data",
        "kind": 5,
        "importPath": "app.quiz_generator",
        "description": "app.quiz_generator",
        "peekOfCode": "user_data = {\n        \"created_by\": \"lberm007@ucr.edu\",  # Replace with the actual creator identifier\n        \"code_language\": \"javascript\",\n    }\nquiz_generator = Blueprint('quiz_generator', __name__)\n@quiz_generator.route('/generate_from_text', methods=['POST'])\ndef generate_from_text():\n    text = request.form.get(\"user_question\")\n    if not text:\n        return jsonify({\"error\": \"No text provided\"}), 400",
        "detail": "app.quiz_generator",
        "documentation": {}
    },
    {
        "label": "quiz_generator",
        "kind": 5,
        "importPath": "app.quiz_generator",
        "description": "app.quiz_generator",
        "peekOfCode": "quiz_generator = Blueprint('quiz_generator', __name__)\n@quiz_generator.route('/generate_from_text', methods=['POST'])\ndef generate_from_text():\n    text = request.form.get(\"user_question\")\n    if not text:\n        return jsonify({\"error\": \"No text provided\"}), 400\n    try:\n        print(f\"This is the user question to be generated: {text}\")\n        # Use asyncio to run the generate function\n        loop = asyncio.new_event_loop()",
        "detail": "app.quiz_generator",
        "documentation": {}
    },
    {
        "label": "EmbeddingDataFrame",
        "kind": 6,
        "importPath": "src.data_handler.embedded_dataframe",
        "description": "src.data_handler.embedded_dataframe",
        "peekOfCode": "class EmbeddingDataFrame:\n    \"\"\"\n    Processes and validates a DataFrame for embedding-based searches.\n    This class is designed to load a CSV file, validate the structure of the DataFrame, \n    and ensure that the specified columns for embedding, input examples, and corresponding \n    outputs are valid. The `validate_dataframe` method checks for the presence of the \n    required columns and handles missing data in the output column.\n    Attributes:\n        csv_path (str): Path to the CSV file to be processed.\n        embedding_column (str): The name of the column containing the embeddings.",
        "detail": "src.data_handler.embedded_dataframe",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.data_handler.embedded_dataframe",
        "description": "src.data_handler.embedded_dataframe",
        "peekOfCode": "def main():\n    base_dir = os.path.dirname(os.path.abspath(__file__))\n    csv_path = os.path.join(base_dir, '..', 'data', 'Question_Embedding_20240128.csv')\n    logger.debug(f\"Base directory set to: {base_dir}\")\n    logger.debug(f\"CSV path for question embeddings constructed: {csv_path}\")\n    try:\n        df = EmbeddingDataFrame(csv_path,\"question_embedding\", \"question\", \"question.html\")\n    except ValueError as e:\n        logger.error(f\"Failed to Create embedded dataframe error {e}\")\nif __name__ == \"__main__\":",
        "detail": "src.data_handler.embedded_dataframe",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.data_handler.embedded_dataframe",
        "description": "src.data_handler.embedded_dataframe",
        "peekOfCode": "logger = get_logger(__name__)\n@dataclass\nclass EmbeddingDataFrame:\n    \"\"\"\n    Processes and validates a DataFrame for embedding-based searches.\n    This class is designed to load a CSV file, validate the structure of the DataFrame, \n    and ensure that the specified columns for embedding, input examples, and corresponding \n    outputs are valid. The `validate_dataframe` method checks for the presence of the \n    required columns and handles missing data in the output column.\n    Attributes:",
        "detail": "src.data_handler.embedded_dataframe",
        "documentation": {}
    },
    {
        "label": "ExampleBasedPromptDataFrame",
        "kind": 6,
        "importPath": "src.data_handler.example_based_prompt_formatter",
        "description": "src.data_handler.example_based_prompt_formatter",
        "peekOfCode": "class ExampleBasedPromptDataFrame:\n    example_input_column: str\n    example_output_column: str\n    api_key: str\n    embedding_engine: str = \"text-embedding-ada-002\"\n    embedding_columns: str = \"question_embedding\"\n    embedding_file: str = os.path.join(base_dir, '..', 'data', 'Question_Embedding_20240128.csv')\n    df_config: EmbeddingDataFrame = field(init=False)\n    llm_config: LLMConfig = field(init=False)\n    embedding_generator: GenerateEmbeddings = field(init=False)",
        "detail": "src.data_handler.example_based_prompt_formatter",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.data_handler.example_based_prompt_formatter",
        "description": "src.data_handler.example_based_prompt_formatter",
        "peekOfCode": "def main():\n    # Define column names\n    search_column = \"question\"\n    output_column = \"question.html\"\n    # Import API key\n    from ..credentials import api_key\n    # Initialize the formatter with the provided API key and column names\n    formatter = ExampleBasedPromptDataFrame(\n        example_input_column=search_column, \n        example_output_column=output_column, ",
        "detail": "src.data_handler.example_based_prompt_formatter",
        "documentation": {}
    },
    {
        "label": "base_dir",
        "kind": 5,
        "importPath": "src.data_handler.example_based_prompt_formatter",
        "description": "src.data_handler.example_based_prompt_formatter",
        "peekOfCode": "base_dir = os.path.dirname(os.path.abspath(__file__))\n@dataclass\nclass ExampleBasedPromptDataFrame:\n    example_input_column: str\n    example_output_column: str\n    api_key: str\n    embedding_engine: str = \"text-embedding-ada-002\"\n    embedding_columns: str = \"question_embedding\"\n    embedding_file: str = os.path.join(base_dir, '..', 'data', 'Question_Embedding_20240128.csv')\n    df_config: EmbeddingDataFrame = field(init=False)",
        "detail": "src.data_handler.example_based_prompt_formatter",
        "documentation": {}
    },
    {
        "label": "GenerateEmbeddings",
        "kind": 6,
        "importPath": "src.data_handler.generate_embeddings",
        "description": "src.data_handler.generate_embeddings",
        "peekOfCode": "class GenerateEmbeddings:\n    \"\"\"\n    A class to generate and display embeddings for given text queries using a specified language model.\n    Attributes:\n        llm_config (LLMConfig): Configuration object for the language model, including API key and model name.\n    Methods:\n        get_embeddings_sync(query: str) -> List[float]:\n            Generates embeddings for a given text query using the specified language model.\n        pretty_print_embeddings(queries: List[str], length_embeddings: int = 10) -> None:\n            Generates and prints embeddings for a list of text queries, showing only the first few values ",
        "detail": "src.data_handler.generate_embeddings",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.data_handler.generate_embeddings",
        "description": "src.data_handler.generate_embeddings",
        "peekOfCode": "def main():\n    queries = [\n        \"What is a car?\",\n        \"What is the capital of France?\",\n        \"This is just some text\"\n    ]\n    # Initialize the LLM configuration\n    llm_config = LLMConfig(\n        api_key=api_key,\n        model=\"text-embedding-ada-002\",",
        "detail": "src.data_handler.generate_embeddings",
        "documentation": {}
    },
    {
        "label": "process_embeddings",
        "kind": 2,
        "importPath": "src.data_handler.process_embeddings",
        "description": "src.data_handler.process_embeddings",
        "peekOfCode": "def process_embeddings(df: pd.DataFrame, embedding_column: str) -> pd.DataFrame:\n    \"\"\"Converts embedding column to float values\n    Args:\n        df (pd.DataFrame): DataFrame to be processed\n        embedding_column (str): Name of the question embeddings\n    Raises:\n        ValueError: Error in processing embeddings\n    Returns:\n        pd.DataFrame: DataFrame after being processed\n    \"\"\"",
        "detail": "src.data_handler.process_embeddings",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.data_handler.process_embeddings",
        "description": "src.data_handler.process_embeddings",
        "peekOfCode": "def main() -> None:\n    base_dir = os.path.dirname(os.path.abspath(__file__))\n    csv_path = os.path.join(base_dir, '..', 'data', 'Question_Embedding_20240128.csv')\n    logger.debug(f\"Base directory set to: {base_dir}\")\n    logger.debug(f\"CSV path for question embeddings constructed: {csv_path}\")\n    try:\n        df = pd.read_csv(csv_path)\n        logger.info(f\"Successfully loaded CSV file with {len(df)} records from {csv_path}\")\n    except FileNotFoundError:\n        logger.exception(f\"CSV file not found at {csv_path}\")",
        "detail": "src.data_handler.process_embeddings",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.data_handler.process_embeddings",
        "description": "src.data_handler.process_embeddings",
        "peekOfCode": "logger = get_logger(__name__)\ndef process_embeddings(df: pd.DataFrame, embedding_column: str) -> pd.DataFrame:\n    \"\"\"Converts embedding column to float values\n    Args:\n        df (pd.DataFrame): DataFrame to be processed\n        embedding_column (str): Name of the question embeddings\n    Raises:\n        ValueError: Error in processing embeddings\n    Returns:\n        pd.DataFrame: DataFrame after being processed",
        "detail": "src.data_handler.process_embeddings",
        "documentation": {}
    },
    {
        "label": "SemanticSearchManager",
        "kind": 6,
        "importPath": "src.data_handler.semantic_search",
        "description": "src.data_handler.semantic_search",
        "peekOfCode": "class SemanticSearchManager:\n    \"\"\"\n    A class to manage the configuration, validation, and processing of a DataFrame for semantic search operations.\n    This class handles validating the DataFrame, generating embeddings for input queries, \n    and calculating similarity scores between the query embeddings and the embeddings stored in the DataFrame.\n    Attributes:\n        embedded_dataframe_config (EmbeddingDataFrame): Configuration object containing the DataFrame \n            and information about the relevant columns used in the semantic search.\n        embedding_generator (GenerateEmbeddings): An instance responsible for generating embeddings \n            using a language model.",
        "detail": "src.data_handler.semantic_search",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.data_handler.semantic_search",
        "description": "src.data_handler.semantic_search",
        "peekOfCode": "def main():\n    # Set up file paths and column names\n    base_dir = os.path.dirname(os.path.abspath(__file__))\n    csv_path = os.path.join(base_dir, '..', 'data', 'Question_Embedding_20240128.csv')\n    embedding_column = \"question_embedding\"\n    search_column = \"question\"\n    output_column = \"question.html\"\n    # Initialize the DataFrame configuration\n    df_config = EmbeddingDataFrame(csv_path, embedding_column, search_column, output_column)\n    # Initialize the LLM configuration",
        "detail": "src.data_handler.semantic_search",
        "documentation": {}
    },
    {
        "label": "isvalid_csv",
        "kind": 2,
        "importPath": "src.data_handler.utils",
        "description": "src.data_handler.utils",
        "peekOfCode": "def isvalid_csv(csv_path: str) -> bool:\n    \"\"\"\n    Checks if the given path is a valid CSV file.\n    Parameters:\n    - csv_path (str): The path to the CSV file.\n    Returns:\n    - bool: True if the file exists and is a valid CSV, False otherwise.\n    \"\"\"\n    return os.path.isfile(csv_path)\ndef load_df(csv_path: str) -> pd.DataFrame:",
        "detail": "src.data_handler.utils",
        "documentation": {}
    },
    {
        "label": "load_df",
        "kind": 2,
        "importPath": "src.data_handler.utils",
        "description": "src.data_handler.utils",
        "peekOfCode": "def load_df(csv_path: str) -> pd.DataFrame:\n    \"\"\"\n    Loads a CSV file into a DataFrame if the file is valid.\n    Parameters:\n    - csv_path (str): The path to the CSV file.\n    Returns:\n    - pd.DataFrame: The loaded DataFrame, or None if the file is not valid.\n    \"\"\"\n    if isvalid_csv(csv_path):\n        try:",
        "detail": "src.data_handler.utils",
        "documentation": {}
    },
    {
        "label": "is_valid_column",
        "kind": 2,
        "importPath": "src.data_handler.utils",
        "description": "src.data_handler.utils",
        "peekOfCode": "def is_valid_column(df:pd.DataFrame, column_to_check:str)->bool:\n    \"\"\"Checks to see if column is in dataframe\n    Args:\n        df (pd.DataFrame): dataframe\n        column_to_check (str): column to check \n    Returns:\n        bool: returns true if column in dataframe\n    \"\"\"\n    return (column_to_check in df.columns)\ndef is_valid_columns(df:pd.DataFrame, columns: List[str])-> bool:",
        "detail": "src.data_handler.utils",
        "documentation": {}
    },
    {
        "label": "is_valid_columns",
        "kind": 2,
        "importPath": "src.data_handler.utils",
        "description": "src.data_handler.utils",
        "peekOfCode": "def is_valid_columns(df:pd.DataFrame, columns: List[str])-> bool:\n    invalid_columns = [column for column in columns if not is_valid_column(df, column)]\n    if invalid_columns:\n        print(f\"Columns {[column for column in invalid_columns]} are not valid.\")\n        return False\n    else:\n        return True",
        "detail": "src.data_handler.utils",
        "documentation": {}
    },
    {
        "label": "validate_and_process_csv",
        "kind": 2,
        "importPath": "src.data_handler.validate_process_csv",
        "description": "src.data_handler.validate_process_csv",
        "peekOfCode": "def validate_and_process_csv(csv_path: str, embedding_column: str) -> pd.DataFrame:\n    \"\"\"\n    Validates the CSV file and processes the embedding column.\n    Parameters:\n    - csv_path (str): The path to the CSV file.\n    - embedding_column (str): The name of the column containing embeddings.\n    Returns:\n    - pd.DataFrame: The processed DataFrame with embeddings.\n    Raises:\n    - ValueError: If the CSV file is invalid or processing fails.",
        "detail": "src.data_handler.validate_process_csv",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.data_handler.validate_process_csv",
        "description": "src.data_handler.validate_process_csv",
        "peekOfCode": "def main() -> None:\n    base_dir = os.path.dirname(os.path.abspath(__file__))\n    csv_path = os.path.join(base_dir, '..', 'data', 'Question_Embedding_20240128.csv')\n    logger.debug(f\"Base directory set to: {base_dir}\")\n    logger.debug(f\"CSV path for question embeddings constructed: {csv_path}\")\n    try:\n        df = pd.read_csv(csv_path)\n        logger.info(f\"Successfully loaded CSV file with {len(df)} records from {csv_path}\")\n    except FileNotFoundError:\n        logger.exception(f\"CSV file not found at {csv_path}\")",
        "detail": "src.data_handler.validate_process_csv",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.data_handler.validate_process_csv",
        "description": "src.data_handler.validate_process_csv",
        "peekOfCode": "logger = get_logger(__name__)\ndef validate_and_process_csv(csv_path: str, embedding_column: str) -> pd.DataFrame:\n    \"\"\"\n    Validates the CSV file and processes the embedding column.\n    Parameters:\n    - csv_path (str): The path to the CSV file.\n    - embedding_column (str): The name of the column containing embeddings.\n    Returns:\n    - pd.DataFrame: The processed DataFrame with embeddings.\n    Raises:",
        "detail": "src.data_handler.validate_process_csv",
        "documentation": {}
    },
    {
        "label": "user_data",
        "kind": 5,
        "importPath": "src.gestalt_module_generator.generate_gestalt_metadata",
        "description": "src.gestalt_module_generator.generate_gestalt_metadata",
        "peekOfCode": "user_data = {\n    \"created_by\": \"lberm007@ucr.edu\",  # Replace with the actual creator identifier\n    \"code_language\": \"javascript\",\n}\nasync def  generate_module_metadata(question: str, user_data: dict) -> dict:\n    initial_metadata = await classify_question(question)\n    metadata = {\n        **initial_metadata.get(\"metadata\"),  # Unpack initial metadata into the new dictionary\n        \"createdBy\": user_data.get(\"created_by\"),  # Add additional metadata fields\n        \"qType\": \"num\",",
        "detail": "src.gestalt_module_generator.generate_gestalt_metadata",
        "documentation": {}
    },
    {
        "label": "user_data",
        "kind": 5,
        "importPath": "src.gestalt_module_generator.generate_lecture",
        "description": "src.gestalt_module_generator.generate_lecture",
        "peekOfCode": "user_data =  user_data = {\n        \"created_by\": \"lberm007@ucr.edu\",  # Replace with the actual creator identifier\n        \"code_language\": \"javascript\",\n    }\n# Step 1: Define the functions\nasync def extract_summary_and_key_concepts(image_paths:List[str]):\n    print(\"Extracting summary and key concepts...\\n\")\n    response = await extract_summary_and_key_concepts_image(image_paths=image_paths)\n    html = await generate_lecture_summary_html(response)\n    print(\"Finished extracting summary and key concepts.\")",
        "detail": "src.gestalt_module_generator.generate_lecture",
        "documentation": {}
    },
    {
        "label": "map_extracted_computational_questions",
        "kind": 2,
        "importPath": "src.gestalt_module_generator.map_extracted_computational_questions",
        "description": "src.gestalt_module_generator.map_extracted_computational_questions",
        "peekOfCode": "def map_extracted_computational_questions(response: Dict) -> List[Dict[str, str]]:\n    \"\"\"\n    Maps extracted computational questions and their solutions from the provided response.\n    This function takes a response dictionary containing extracted questions and their details, checks if each \n    question is complete, and constructs a corresponding solution guide. It returns a list of dictionaries where \n    each dictionary represents a question and its corresponding solution.\n    Args:\n        response (Dict): The dictionary containing extracted questions and their details. The expected format \n                         includes keys like 'extracted_question', 'question', 'complete', 'solution', 'image_req', \n                         and 'external_data_req'.",
        "detail": "src.gestalt_module_generator.map_extracted_computational_questions",
        "documentation": {}
    },
    {
        "label": "is_adaptive_question",
        "kind": 2,
        "importPath": "src.gestalt_module_generator.utils",
        "description": "src.gestalt_module_generator.utils",
        "peekOfCode": "def is_adaptive_question(metadata_dict: dict) -> bool:\n    if not isinstance(metadata_dict, dict):\n        raise TypeError(f\"Expected a dictionary, but got {type(metadata_dict).__name__} instead.\")\n    if \"isAdaptive\" not in metadata_dict:\n        raise KeyError(\"Key 'isAdaptive' not found in the dictionary.\")\n    return metadata_dict[\"isAdaptive\"]\ndef extract_question_title(metadata_dict: dict) -> str:\n    if \"title\" not in metadata_dict:\n        raise KeyError(\"Key 'title' not found in the dictionary.\")\n    return metadata_dict.get(\"title\", \"Undefined Title\")",
        "detail": "src.gestalt_module_generator.utils",
        "documentation": {}
    },
    {
        "label": "extract_question_title",
        "kind": 2,
        "importPath": "src.gestalt_module_generator.utils",
        "description": "src.gestalt_module_generator.utils",
        "peekOfCode": "def extract_question_title(metadata_dict: dict) -> str:\n    if \"title\" not in metadata_dict:\n        raise KeyError(\"Key 'title' not found in the dictionary.\")\n    return metadata_dict.get(\"title\", \"Undefined Title\")\ndef is_image_file_extension(file_path: str) -> bool:\n    return file_path.endswith(('.png', '.jpg', '.jpeg'))\ndef convert_pdf_to_images(pdf_path: str, tempdir: str) -> List[str]:\n    image_paths = []\n    document = fitz.open(pdf_path)\n    base_name = os.path.basename(pdf_path).replace(\".pdf\", \"\")",
        "detail": "src.gestalt_module_generator.utils",
        "documentation": {}
    },
    {
        "label": "is_image_file_extension",
        "kind": 2,
        "importPath": "src.gestalt_module_generator.utils",
        "description": "src.gestalt_module_generator.utils",
        "peekOfCode": "def is_image_file_extension(file_path: str) -> bool:\n    return file_path.endswith(('.png', '.jpg', '.jpeg'))\ndef convert_pdf_to_images(pdf_path: str, tempdir: str) -> List[str]:\n    image_paths = []\n    document = fitz.open(pdf_path)\n    base_name = os.path.basename(pdf_path).replace(\".pdf\", \"\")\n    logging.info(\"Converting PDF to Collection of Images\")\n    for page_number in range(document.page_count):\n        filename = f\"{base_name}_pg_{page_number + 1}.jpg\"\n        filepath = os.path.join(tempdir, filename)",
        "detail": "src.gestalt_module_generator.utils",
        "documentation": {}
    },
    {
        "label": "convert_pdf_to_images",
        "kind": 2,
        "importPath": "src.gestalt_module_generator.utils",
        "description": "src.gestalt_module_generator.utils",
        "peekOfCode": "def convert_pdf_to_images(pdf_path: str, tempdir: str) -> List[str]:\n    image_paths = []\n    document = fitz.open(pdf_path)\n    base_name = os.path.basename(pdf_path).replace(\".pdf\", \"\")\n    logging.info(\"Converting PDF to Collection of Images\")\n    for page_number in range(document.page_count):\n        filename = f\"{base_name}_pg_{page_number + 1}.jpg\"\n        filepath = os.path.join(tempdir, filename)\n        page = document.load_page(page_number)\n        pix = page.get_pixmap()",
        "detail": "src.gestalt_module_generator.utils",
        "documentation": {}
    },
    {
        "label": "convert_pdf_to_images_in_memory",
        "kind": 2,
        "importPath": "src.gestalt_module_generator.utils",
        "description": "src.gestalt_module_generator.utils",
        "peekOfCode": "def convert_pdf_to_images_in_memory(pdf_path: str) -> List[BytesIO]:\n    \"\"\"\n    Converts each page of a PDF file to an image and returns the images as in-memory BytesIO objects.\n    Args:\n        pdf_path (str): The path to the PDF file.\n    Returns:\n        List[BytesIO]: A list of BytesIO objects containing the image data.\n    \"\"\"\n    image_data_list = []\n    document = fitz.open(pdf_path)",
        "detail": "src.gestalt_module_generator.utils",
        "documentation": {}
    },
    {
        "label": "create_zip_file",
        "kind": 2,
        "importPath": "src.gestalt_module_generator.utils",
        "description": "src.gestalt_module_generator.utils",
        "peekOfCode": "def create_zip_file(file_paths: List[str], base_dir: str) -> BytesIO:\n    memory_file = io.BytesIO()\n    with zipfile.ZipFile(memory_file, 'w') as zipf:\n        for file_path in file_paths:\n            zipf.write(file_path, os.path.relpath(file_path, base_dir))\n    memory_file.seek(0)\n    return memory_file\n# Main entry point\nasync def main():\n    pass",
        "detail": "src.gestalt_module_generator.utils",
        "documentation": {}
    },
    {
        "label": "Response",
        "kind": 6,
        "importPath": "src.llm_generators.agent.lecture_triaging_agent",
        "description": "src.llm_generators.agent.lecture_triaging_agent",
        "peekOfCode": "class Response(BaseModel):\n    functions_call: List[str] = Field(...,description=\"An array of functions to call\")\nschema = Response.model_json_schema()\nresponse_format = {\n    \"type\": \"json_schema\",\n    \"json_schema\": {\n        \"name\": \"lecture_analysis\",\n        \"schema\": schema\n    }\n}",
        "detail": "src.llm_generators.agent.lecture_triaging_agent",
        "documentation": {}
    },
    {
        "label": "triaging_system_prompt",
        "kind": 5,
        "importPath": "src.llm_generators.agent.lecture_triaging_agent",
        "description": "src.llm_generators.agent.lecture_triaging_agent",
        "peekOfCode": "triaging_system_prompt = \"\"\"\nYou are responsible for assessing the user's query and analyzing the provided material. Route the query to the appropriate functions based on the content. The available functions are:\n- **extract_summary_and_key_concepts**: Use this function to extract the summary and key concepts only if the material is long and formatted as a lecture. This function is not applicable for short materials or collections of questions.\n- **conceptual_question_extraction**: This function must always be called if extract_summary_and_key_concepts is used, as it complements the extraction of key concepts by generating or extracting related conceptual questions. For shorter materials, such as a collection of questions, this function should follow the same conditions as the extract_computational_questions function.\n- **extract_derivations**: Extract mathematical derivations only if it is clear that the material contains formal mathematical derivations. \n- **computational_question_extraction**: This function extracts computational questions along with their solution.This function is ideally used when the material includes problems with solutions. This function works for single to multiple questions present\nForward the user's query to the relevant functions using the send_query_to_functions tool based on the material's content and format.\n\"\"\"\nclass Response(BaseModel):\n    functions_call: List[str] = Field(...,description=\"An array of functions to call\")",
        "detail": "src.llm_generators.agent.lecture_triaging_agent",
        "documentation": {}
    },
    {
        "label": "schema",
        "kind": 5,
        "importPath": "src.llm_generators.agent.lecture_triaging_agent",
        "description": "src.llm_generators.agent.lecture_triaging_agent",
        "peekOfCode": "schema = Response.model_json_schema()\nresponse_format = {\n    \"type\": \"json_schema\",\n    \"json_schema\": {\n        \"name\": \"lecture_analysis\",\n        \"schema\": schema\n    }\n}\nasync def lecture_triaging_agent(image_paths: list[str]):\n    responses = await send_image_request(prompt = triaging_system_prompt,response_format=response_format, image_paths=image_paths)",
        "detail": "src.llm_generators.agent.lecture_triaging_agent",
        "documentation": {}
    },
    {
        "label": "response_format",
        "kind": 5,
        "importPath": "src.llm_generators.agent.lecture_triaging_agent",
        "description": "src.llm_generators.agent.lecture_triaging_agent",
        "peekOfCode": "response_format = {\n    \"type\": \"json_schema\",\n    \"json_schema\": {\n        \"name\": \"lecture_analysis\",\n        \"schema\": schema\n    }\n}\nasync def lecture_triaging_agent(image_paths: list[str]):\n    responses = await send_image_request(prompt = triaging_system_prompt,response_format=response_format, image_paths=image_paths)\n    cleaned_response = json.loads(responses[\"choices\"][0][\"message\"][\"content\"])",
        "detail": "src.llm_generators.agent.lecture_triaging_agent",
        "documentation": {}
    },
    {
        "label": "extract_conceptual_questions",
        "kind": 2,
        "importPath": "src.llm_generators.generate_ui.generate_conceptual_question_html",
        "description": "src.llm_generators.generate_ui.generate_conceptual_question_html",
        "peekOfCode": "def extract_conceptual_questions(response: dict) -> List[str]:\n    conceptual_questions = response.get(\"questions\", [])\n    all_questions = []\n    for conceptual_question in conceptual_questions:\n        question_text = f\"Question: {conceptual_question.get('question', 'Unknown')}\"\n        # Handle multiple choice options\n        multiple_choice_options = conceptual_question.get('multiple_choice_options', [])\n        options_text = \"\\n\".join(f\" - Option: {option}\" for option in multiple_choice_options)\n        # Add correct answer\n        correct_answer = f\"Correct Answer: {conceptual_question.get('correct_answer', 'No answer provided')}\"",
        "detail": "src.llm_generators.generate_ui.generate_conceptual_question_html",
        "documentation": {}
    },
    {
        "label": "create_multiple_prompts",
        "kind": 2,
        "importPath": "src.llm_generators.generate_ui.generate_conceptual_question_html",
        "description": "src.llm_generators.generate_ui.generate_conceptual_question_html",
        "peekOfCode": "def create_multiple_prompts(base_prompt: str, response: dict) -> List[str]:\n    derivations = extract_conceptual_questions(response)\n    return [base_prompt + derivation for derivation in derivations]\nasync def generate_conceptual_questions_html(response: dict) -> BeautifulSoup:\n    base_prompt = \"\"\"\n    You are a web developer tasked with creating an engaging and informative HTML webpage based on the following extracted lecture notes. The webpage should be well-structured, visually appealing, and easy to navigate.\n    You are only focused on working on the following sections. When you need to format any mathematical symbols or equations, use LaTeX enclosed within appropriate delimiters to ensure proper rendering.\n    **Instructions:**\n    1. **Conceptual Questions**: Create a section dedicated to multiple-choice conceptual questions based on the lecture material. Each question should be clearly presented, with four possible answer choices labeled (A), (B), (C), and (D). Indicate the correct answer for each question.\n    - Ensure that all questions and answer choices are formatted using appropriate HTML tags to enhance readability.",
        "detail": "src.llm_generators.generate_ui.generate_conceptual_question_html",
        "documentation": {}
    },
    {
        "label": "extract_multiple_derivations",
        "kind": 2,
        "importPath": "src.llm_generators.generate_ui.generate_derivations_html",
        "description": "src.llm_generators.generate_ui.generate_derivations_html",
        "peekOfCode": "def extract_multiple_derivations(response: dict) -> List[str]:\n    derivations = response.get(\"derivations\", [])\n    all_derivations = [\n        f\"Derivation Name: {derivation.get('derivation_name', 'Unknown')}\" +\n        \"\".join(\n            f\"\\n - Explanation: {step.get('explanation', 'No explanation provided')}\"\n            f\"\\n - Step: {step.get('output', 'No output provided')}\"\n            for step in derivation.get(\"derivation_steps\", [])\n        )\n        for derivation in derivations",
        "detail": "src.llm_generators.generate_ui.generate_derivations_html",
        "documentation": {}
    },
    {
        "label": "create_multiple_prompts",
        "kind": 2,
        "importPath": "src.llm_generators.generate_ui.generate_derivations_html",
        "description": "src.llm_generators.generate_ui.generate_derivations_html",
        "peekOfCode": "def create_multiple_prompts(base_prompt: str, response: dict) -> List[str]:\n    derivations = extract_multiple_derivations(response)\n    return [base_prompt + derivation for derivation in derivations]\nasync def generate_derivations_html(response: dict) -> BeautifulSoup:\n    base_prompt = \"\"\"\n    You are a web developer tasked with creating an engaging and informative HTML webpage based on the following extracted lecture notes. The webpage should be well-structured, visually appealing, and easy to navigate.\n    You are only focused on working on the following sections. When you need to format any mathematical symbols or equations, use LaTeX enclosed within appropriate delimiters to ensure proper rendering.\n    **Instructions:**\n    1. **Derivations**: Present any mathematical derivations or logical arguments discussed in the lecture. This section should be meticulously formatted to showcase each step clearly, allowing readers to follow the derivation process step by step. Utilize appropriate HTML tags for mathematical notation and consider using ordered lists or numbered headings to denote each step.\n    - Ensure that all derivations are presented in full detail:",
        "detail": "src.llm_generators.generate_ui.generate_derivations_html",
        "documentation": {}
    },
    {
        "label": "unescape_backslashes",
        "kind": 2,
        "importPath": "src.llm_generators.generate_ui.generate_html_from_ui",
        "description": "src.llm_generators.generate_ui.generate_html_from_ui",
        "peekOfCode": "def unescape_backslashes(latex_string):\n    return latex_string.replace('\\\\\\\\', '\\\\')\ndef ui_to_html(ui: dict) -> str:\n    # Start with the opening tag\n    html = f\"<{ui.get('type')}\"\n    # Add attributes\n    if ui.get('attributes'):\n        for attribute in ui.get('attributes'):\n            html += f' {attribute.get(\"name\")}=\"{attribute.get(\"value\")}\"'\n    # Close the opening tag",
        "detail": "src.llm_generators.generate_ui.generate_html_from_ui",
        "documentation": {}
    },
    {
        "label": "ui_to_html",
        "kind": 2,
        "importPath": "src.llm_generators.generate_ui.generate_html_from_ui",
        "description": "src.llm_generators.generate_ui.generate_html_from_ui",
        "peekOfCode": "def ui_to_html(ui: dict) -> str:\n    # Start with the opening tag\n    html = f\"<{ui.get('type')}\"\n    # Add attributes\n    if ui.get('attributes'):\n        for attribute in ui.get('attributes'):\n            html += f' {attribute.get(\"name\")}=\"{attribute.get(\"value\")}\"'\n    # Close the opening tag\n    html += \">\"\n    #Add the label if it exists",
        "detail": "src.llm_generators.generate_ui.generate_html_from_ui",
        "documentation": {}
    },
    {
        "label": "generate_lecture_summary_prompt",
        "kind": 2,
        "importPath": "src.llm_generators.generate_ui.generate_lecture_summary_ui",
        "description": "src.llm_generators.generate_ui.generate_lecture_summary_ui",
        "peekOfCode": "def generate_lecture_summary_prompt(response: dict) -> str:\n    analysis = response.get(\"analysis\", {})\n    summary = analysis.get(\"summary\", \"No summary provided.\")\n    key_concepts = analysis.get(\"key_concepts\", \"No key concepts provided.\")\n    foundational_concepts = analysis.get(\"foundational_concepts\", \"No foundational concepts provided.\")\n    prompt = f\"\"\"\n    You are a web developer tasked with creating an engaging and informative HTML webpage based on the following extracted lecture notes. The webpage should be well-structured, visually appealing, and easy to navigate.\n    You are only focused on working on the following sections. When you need to format any mathematical symbols or equations, use LaTeX enclosed within appropriate delimiters to ensure proper rendering.\n    **Instructions:**\n    1. **Summary of Lecture**: Create a section that provides a concise overview of the lecture's main points. Use appropriate headings and bullet points to make the content easily digestible.",
        "detail": "src.llm_generators.generate_ui.generate_lecture_summary_ui",
        "documentation": {}
    },
    {
        "label": "get_valid_css_classes",
        "kind": 2,
        "importPath": "src.llm_generators.generate_ui.get_valid_css",
        "description": "src.llm_generators.generate_ui.get_valid_css",
        "peekOfCode": "def get_valid_css_classes( UItype: UIType,name_interest: str=\"\",) -> tuple:\n    \"\"\"\n    Helper function to isolate and retrieve valid CSS classes based on the specified UI type.\n    Args:\n        name_interest (str): The category name of the CSS styles (e.g., \"summary_and_key_concepts\").\n        UItype (UIType): The UI type for which CSS classes are being isolated.\n    Returns:\n        tuple: A tuple containing:\n            - VALID_CSS_STYLES (dict): A dictionary mapping UI types to their corresponding valid CSS class names.\n            - css_descriptions (str): A formatted string containing descriptions of the valid CSS classes.",
        "detail": "src.llm_generators.generate_ui.get_valid_css",
        "documentation": {}
    },
    {
        "label": "base_dir",
        "kind": 5,
        "importPath": "src.llm_generators.generate_ui.get_valid_css",
        "description": "src.llm_generators.generate_ui.get_valid_css",
        "peekOfCode": "base_dir = os.path.dirname(os.path.abspath(__file__))\n# Construct the full path to the JSON file\ncss_styles_file = os.path.join(base_dir, 'valid_css_styles_bootstrap.json')\nwith open(css_styles_file,\"r\") as file:\n    css_styles = json.load(file)\ndef get_valid_css_classes( UItype: UIType,name_interest: str=\"\",) -> tuple:\n    \"\"\"\n    Helper function to isolate and retrieve valid CSS classes based on the specified UI type.\n    Args:\n        name_interest (str): The category name of the CSS styles (e.g., \"summary_and_key_concepts\").",
        "detail": "src.llm_generators.generate_ui.get_valid_css",
        "documentation": {}
    },
    {
        "label": "css_styles_file",
        "kind": 5,
        "importPath": "src.llm_generators.generate_ui.get_valid_css",
        "description": "src.llm_generators.generate_ui.get_valid_css",
        "peekOfCode": "css_styles_file = os.path.join(base_dir, 'valid_css_styles_bootstrap.json')\nwith open(css_styles_file,\"r\") as file:\n    css_styles = json.load(file)\ndef get_valid_css_classes( UItype: UIType,name_interest: str=\"\",) -> tuple:\n    \"\"\"\n    Helper function to isolate and retrieve valid CSS classes based on the specified UI type.\n    Args:\n        name_interest (str): The category name of the CSS styles (e.g., \"summary_and_key_concepts\").\n        UItype (UIType): The UI type for which CSS classes are being isolated.\n    Returns:",
        "detail": "src.llm_generators.generate_ui.get_valid_css",
        "documentation": {}
    },
    {
        "label": "ModuleCodeGenerator",
        "kind": 6,
        "importPath": "src.llm_generators.module_generators.code_generator",
        "description": "src.llm_generators.module_generators.code_generator",
        "peekOfCode": "class ModuleCodeGenerator:\n    template: str\n    example_input_column: str\n    example_output_column: str\n    llm_config: LLMConfig\n    threshold: float = 0.3\n    num_examples: int = 2\n    def __post_init__(self):\n        self.example_formatter = ExampleBasedPromptDataFrame(\n            example_input_column=self.example_input_column,",
        "detail": "src.llm_generators.module_generators.code_generator",
        "documentation": {}
    },
    {
        "label": "MetaData",
        "kind": 6,
        "importPath": "src.llm_generators.module_generators.metadata_generator",
        "description": "src.llm_generators.module_generators.metadata_generator",
        "peekOfCode": "class MetaData(BaseModel):\n    uuid: str = Field(...,description=\"uuid: A universally unique identifier (UUID) for this item\")\n    title: str = Field(..., description=\"An appropriate title for the given question, return using CamelCase format\")\n    stem: str = Field(..., description=\"Additional context or a subtopic related to the main topic\")\n    topic: str = Field(..., description=\"The main topic or subject of the educational content\")\n    tags: List[str] = Field(..., description=\"An array of keywords or tags associated with the content\")\n    prereqs: List[str] = Field(..., description=\"An array of prerequisites needed to access or understand the content\")\n    isAdaptive: bool = Field(..., description=\"Designates whether the content necessitates any form of numerical computation. Assign as 'true' if the question involves any numerical computation; return 'false' if no computational effort is required\")\nclass Response(BaseModel):\n    question: str = Field(...,description=\"Original Question that was classified\")",
        "detail": "src.llm_generators.module_generators.metadata_generator",
        "documentation": {}
    },
    {
        "label": "Response",
        "kind": 6,
        "importPath": "src.llm_generators.module_generators.metadata_generator",
        "description": "src.llm_generators.module_generators.metadata_generator",
        "peekOfCode": "class Response(BaseModel):\n    question: str = Field(...,description=\"Original Question that was classified\")\n    metadata:MetaData\nasync def classify_question(question:str)->dict:\n    prompt =  f\"Generate metadat of the following question {question}\"\n    response = await client_async.beta.chat.completions.parse(\n        model=MODEL,\n        messages=[\n            {\"role\": \"system\", \"content\": \"You are a professor at a University focused on mechanical engineering education. Please return the result in JSON format.\"},\n            {\"role\": \"user\", \"content\": prompt}",
        "detail": "src.llm_generators.module_generators.metadata_generator",
        "documentation": {}
    },
    {
        "label": "MODEL",
        "kind": 5,
        "importPath": "src.llm_generators.module_generators.metadata_generator",
        "description": "src.llm_generators.module_generators.metadata_generator",
        "peekOfCode": "MODEL = \"gpt-4o-mini\"\nclient_async = AsyncOpenAI(api_key=api_key)\nclass MetaData(BaseModel):\n    uuid: str = Field(...,description=\"uuid: A universally unique identifier (UUID) for this item\")\n    title: str = Field(..., description=\"An appropriate title for the given question, return using CamelCase format\")\n    stem: str = Field(..., description=\"Additional context or a subtopic related to the main topic\")\n    topic: str = Field(..., description=\"The main topic or subject of the educational content\")\n    tags: List[str] = Field(..., description=\"An array of keywords or tags associated with the content\")\n    prereqs: List[str] = Field(..., description=\"An array of prerequisites needed to access or understand the content\")\n    isAdaptive: bool = Field(..., description=\"Designates whether the content necessitates any form of numerical computation. Assign as 'true' if the question involves any numerical computation; return 'false' if no computational effort is required\")",
        "detail": "src.llm_generators.module_generators.metadata_generator",
        "documentation": {}
    },
    {
        "label": "client_async",
        "kind": 5,
        "importPath": "src.llm_generators.module_generators.metadata_generator",
        "description": "src.llm_generators.module_generators.metadata_generator",
        "peekOfCode": "client_async = AsyncOpenAI(api_key=api_key)\nclass MetaData(BaseModel):\n    uuid: str = Field(...,description=\"uuid: A universally unique identifier (UUID) for this item\")\n    title: str = Field(..., description=\"An appropriate title for the given question, return using CamelCase format\")\n    stem: str = Field(..., description=\"Additional context or a subtopic related to the main topic\")\n    topic: str = Field(..., description=\"The main topic or subject of the educational content\")\n    tags: List[str] = Field(..., description=\"An array of keywords or tags associated with the content\")\n    prereqs: List[str] = Field(..., description=\"An array of prerequisites needed to access or understand the content\")\n    isAdaptive: bool = Field(..., description=\"Designates whether the content necessitates any form of numerical computation. Assign as 'true' if the question involves any numerical computation; return 'false' if no computational effort is required\")\nclass Response(BaseModel):",
        "detail": "src.llm_generators.module_generators.metadata_generator",
        "documentation": {}
    },
    {
        "label": "question_html_gen_template",
        "kind": 5,
        "importPath": "src.llm_generators.module_generators.module_generator_templates",
        "description": "src.llm_generators.module_generators.module_generator_templates",
        "peekOfCode": "question_html_gen_template = \"\"\"\n1. Analyze the Question\nBegin by carefully reading the physics question to determine its nature—whether it demands computational solutions or is purely theoretical. \nThis initial analysis is critical as it dictates the necessity of incorporating placeholders for numerical values. \nConsider the context and specifics of the question thoroughly to ensure the correct categorization.\n2. Identify Parameters for Computation\nFor questions requiring computational analysis:\nIdentify all numerical values that could potentially vary or would be essential for calculations. This step is paramount and must be prioritized for computational questions.\nReplace these values with placeholders using the format {{params.variable_name}}. Ensure you choose descriptive and unique names for each variable to prevent any confusion and to clearly indicate their roles in the computations.\n3. Emphasize Placeholder Implementation",
        "detail": "src.llm_generators.module_generators.module_generator_templates",
        "documentation": {}
    },
    {
        "label": "server_js_template_base",
        "kind": 5,
        "importPath": "src.llm_generators.module_generators.module_generator_templates",
        "description": "src.llm_generators.module_generators.module_generator_templates",
        "peekOfCode": "server_js_template_base = \"\"\"\n    Design a robust JavaScript module capable of generating computational problems across various STEM disciplines. This module will ingest an HTML file containing a structured query and will output a JavaScript snippet that performs the calculations for the described problem. The JavaScript code must conform to the following outline:\n    const generate = () => {{\n        // 1. Dynamic Parameter Selection:\n        // - Thoroughly analyze the HTML or data source to identify an extensive range of categories and units for computation.\n        // - Ensure the inclusion of a wide variety of units and values, covering different global measurement systems.\n        // - Develop a randomized selection algorithm to fairly choose a category or unit system, ensuring equitable representation.\n        // - When applicable, ensure that it alternates between SI and USCS for unit selection.\n        // 2. Value Generation:\n        // - Produce random values relevant to the problem's context, ensuring they fall within specified ranges.",
        "detail": "src.llm_generators.module_generators.module_generator_templates",
        "documentation": {}
    },
    {
        "label": "server_template_code_guide",
        "kind": 5,
        "importPath": "src.llm_generators.module_generators.module_generator_templates",
        "description": "src.llm_generators.module_generators.module_generator_templates",
        "peekOfCode": "server_template_code_guide = \"\"\"\n    Additionally, you have access to both a code guide and a solution guide. The solution guide provides an accurate, step-by-step method for solving the problem, dictating the logical approach. \n    The code guide offers guidance on how to implement this solution in code, including formatting and other relevant considerations.\n\"\"\"\nsolution_html_template= \"\"\"\nObjective:\n        Develop an HTML module to generate comprehensive solutions and step-by-step guides for STEM problems. Utilize specific HTML tags for structural organization and LaTeX for mathematical equations and symbols.\n        HTML Tags and LaTeX Integration:\n        - <pl-solution-panel>: Used to encapsulate the entire solution guide.\n        - <pl-hint level=\"1\" data-type=\"text\">: Employed for providing hints and detailed step-by-step explanations within the guide.",
        "detail": "src.llm_generators.module_generators.module_generator_templates",
        "documentation": {}
    },
    {
        "label": "solution_improvement_prompt",
        "kind": 5,
        "importPath": "src.llm_generators.module_generators.module_generator_templates",
        "description": "src.llm_generators.module_generators.module_generator_templates",
        "peekOfCode": "solution_improvement_prompt = \"\"\"Given the current HTML module for STEM problem-solving, your task is to enhance it using the provided code as a foundational guide. This code is designed to dynamically generate problem parameters and their correct answers. Your objective is to integrate these elements into the HTML solution guide effectively.\n        Your Specific Tasks:\n        1. **Review the Current ssolution guide  **: \n        Begin by examining the provided HTML solution guide  {solution_generated}. \n        2. **Integrate Dynamic Content Using Placeholders**: Insert placeholders into the HTML that correspond to the outputs of the code found in the params datastructure. Use placeholders like `{{params.placeholder_value}}` or `{{correct_answers.placeholder_value}}` that align with the variable names and data formats in the code. This ensures the HTML will dynamically display the correct data when the module runs.\n         Reference Code for Integration:\n         {code_guide}\n          Include your revised HTML code below:\n        ```insert revised html code here```\n        \"\"\"",
        "detail": "src.llm_generators.module_generators.module_generator_templates",
        "documentation": {}
    },
    {
        "label": "server_py_template_base",
        "kind": 5,
        "importPath": "src.llm_generators.module_generators.module_generator_templates",
        "description": "src.llm_generators.module_generators.module_generator_templates",
        "peekOfCode": "server_py_template_base = \"\"\"\n    Design a robust Python module capable of generating computational problems across various STEM disciplines. This module will ingest an HTML file containing a structured query and will output a Python snippet that performs the calculations for the described problem. The Python code must conform to the following outline:\n    def generate():\n        # 1. Dynamic Parameter Selection:\n        # Do not include html inside the python code\n        # - Thoroughly analyze the HTML or data source to identify an extensive range of categories and units for computation.\n        # - Ensure the inclusion of a wide variety of units and values, covering different global measurement systems.\n        # - Develop a randomized selection algorithm to fairly choose a category or unit system, ensuring equitable representation.\n        # - When applicable, ensure that it alternates between SI and USCS for unit selection.\n        # 2. Value Generation:",
        "detail": "src.llm_generators.module_generators.module_generator_templates",
        "documentation": {}
    },
    {
        "label": "llm_config",
        "kind": 5,
        "importPath": "src.llm_generators.module_generators.question_html_generator",
        "description": "src.llm_generators.module_generators.question_html_generator",
        "peekOfCode": "llm_config = LLMConfig(api_key=api_key,model=\"gpt-4o-mini\",temperature=0)\nquestion_html_generator = ModuleCodeGenerator(\n    template=question_html_gen_template,\n    example_input_column=\"question\",\n    example_output_column=\"question.html\",\n    llm_config=llm_config\n)\nasync def main():\n    question = [\"A car travels a long a straight road for a total time of 5 mphs for 30 minutes calculate the total distance\"]\n    generated = await question_html_generator.arun(question)",
        "detail": "src.llm_generators.module_generators.question_html_generator",
        "documentation": {}
    },
    {
        "label": "question_html_generator",
        "kind": 5,
        "importPath": "src.llm_generators.module_generators.question_html_generator",
        "description": "src.llm_generators.module_generators.question_html_generator",
        "peekOfCode": "question_html_generator = ModuleCodeGenerator(\n    template=question_html_gen_template,\n    example_input_column=\"question\",\n    example_output_column=\"question.html\",\n    llm_config=llm_config\n)\nasync def main():\n    question = [\"A car travels a long a straight road for a total time of 5 mphs for 30 minutes calculate the total distance\"]\n    generated = await question_html_generator.arun(question)\n    return generated",
        "detail": "src.llm_generators.module_generators.question_html_generator",
        "documentation": {}
    },
    {
        "label": "llm_config",
        "kind": 5,
        "importPath": "src.llm_generators.module_generators.question_solution_html_generator",
        "description": "src.llm_generators.module_generators.question_solution_html_generator",
        "peekOfCode": "llm_config = LLMConfig(api_key=api_key,model=\"gpt-4o-mini\",temperature=0)\nquestion_solution_generator = ModuleCodeGenerator(\n    template=solution_html_template,\n    example_input_column=\"question.html\",\n    example_output_column=\"solution.html\",\n    llm_config=llm_config\n)\nasync def main():\n    question = [\"A car travels a long a straight road for a total time of 5 mphs for 30 minutes calculate the total distance\"]\n    generated = await question_solution_generator.arun(question)",
        "detail": "src.llm_generators.module_generators.question_solution_html_generator",
        "documentation": {}
    },
    {
        "label": "question_solution_generator",
        "kind": 5,
        "importPath": "src.llm_generators.module_generators.question_solution_html_generator",
        "description": "src.llm_generators.module_generators.question_solution_html_generator",
        "peekOfCode": "question_solution_generator = ModuleCodeGenerator(\n    template=solution_html_template,\n    example_input_column=\"question.html\",\n    example_output_column=\"solution.html\",\n    llm_config=llm_config\n)\nasync def main():\n    question = [\"A car travels a long a straight road for a total time of 5 mphs for 30 minutes calculate the total distance\"]\n    generated = await question_solution_generator.arun(question)\n    return generated",
        "detail": "src.llm_generators.module_generators.question_solution_html_generator",
        "documentation": {}
    },
    {
        "label": "llm_config",
        "kind": 5,
        "importPath": "src.llm_generators.module_generators.server_js_generator",
        "description": "src.llm_generators.module_generators.server_js_generator",
        "peekOfCode": "llm_config = LLMConfig(api_key=api_key,model=\"gpt-4o-mini\",temperature=0)\nserver_js_generator = ModuleCodeGenerator(\n    template=server_js_template_base,\n    example_input_column=\"question.html\",\n    example_output_column=\"server.js\",\n    llm_config=llm_config\n)\nasync def main():\n    question = [\"A car travels a long a straight road for a total time of 5 mphs for 30 minutes calculate the total distance\"]\n    generated = await server_js_generator.arun(question)",
        "detail": "src.llm_generators.module_generators.server_js_generator",
        "documentation": {}
    },
    {
        "label": "server_js_generator",
        "kind": 5,
        "importPath": "src.llm_generators.module_generators.server_js_generator",
        "description": "src.llm_generators.module_generators.server_js_generator",
        "peekOfCode": "server_js_generator = ModuleCodeGenerator(\n    template=server_js_template_base,\n    example_input_column=\"question.html\",\n    example_output_column=\"server.js\",\n    llm_config=llm_config\n)\nasync def main():\n    question = [\"A car travels a long a straight road for a total time of 5 mphs for 30 minutes calculate the total distance\"]\n    generated = await server_js_generator.arun(question)\n    return generated",
        "detail": "src.llm_generators.module_generators.server_js_generator",
        "documentation": {}
    },
    {
        "label": "llm_config",
        "kind": 5,
        "importPath": "src.llm_generators.module_generators.server_py_generator",
        "description": "src.llm_generators.module_generators.server_py_generator",
        "peekOfCode": "llm_config = LLMConfig(api_key=api_key,model=\"gpt-4o-mini\",temperature=0)\nserver_py_generator = ModuleCodeGenerator(\n    template=server_py_template_base,\n    example_input_column=\"question.html\",\n    example_output_column=\"server.py\",\n    llm_config=llm_config\n)\nasync def main():\n    question = [\"A car travels a long a straight road for a total time of 5 mphs for 30 minutes calculate the total distance\"]\n    generated = await server_py_generator.arun(question)",
        "detail": "src.llm_generators.module_generators.server_py_generator",
        "documentation": {}
    },
    {
        "label": "server_py_generator",
        "kind": 5,
        "importPath": "src.llm_generators.module_generators.server_py_generator",
        "description": "src.llm_generators.module_generators.server_py_generator",
        "peekOfCode": "server_py_generator = ModuleCodeGenerator(\n    template=server_py_template_base,\n    example_input_column=\"question.html\",\n    example_output_column=\"server.py\",\n    llm_config=llm_config\n)\nasync def main():\n    question = [\"A car travels a long a straight road for a total time of 5 mphs for 30 minutes calculate the total distance\"]\n    generated = await server_py_generator.arun(question)\n    return generated",
        "detail": "src.llm_generators.module_generators.server_py_generator",
        "documentation": {}
    },
    {
        "label": "question_html_gen_template",
        "kind": 5,
        "importPath": "src.llm_generators.llm_templates",
        "description": "src.llm_generators.llm_templates",
        "peekOfCode": "question_html_gen_template = \"\"\"\n1. Analyze the Question\nBegin by carefully reading the physics question to determine its nature—whether it demands computational solutions or is purely theoretical. \nThis initial analysis is critical as it dictates the necessity of incorporating placeholders for numerical values. \nConsider the context and specifics of the question thoroughly to ensure the correct categorization.\n2. Identify Parameters for Computation\nFor questions requiring computational analysis:\nIdentify all numerical values that could potentially vary or would be essential for calculations. This step is paramount and must be prioritized for computational questions.\nReplace these values with placeholders using the format {{params.variable_name}}. Ensure you choose descriptive and unique names for each variable to prevent any confusion and to clearly indicate their roles in the computations.\n3. Emphasize Placeholder Implementation",
        "detail": "src.llm_generators.llm_templates",
        "documentation": {}
    },
    {
        "label": "server_js_template_base",
        "kind": 5,
        "importPath": "src.llm_generators.llm_templates",
        "description": "src.llm_generators.llm_templates",
        "peekOfCode": "server_js_template_base = \"\"\"\n    Design a robust JavaScript module capable of generating computational problems across various STEM disciplines. This module will ingest an HTML file containing a structured query and will output a JavaScript snippet that performs the calculations for the described problem. The JavaScript code must conform to the following outline:\n    const generate = () => {{\n        // 1. Dynamic Parameter Selection:\n        // - Thoroughly analyze the HTML or data source to identify an extensive range of categories and units for computation.\n        // - Ensure the inclusion of a wide variety of units and values, covering different global measurement systems.\n        // - Develop a randomized selection algorithm to fairly choose a category or unit system, ensuring equitable representation.\n        // - When applicable, ensure that it alternates between SI and USCS for unit selection.\n        // 2. Value Generation:\n        // - Produce random values relevant to the problem's context, ensuring they fall within specified ranges.",
        "detail": "src.llm_generators.llm_templates",
        "documentation": {}
    },
    {
        "label": "server_template_code_guide",
        "kind": 5,
        "importPath": "src.llm_generators.llm_templates",
        "description": "src.llm_generators.llm_templates",
        "peekOfCode": "server_template_code_guide = \"\"\"\n    Additionally, you have access to both a code guide and a solution guide. The solution guide provides an accurate, step-by-step method for solving the problem, dictating the logical approach. \n    The code guide offers guidance on how to implement this solution in code, including formatting and other relevant considerations.\n\"\"\"\ngenerate_metadata_template = \"\"\"\nGiven the following input question, generate the following metadata\n  question: {question}\n    - uuid: A universally unique identifier (UUID) for this item\n        - title: The title or name of the educational content. Return using CamelCase convention\n        - stem: = Additional context or a subtopic related to the main topic",
        "detail": "src.llm_generators.llm_templates",
        "documentation": {}
    },
    {
        "label": "generate_metadata_template",
        "kind": 5,
        "importPath": "src.llm_generators.llm_templates",
        "description": "src.llm_generators.llm_templates",
        "peekOfCode": "generate_metadata_template = \"\"\"\nGiven the following input question, generate the following metadata\n  question: {question}\n    - uuid: A universally unique identifier (UUID) for this item\n        - title: The title or name of the educational content. Return using CamelCase convention\n        - stem: = Additional context or a subtopic related to the main topic\n        - topic: The main topic or subject of the educational content\n        - tags: An array of keywords or tags associated with the content for categorization\n        - prereqs: Prerequisites needed to access or understand the content\n        - isAdaptive: Designates whether the content necessitates any form of numerical computation. Assign as 'true' if the question involves any numerical computation; return 'false' if no computational effort is required. Note: This is a string value, not a boolean.",
        "detail": "src.llm_generators.llm_templates",
        "documentation": {}
    },
    {
        "label": "solution_improvement_prompt",
        "kind": 5,
        "importPath": "src.llm_generators.llm_templates",
        "description": "src.llm_generators.llm_templates",
        "peekOfCode": "solution_improvement_prompt = \"\"\"Given the current HTML module for STEM problem-solving, your task is to enhance it using the provided code as a foundational guide. This code is designed to dynamically generate problem parameters and their correct answers. Your objective is to integrate these elements into the HTML solution guide effectively.\n        Your Specific Tasks:\n        1. **Review the Current ssolution guide  **: \n        Begin by examining the provided HTML solution guide  {solution_generated}. \n        2. **Integrate Dynamic Content Using Placeholders**: Insert placeholders into the HTML that correspond to the outputs of the code found in the params datastructure. Use placeholders like `{{params.placeholder_value}}` or `{{correct_answers.placeholder_value}}` that align with the variable names and data formats in the code. This ensures the HTML will dynamically display the correct data when the module runs.\n         Reference Code for Integration:\n         {code_guide}\n          Include your revised HTML code below:\n        ```insert revised html code here```\n        \"\"\"",
        "detail": "src.llm_generators.llm_templates",
        "documentation": {}
    },
    {
        "label": "extract_question_image_template",
        "kind": 5,
        "importPath": "src.llm_generators.llm_templates",
        "description": "src.llm_generators.llm_templates",
        "peekOfCode": "extract_question_image_template = \"\"\"Extract only the question being asked from the image. Ensure that it includes all details, data, and parameters necessary for understanding the question comprehensively. Represent any special characters, such as math symbols, using LaTeX format. \nIf the image contains multiple questions, return them as an ordered list. Do not extract any other information, such as how to solve the problem or any additional context. \nYour sole objective is to extract the original question(s) from the image.\"\"\"\nextract_solution_image_tempate = \"\"\"\nAnalyze the provided image to extract and develop a concise solution guide outlining the methodical steps for solving the problem symbolically. The guide should be clear and to the point, without numerical values, and should include relevant conversion factors.\nSolution Guide Format:\nProblem Statement:\n- Define the problem's objective as depicted in the image, clearly outlining its context and goal.\nVariables Description:\n- Describe all discernible variables from the image. Include relevant mathematical expressions or equations in LaTeX.",
        "detail": "src.llm_generators.llm_templates",
        "documentation": {}
    },
    {
        "label": "extract_solution_image_tempate",
        "kind": 5,
        "importPath": "src.llm_generators.llm_templates",
        "description": "src.llm_generators.llm_templates",
        "peekOfCode": "extract_solution_image_tempate = \"\"\"\nAnalyze the provided image to extract and develop a concise solution guide outlining the methodical steps for solving the problem symbolically. The guide should be clear and to the point, without numerical values, and should include relevant conversion factors.\nSolution Guide Format:\nProblem Statement:\n- Define the problem's objective as depicted in the image, clearly outlining its context and goal.\nVariables Description:\n- Describe all discernible variables from the image. Include relevant mathematical expressions or equations in LaTeX.\nEquation Setup:\n- Identify and establish equations or relationships shown or implied in the image, using LaTeX for mathematical representations.\nSolution Process:",
        "detail": "src.llm_generators.llm_templates",
        "documentation": {}
    },
    {
        "label": "code_guide_template",
        "kind": 5,
        "importPath": "src.llm_generators.llm_templates",
        "description": "src.llm_generators.llm_templates",
        "peekOfCode": "code_guide_template = \"\"\"\n### Code Guide for Dynamic Problem Generation in JavaScript\n#### 0. Analyze the Original Question:\n- **Given Values and Units**:\n  - Carefully identify all the given values in the original question.\n  - Note their units and understand their role within the context of the problem.\n#### 1. Variable Ranges:\n- **Establishing Variable Ranges**:\n  - Identify each variable from the problem statement.\n  - Suggest reasonable ranges for each variable.",
        "detail": "src.llm_generators.llm_templates",
        "documentation": {}
    },
    {
        "label": "server_py_template_base",
        "kind": 5,
        "importPath": "src.llm_generators.llm_templates",
        "description": "src.llm_generators.llm_templates",
        "peekOfCode": "server_py_template_base = \"\"\"\n    Design a robust Python module capable of generating computational problems across various STEM disciplines. This module will ingest an HTML file containing a structured query and will output a Python snippet that performs the calculations for the described problem. The Python code must conform to the following outline:\n    def generate():\n        # 1. Dynamic Parameter Selection:\n        # Do not include html inside the python code\n        # - Thoroughly analyze the HTML or data source to identify an extensive range of categories and units for computation.\n        # - Ensure the inclusion of a wide variety of units and values, covering different global measurement systems.\n        # - Develop a randomized selection algorithm to fairly choose a category or unit system, ensuring equitable representation.\n        # - When applicable, ensure that it alternates between SI and USCS for unit selection.\n        # 2. Value Generation:",
        "detail": "src.llm_generators.llm_templates",
        "documentation": {}
    },
    {
        "label": "assistant_template",
        "kind": 5,
        "importPath": "src.llm_generators.llm_templates",
        "description": "src.llm_generators.llm_templates",
        "peekOfCode": "assistant_template = \"\"\"\nRole: You are a personal physics tutor with access to solution guides for specific problems. Your goal is to guide students to find the solutions themselves by asking probing questions and gauging their understanding. You also have access to a code interpreter tool to perform necessary computations.\nGuidelines:\nCheck Solution Availability:\nStep 1: When a student asks a question, first check if the solution to the problem is available in the solution guides you have access to.\nUnavailable Solution: If the solution is not available, inform the student: \"I do not have access to the solution to that particular problem. However, I can try my best to help you understand the concepts and work through it. It is always best to review with a professor or attend office hours for further clarification.\"\nIdentify the Problem: If the solution is available, do not use it right away. Instead, proceed to identify the problem and the student's current understanding.\nAsk Probing Questions: Ask questions that lead the student to discover the steps and concepts needed to solve the problem. Gauge where they are with the material and identify what they are stuck on.\nProvide Hints: If the student is struggling, offer hints or partial steps that can help them progress without giving away the complete answer.\nUse Code Interpreter: If the solution requires complex computations, guide the student through the process and use the code interpreter tool to verify their calculations or help them understand the computation steps.",
        "detail": "src.llm_generators.llm_templates",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": "src.llm_generators.llm_templates",
        "description": "src.llm_generators.llm_templates",
        "peekOfCode": "G = 6.67430e-11  # Gravitational constant\nm1 = 5.97e24  # Mass of the Earth in kg\nm2 = 7.35e22  # Mass of the Moon in kg\nr = 3.84e8  # Distance between Earth and Moon in meters\nF = G * m1 * m2 / r**2\nF\n\"Now, what result do you get from this calculation?\"\nClarify Doubts: If the student has follow-up questions or needs clarification on any part of the solution, provide additional guiding questions or hints to help them understand better.\n\"\"\"\nextract_question_image_template = \"\"\"",
        "detail": "src.llm_generators.llm_templates",
        "documentation": {}
    },
    {
        "label": "m1",
        "kind": 5,
        "importPath": "src.llm_generators.llm_templates",
        "description": "src.llm_generators.llm_templates",
        "peekOfCode": "m1 = 5.97e24  # Mass of the Earth in kg\nm2 = 7.35e22  # Mass of the Moon in kg\nr = 3.84e8  # Distance between Earth and Moon in meters\nF = G * m1 * m2 / r**2\nF\n\"Now, what result do you get from this calculation?\"\nClarify Doubts: If the student has follow-up questions or needs clarification on any part of the solution, provide additional guiding questions or hints to help them understand better.\n\"\"\"\nextract_question_image_template = \"\"\"\nYou are tasked with analyzing the following image. Extract all the questions found in the image and return them as a JSON structure using the following format:",
        "detail": "src.llm_generators.llm_templates",
        "documentation": {}
    },
    {
        "label": "m2",
        "kind": 5,
        "importPath": "src.llm_generators.llm_templates",
        "description": "src.llm_generators.llm_templates",
        "peekOfCode": "m2 = 7.35e22  # Mass of the Moon in kg\nr = 3.84e8  # Distance between Earth and Moon in meters\nF = G * m1 * m2 / r**2\nF\n\"Now, what result do you get from this calculation?\"\nClarify Doubts: If the student has follow-up questions or needs clarification on any part of the solution, provide additional guiding questions or hints to help them understand better.\n\"\"\"\nextract_question_image_template = \"\"\"\nYou are tasked with analyzing the following image. Extract all the questions found in the image and return them as a JSON structure using the following format:\n{",
        "detail": "src.llm_generators.llm_templates",
        "documentation": {}
    },
    {
        "label": "r",
        "kind": 5,
        "importPath": "src.llm_generators.llm_templates",
        "description": "src.llm_generators.llm_templates",
        "peekOfCode": "r = 3.84e8  # Distance between Earth and Moon in meters\nF = G * m1 * m2 / r**2\nF\n\"Now, what result do you get from this calculation?\"\nClarify Doubts: If the student has follow-up questions or needs clarification on any part of the solution, provide additional guiding questions or hints to help them understand better.\n\"\"\"\nextract_question_image_template = \"\"\"\nYou are tasked with analyzing the following image. Extract all the questions found in the image and return them as a JSON structure using the following format:\n{\n    {",
        "detail": "src.llm_generators.llm_templates",
        "documentation": {}
    },
    {
        "label": "F",
        "kind": 5,
        "importPath": "src.llm_generators.llm_templates",
        "description": "src.llm_generators.llm_templates",
        "peekOfCode": "F = G * m1 * m2 / r**2\nF\n\"Now, what result do you get from this calculation?\"\nClarify Doubts: If the student has follow-up questions or needs clarification on any part of the solution, provide additional guiding questions or hints to help them understand better.\n\"\"\"\nextract_question_image_template = \"\"\"\nYou are tasked with analyzing the following image. Extract all the questions found in the image and return them as a JSON structure using the following format:\n{\n    {\n      \"question\": \"extracted question\",",
        "detail": "src.llm_generators.llm_templates",
        "documentation": {}
    },
    {
        "label": "extract_question_image_template",
        "kind": 5,
        "importPath": "src.llm_generators.llm_templates",
        "description": "src.llm_generators.llm_templates",
        "peekOfCode": "extract_question_image_template = \"\"\"\nYou are tasked with analyzing the following image. Extract all the questions found in the image and return them as a JSON structure using the following format:\n{\n    {\n      \"question\": \"extracted question\",\n      \"question_number\": \"the number of the question\",\n      \"requires_image\": true/false,\n      \"question_complete\": true/false\n    }\n}",
        "detail": "src.llm_generators.llm_templates",
        "documentation": {}
    },
    {
        "label": "LLM_Call",
        "kind": 6,
        "importPath": "src.llm_module_generator.config.llm_call",
        "description": "src.llm_module_generator.config.llm_call",
        "peekOfCode": "class LLM_Call():\n    llm_config: LLMConfig\n    total_tokens: int = field(default=0,init=False)\n    def __post_init__(self):\n        self.client_async = AsyncOpenAI(api_key = self.llm_config.api_key)\n    async def acall(self, prompt: str, response_format: Union[Dict, BaseModel] = None): # type: ignore\n        try:\n            response = await self.client_async.beta.chat.completions.parse( # type: ignore\n                model = self.llm_config.model,\n            messages=[",
        "detail": "src.llm_module_generator.config.llm_call",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.llm_module_generator.config.llm_call",
        "description": "src.llm_module_generator.config.llm_call",
        "peekOfCode": "def main():\n    llm_config = LLMConfig(api_key=api_key, model=\"chatgpt-4o-latest\", temperature=0)\n    completion_model = LLM_Call(llm_config)\n    print(asyncio.run(completion_model.acall(\"Hello\")))\n    print(asyncio.run(completion_model.acall(\"How are you\")))\n    print(completion_model.get_total_tokens())\nif __name__ == \"__main__\":\n    main()",
        "detail": "src.llm_module_generator.config.llm_call",
        "documentation": {}
    },
    {
        "label": "LLMConfig",
        "kind": 6,
        "importPath": "src.llm_module_generator.config.llm_config",
        "description": "src.llm_module_generator.config.llm_config",
        "peekOfCode": "class LLMConfig:\n    api_key:str\n    model:str\n    temperature:float",
        "detail": "src.llm_module_generator.config.llm_config",
        "documentation": {}
    },
    {
        "label": "conceptual_question_prompt",
        "kind": 5,
        "importPath": "src.llm_module_generator.image_extraction.image_extraction_prompts",
        "description": "src.llm_module_generator.image_extraction.image_extraction_prompts",
        "peekOfCode": "conceptual_question_prompt = \"\"\"\n    You are tasked with analyzing the following lecture slides covering a specific class topic. Please address the following:\n    1. **Conceptual Questions**: Generate 4 multiple-choice conceptual questions based on the lecture material, each with 4 options. Indicate the correct answer for each question.\n    These questions can either be derived based on the information from the lecture slides or they can be generated by you. If you decide to generate, you need to indicate this in the response as a bool.\n    Always return the sources of where these questions are derived from.\n    Format any mathematical symbols or equations using LaTeX.\n    \"\"\"\nlecture_analysis_prompt =\"\"\"\n    You are tasked with analyzing the following lecture slides covering a specific class topic. Please address the following questions and return the results as a JSON structure with the specified keys:\n    1. **summary**: Provide a comprehensive summary of the lecture material.",
        "detail": "src.llm_module_generator.image_extraction.image_extraction_prompts",
        "documentation": {}
    },
    {
        "label": "extract_computation_questions_prompt",
        "kind": 5,
        "importPath": "src.llm_module_generator.image_extraction.image_extraction_prompts",
        "description": "src.llm_module_generator.image_extraction.image_extraction_prompts",
        "peekOfCode": "extract_computation_questions_prompt = \"\"\"\nExtract and process the content from the provided image according to these guidelines:\n1. **Question Extraction:**\n   - Extract all the computational questions from the image or lecture material. Ensure that all necessary details, data, and parameters are included to fully understand the question.\n   - Represent any special characters, such as mathematical symbols, in LaTeX format.\n   - Clearly identify and extract the source of the question.\n2. **Solution Steps:**\n   - For each question, provide a detailed solution with step-by-step explanations. Use LaTeX for formatting any mathematical symbols or equations.\n   - Ensure that the solution guide strictly adheres to the symbolic representation requirement, with no numerical values included in the steps.\n3. **Image Requirements:**",
        "detail": "src.llm_module_generator.image_extraction.image_extraction_prompts",
        "documentation": {}
    },
    {
        "label": "LectureSummary",
        "kind": 6,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "class LectureSummary(BaseModel):\n    summary: str = Field(..., description=\"A summary of the lecture material, describing the essence of what the lecture was about. Use LaTeX for any mathematical symbols or equations.\")\n    key_concepts: List[str] = Field(..., description=\"A list of key concepts covered in the lecture. Use LaTeX for any mathematical symbols or equations.\")\n    keywords: List[str] = Field(..., description=\"A list of keywords that describe the lecture. Use LaTeX for any mathematical symbols or equations.\")\n    foundational_concepts: List[str] = Field(..., description=\"A list of prerequisite concepts that the lecture builds upon. Use LaTeX for any mathematical symbols or equations.\")\nclass LectureAnalysis(BaseModel):\n    analysis: LectureSummary = Field(..., description=\"The analysis of the lecture material.\")\nclass Step(BaseModel):\n    explanation: str = Field(..., description=\"An explanation of the step involved in solving the problem, using LaTeX for any mathematical symbols or equations.\")\n    output: str = Field(..., description=\"The output or result of the step, formatted in LaTeX if it includes any mathematical symbols or equations.\")",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "LectureAnalysis",
        "kind": 6,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "class LectureAnalysis(BaseModel):\n    analysis: LectureSummary = Field(..., description=\"The analysis of the lecture material.\")\nclass Step(BaseModel):\n    explanation: str = Field(..., description=\"An explanation of the step involved in solving the problem, using LaTeX for any mathematical symbols or equations.\")\n    output: str = Field(..., description=\"The output or result of the step, formatted in LaTeX if it includes any mathematical symbols or equations.\")\nclass ImageReq(BaseModel):\n    requires_image: bool = Field(..., description=\"Indicate whether the question requires an image to solve.\")\n    image_description: Optional[str] = Field(None, description=\"If the question requires an image to solve, provide a description of the image that is needed.\")\nclass ExternalDataReq(BaseModel):\n    requires_external_data: bool = Field(..., description=\"Indicates whether external data, such as tabular data or charts, is needed to solve the question.\")",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "Step",
        "kind": 6,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "class Step(BaseModel):\n    explanation: str = Field(..., description=\"An explanation of the step involved in solving the problem, using LaTeX for any mathematical symbols or equations.\")\n    output: str = Field(..., description=\"The output or result of the step, formatted in LaTeX if it includes any mathematical symbols or equations.\")\nclass ImageReq(BaseModel):\n    requires_image: bool = Field(..., description=\"Indicate whether the question requires an image to solve.\")\n    image_description: Optional[str] = Field(None, description=\"If the question requires an image to solve, provide a description of the image that is needed.\")\nclass ExternalDataReq(BaseModel):\n    requires_external_data: bool = Field(..., description=\"Indicates whether external data, such as tabular data or charts, is needed to solve the question.\")\n    external_data: Optional[str] = Field(None, description=\"If external data is required, indicate the required data.\")\nclass ComputationalQuestion(BaseModel):",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "ImageReq",
        "kind": 6,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "class ImageReq(BaseModel):\n    requires_image: bool = Field(..., description=\"Indicate whether the question requires an image to solve.\")\n    image_description: Optional[str] = Field(None, description=\"If the question requires an image to solve, provide a description of the image that is needed.\")\nclass ExternalDataReq(BaseModel):\n    requires_external_data: bool = Field(..., description=\"Indicates whether external data, such as tabular data or charts, is needed to solve the question.\")\n    external_data: Optional[str] = Field(None, description=\"If external data is required, indicate the required data.\")\nclass ComputationalQuestion(BaseModel):\n    question: str = Field(..., description=\"A computational question that requires computation. Format any mathematical symbols or equations using LaTeX.\")\n    solution: Optional[List[Step]] = Field(None, description=\"A detailed solution with steps for the computational question, using LaTeX for formatting any mathematical symbols or equations. This field is optional and should be `None` if a solution is not present, particularly if the `complete` field is `false`.\")\n    source: str = Field(..., description=\"The source from which this question is derived.\")",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "ExternalDataReq",
        "kind": 6,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "class ExternalDataReq(BaseModel):\n    requires_external_data: bool = Field(..., description=\"Indicates whether external data, such as tabular data or charts, is needed to solve the question.\")\n    external_data: Optional[str] = Field(None, description=\"If external data is required, indicate the required data.\")\nclass ComputationalQuestion(BaseModel):\n    question: str = Field(..., description=\"A computational question that requires computation. Format any mathematical symbols or equations using LaTeX.\")\n    solution: Optional[List[Step]] = Field(None, description=\"A detailed solution with steps for the computational question, using LaTeX for formatting any mathematical symbols or equations. This field is optional and should be `None` if a solution is not present, particularly if the `complete` field is `false`.\")\n    source: str = Field(..., description=\"The source from which this question is derived.\")\n    complete: bool = Field(..., description=\"Indicates if the computational question is completed with the solutions. If `false`, the `solution` field can be `None`.\")\n    image_req: List[ImageReq] = Field(..., description=\"A list of image requirements for understanding the question, if any.\")\n    external_data_req: ExternalDataReq",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "ComputationalQuestion",
        "kind": 6,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "class ComputationalQuestion(BaseModel):\n    question: str = Field(..., description=\"A computational question that requires computation. Format any mathematical symbols or equations using LaTeX.\")\n    solution: Optional[List[Step]] = Field(None, description=\"A detailed solution with steps for the computational question, using LaTeX for formatting any mathematical symbols or equations. This field is optional and should be `None` if a solution is not present, particularly if the `complete` field is `false`.\")\n    source: str = Field(..., description=\"The source from which this question is derived.\")\n    complete: bool = Field(..., description=\"Indicates if the computational question is completed with the solutions. If `false`, the `solution` field can be `None`.\")\n    image_req: List[ImageReq] = Field(..., description=\"A list of image requirements for understanding the question, if any.\")\n    external_data_req: ExternalDataReq\nclass ExtractedCompuationalQuestions(BaseModel):\n    extracted_question: List[ComputationalQuestion] = Field(...,description=\"A list of all the extracted questions\")\nclass ImageRequirements(BaseModel):",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "ExtractedCompuationalQuestions",
        "kind": 6,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "class ExtractedCompuationalQuestions(BaseModel):\n    extracted_question: List[ComputationalQuestion] = Field(...,description=\"A list of all the extracted questions\")\nclass ImageRequirements(BaseModel):\n    requires_image: str = Field(..., description=\"Indicates if the derivation requires an image to fully understand the derivation. Should be 'True' or 'False'.\")\n    recommended_image: str = Field(..., description=\"If the image is required, provide a recommendation of what the image should depict.\")\nclass SingleDerivation(BaseModel):\n    derivation_name: str = Field(..., description=\"The name of the derivation and what it aims to demonstrate.\")\n    derivation_steps: List[Step] = Field(..., description=\"A list of steps involved in the derivation, each step explained and formatted using LaTeX for mathematical symbols or equations.\")\n    derivation_source: str = Field(..., description=\"The source from which this derivation is derived.\")\n    image_stats: List[ImageRequirements] = Field(..., description=\"A list of image requirements for understanding the derivation, if any.\")",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "ImageRequirements",
        "kind": 6,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "class ImageRequirements(BaseModel):\n    requires_image: str = Field(..., description=\"Indicates if the derivation requires an image to fully understand the derivation. Should be 'True' or 'False'.\")\n    recommended_image: str = Field(..., description=\"If the image is required, provide a recommendation of what the image should depict.\")\nclass SingleDerivation(BaseModel):\n    derivation_name: str = Field(..., description=\"The name of the derivation and what it aims to demonstrate.\")\n    derivation_steps: List[Step] = Field(..., description=\"A list of steps involved in the derivation, each step explained and formatted using LaTeX for mathematical symbols or equations.\")\n    derivation_source: str = Field(..., description=\"The source from which this derivation is derived.\")\n    image_stats: List[ImageRequirements] = Field(..., description=\"A list of image requirements for understanding the derivation, if any.\")\nclass DerivationResponse(BaseModel):\n    derivations: List[SingleDerivation] = Field(..., description=\"A list of derivations, each containing its name, steps, source, and image requirements if applicable.\")",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "SingleDerivation",
        "kind": 6,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "class SingleDerivation(BaseModel):\n    derivation_name: str = Field(..., description=\"The name of the derivation and what it aims to demonstrate.\")\n    derivation_steps: List[Step] = Field(..., description=\"A list of steps involved in the derivation, each step explained and formatted using LaTeX for mathematical symbols or equations.\")\n    derivation_source: str = Field(..., description=\"The source from which this derivation is derived.\")\n    image_stats: List[ImageRequirements] = Field(..., description=\"A list of image requirements for understanding the derivation, if any.\")\nclass DerivationResponse(BaseModel):\n    derivations: List[SingleDerivation] = Field(..., description=\"A list of derivations, each containing its name, steps, source, and image requirements if applicable.\")\nclass ConceptualQuestion(BaseModel):\n    question: str = Field(..., description=\"A conceptual question based on the lecture material that does not require any computation. Format any mathematical symbols or equations using LaTeX.\")\n    multiple_choice_options: List[str] = Field(..., description=\"Four multiple-choice options for the conceptual question. Format any mathematical symbols or equations using LaTeX.\")",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "DerivationResponse",
        "kind": 6,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "class DerivationResponse(BaseModel):\n    derivations: List[SingleDerivation] = Field(..., description=\"A list of derivations, each containing its name, steps, source, and image requirements if applicable.\")\nclass ConceptualQuestion(BaseModel):\n    question: str = Field(..., description=\"A conceptual question based on the lecture material that does not require any computation. Format any mathematical symbols or equations using LaTeX.\")\n    multiple_choice_options: List[str] = Field(..., description=\"Four multiple-choice options for the conceptual question. Format any mathematical symbols or equations using LaTeX.\")\n    correct_answer: str = Field(..., description=\"The correct option from the multiple-choice options. Format any mathematical symbols or equations using LaTeX.\")\n    source: str = Field(..., description=\"The source from which this question is derived.\")\n    generated: bool = Field(..., description=\"Whether the question was generated or extracted from the lecture material.\")\nclass Questions(BaseModel):\n    questions: List[ConceptualQuestion] = Field(..., description=\"A list of conceptual questions based on the lecture material.\")",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "ConceptualQuestion",
        "kind": 6,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "class ConceptualQuestion(BaseModel):\n    question: str = Field(..., description=\"A conceptual question based on the lecture material that does not require any computation. Format any mathematical symbols or equations using LaTeX.\")\n    multiple_choice_options: List[str] = Field(..., description=\"Four multiple-choice options for the conceptual question. Format any mathematical symbols or equations using LaTeX.\")\n    correct_answer: str = Field(..., description=\"The correct option from the multiple-choice options. Format any mathematical symbols or equations using LaTeX.\")\n    source: str = Field(..., description=\"The source from which this question is derived.\")\n    generated: bool = Field(..., description=\"Whether the question was generated or extracted from the lecture material.\")\nclass Questions(BaseModel):\n    questions: List[ConceptualQuestion] = Field(..., description=\"A list of conceptual questions based on the lecture material.\")\n# Define the JSON schemas\nlecture_schema = LectureAnalysis.model_json_schema()",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "Questions",
        "kind": 6,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "class Questions(BaseModel):\n    questions: List[ConceptualQuestion] = Field(..., description=\"A list of conceptual questions based on the lecture material.\")\n# Define the JSON schemas\nlecture_schema = LectureAnalysis.model_json_schema()\ncomputational_schema = ExtractedCompuationalQuestions.model_json_schema()\nderivation_schema = DerivationResponse.model_json_schema()\nconceputual_question_schema = Questions.model_json_schema()\n## Define all the extractors\nextract_summary = ImageToLLMProcessor(prompt=lecture_analysis_prompt,response_schema=lecture_schema)\nextract_computational_questions = ImageToLLMProcessor(prompt=extract_computation_questions_prompt,response_schema=computational_schema)",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "lecture_schema",
        "kind": 5,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "lecture_schema = LectureAnalysis.model_json_schema()\ncomputational_schema = ExtractedCompuationalQuestions.model_json_schema()\nderivation_schema = DerivationResponse.model_json_schema()\nconceputual_question_schema = Questions.model_json_schema()\n## Define all the extractors\nextract_summary = ImageToLLMProcessor(prompt=lecture_analysis_prompt,response_schema=lecture_schema)\nextract_computational_questions = ImageToLLMProcessor(prompt=extract_computation_questions_prompt,response_schema=computational_schema)\nextract_derivations = ImageToLLMProcessor(prompt = extract_derivations_prompt, response_schema = derivation_schema)\nextract_conceptual_questions = ImageToLLMProcessor(prompt = conceptual_question_prompt, response_schema = conceputual_question_schema)\nasync def process_with_extractor(extractor: ImageToLLMProcessor, image_paths: List[str], prompt: str) -> dict:",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "computational_schema",
        "kind": 5,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "computational_schema = ExtractedCompuationalQuestions.model_json_schema()\nderivation_schema = DerivationResponse.model_json_schema()\nconceputual_question_schema = Questions.model_json_schema()\n## Define all the extractors\nextract_summary = ImageToLLMProcessor(prompt=lecture_analysis_prompt,response_schema=lecture_schema)\nextract_computational_questions = ImageToLLMProcessor(prompt=extract_computation_questions_prompt,response_schema=computational_schema)\nextract_derivations = ImageToLLMProcessor(prompt = extract_derivations_prompt, response_schema = derivation_schema)\nextract_conceptual_questions = ImageToLLMProcessor(prompt = conceptual_question_prompt, response_schema = conceputual_question_schema)\nasync def process_with_extractor(extractor: ImageToLLMProcessor, image_paths: List[str], prompt: str) -> dict:\n    \"\"\"",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "derivation_schema",
        "kind": 5,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "derivation_schema = DerivationResponse.model_json_schema()\nconceputual_question_schema = Questions.model_json_schema()\n## Define all the extractors\nextract_summary = ImageToLLMProcessor(prompt=lecture_analysis_prompt,response_schema=lecture_schema)\nextract_computational_questions = ImageToLLMProcessor(prompt=extract_computation_questions_prompt,response_schema=computational_schema)\nextract_derivations = ImageToLLMProcessor(prompt = extract_derivations_prompt, response_schema = derivation_schema)\nextract_conceptual_questions = ImageToLLMProcessor(prompt = conceptual_question_prompt, response_schema = conceputual_question_schema)\nasync def process_with_extractor(extractor: ImageToLLMProcessor, image_paths: List[str], prompt: str) -> dict:\n    \"\"\"\n    Process the images using the specified extractor and return the structured response.",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "conceputual_question_schema",
        "kind": 5,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "conceputual_question_schema = Questions.model_json_schema()\n## Define all the extractors\nextract_summary = ImageToLLMProcessor(prompt=lecture_analysis_prompt,response_schema=lecture_schema)\nextract_computational_questions = ImageToLLMProcessor(prompt=extract_computation_questions_prompt,response_schema=computational_schema)\nextract_derivations = ImageToLLMProcessor(prompt = extract_derivations_prompt, response_schema = derivation_schema)\nextract_conceptual_questions = ImageToLLMProcessor(prompt = conceptual_question_prompt, response_schema = conceputual_question_schema)\nasync def process_with_extractor(extractor: ImageToLLMProcessor, image_paths: List[str], prompt: str) -> dict:\n    \"\"\"\n    Process the images using the specified extractor and return the structured response.\n    Args:",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "extract_summary",
        "kind": 5,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "extract_summary = ImageToLLMProcessor(prompt=lecture_analysis_prompt,response_schema=lecture_schema)\nextract_computational_questions = ImageToLLMProcessor(prompt=extract_computation_questions_prompt,response_schema=computational_schema)\nextract_derivations = ImageToLLMProcessor(prompt = extract_derivations_prompt, response_schema = derivation_schema)\nextract_conceptual_questions = ImageToLLMProcessor(prompt = conceptual_question_prompt, response_schema = conceputual_question_schema)\nasync def process_with_extractor(extractor: ImageToLLMProcessor, image_paths: List[str], prompt: str) -> dict:\n    \"\"\"\n    Process the images using the specified extractor and return the structured response.\n    Args:\n        extractor (ImageToLLMProcessor): The extractor instance to process the images.\n        image_paths (List[str]): A list of paths to the images to be processed.",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "extract_computational_questions",
        "kind": 5,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "extract_computational_questions = ImageToLLMProcessor(prompt=extract_computation_questions_prompt,response_schema=computational_schema)\nextract_derivations = ImageToLLMProcessor(prompt = extract_derivations_prompt, response_schema = derivation_schema)\nextract_conceptual_questions = ImageToLLMProcessor(prompt = conceptual_question_prompt, response_schema = conceputual_question_schema)\nasync def process_with_extractor(extractor: ImageToLLMProcessor, image_paths: List[str], prompt: str) -> dict:\n    \"\"\"\n    Process the images using the specified extractor and return the structured response.\n    Args:\n        extractor (ImageToLLMProcessor): The extractor instance to process the images.\n        image_paths (List[str]): A list of paths to the images to be processed.\n        prompt (str): The prompt to send along with the images.",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "extract_derivations",
        "kind": 5,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "extract_derivations = ImageToLLMProcessor(prompt = extract_derivations_prompt, response_schema = derivation_schema)\nextract_conceptual_questions = ImageToLLMProcessor(prompt = conceptual_question_prompt, response_schema = conceputual_question_schema)\nasync def process_with_extractor(extractor: ImageToLLMProcessor, image_paths: List[str], prompt: str) -> dict:\n    \"\"\"\n    Process the images using the specified extractor and return the structured response.\n    Args:\n        extractor (ImageToLLMProcessor): The extractor instance to process the images.\n        image_paths (List[str]): A list of paths to the images to be processed.\n        prompt (str): The prompt to send along with the images.\n    Returns:",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "extract_conceptual_questions",
        "kind": 5,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "extract_conceptual_questions = ImageToLLMProcessor(prompt = conceptual_question_prompt, response_schema = conceputual_question_schema)\nasync def process_with_extractor(extractor: ImageToLLMProcessor, image_paths: List[str], prompt: str) -> dict:\n    \"\"\"\n    Process the images using the specified extractor and return the structured response.\n    Args:\n        extractor (ImageToLLMProcessor): The extractor instance to process the images.\n        image_paths (List[str]): A list of paths to the images to be processed.\n        prompt (str): The prompt to send along with the images.\n    Returns:\n        dict: The structured response obtained from the images.",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "ImageToLLMProcessor",
        "kind": 6,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_processor",
        "description": "src.llm_module_generator.image_extraction.image_llm_processor",
        "peekOfCode": "class ImageToLLMProcessor:\n    \"\"\"\n    A class responsible for processing images and interacting with an LLM.\n    Attributes\n        total_tokens (int): The total number of tokens used in LLM responses.\n    \"\"\"\n    prompt:str \n    response_schema:str \n    total_tokens: int = field(default=0, init=False)\n    def __post_init__(self):",
        "detail": "src.llm_module_generator.image_extraction.image_llm_processor",
        "documentation": {}
    },
    {
        "label": "LLMUIBuilder",
        "kind": 6,
        "importPath": "src.llm_module_generator.ui_generator.ui_builder",
        "description": "src.llm_module_generator.ui_generator.ui_builder",
        "peekOfCode": "class LLMUIBuilder(LLM_Call):\n    \"\"\"\n    LLMUIBuilder is a subclass of LLM_Call designed to generate a user interface (UI)\n    using a large language model (LLM). The class allows the construction of a UI\n    based on a provided prompt and applies predefined CSS categories to the generated\n    UI elements.\n    Attributes:\n        llm_config (LLMConfig): Configuration for the LLM.\n        css_category (str): The category of CSS styles to apply.\n        css_description (str): A description of the CSS styles applied, initialized in `__post_init__`.",
        "detail": "src.llm_module_generator.ui_generator.ui_builder",
        "documentation": {}
    },
    {
        "label": "unescape_backslashes",
        "kind": 2,
        "importPath": "src.llm_module_generator.ui_generator.ui_builder",
        "description": "src.llm_module_generator.ui_generator.ui_builder",
        "peekOfCode": "def unescape_backslashes(latex_string):\n    return latex_string.replace('\\\\\\\\', '\\\\')\n@dataclass\nclass LLMUIBuilder(LLM_Call):\n    \"\"\"\n    LLMUIBuilder is a subclass of LLM_Call designed to generate a user interface (UI)\n    using a large language model (LLM). The class allows the construction of a UI\n    based on a provided prompt and applies predefined CSS categories to the generated\n    UI elements.\n    Attributes:",
        "detail": "src.llm_module_generator.ui_generator.ui_builder",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.llm_module_generator.ui_generator.ui_builder",
        "description": "src.llm_module_generator.ui_generator.ui_builder",
        "peekOfCode": "logger = get_logger(__name__)\ndef unescape_backslashes(latex_string):\n    return latex_string.replace('\\\\\\\\', '\\\\')\n@dataclass\nclass LLMUIBuilder(LLM_Call):\n    \"\"\"\n    LLMUIBuilder is a subclass of LLM_Call designed to generate a user interface (UI)\n    using a large language model (LLM). The class allows the construction of a UI\n    based on a provided prompt and applies predefined CSS categories to the generated\n    UI elements.",
        "detail": "src.llm_module_generator.ui_generator.ui_builder",
        "documentation": {}
    },
    {
        "label": "ConceptualQuestionUIBuilder",
        "kind": 6,
        "importPath": "src.llm_module_generator.ui_generator.ui_generators",
        "description": "src.llm_module_generator.ui_generator.ui_generators",
        "peekOfCode": "class ConceptualQuestionUIBuilder(LLMUIBuilder):\n    total_tokens: int = field(default=0,init=False)\n    def __post_init__(self):\n        self.extractor = extract_computational_questions\n    async def extract_questions(self, image_paths:list[str]):\n        result = await self.extractor.send_request(image_paths)\n        return result\n    pass\nasync def main():\n    llm_config = LLMConfig(api_key=api_key, model=\"gpt-4o\", temperature=0)",
        "detail": "src.llm_module_generator.ui_generator.ui_generators",
        "documentation": {}
    },
    {
        "label": "UIType",
        "kind": 6,
        "importPath": "src.llm_module_generator.ui_generator.ui_response",
        "description": "src.llm_module_generator.ui_generator.ui_response",
        "peekOfCode": "class UIType(str,Enum):\n        div = \"div\"\n        p = \"p\"\n        ul = \"ul\"\n        ol = \"ol\"\n        li = \"li\"\n        h1 = \"h1\"\n        h2 = \"h2\"\n        span = \"span\"\n        strong = \"strong\"",
        "detail": "src.llm_module_generator.ui_generator.ui_response",
        "documentation": {}
    },
    {
        "label": "Attribute",
        "kind": 6,
        "importPath": "src.llm_module_generator.ui_generator.ui_response",
        "description": "src.llm_module_generator.ui_generator.ui_response",
        "peekOfCode": "class Attribute(BaseModel):\n        name: str = Field(..., description=\"Name of html attribute\")\n        value: str = Field(..., description=\"Value of the html attribute \")                \nclass UI(BaseModel):\n    type: UIType\n    label: str = Field(..., description=\"Content to be placed inside HTML tags. If you need to write mathematical symbols or equations, use LaTeX enclosed within `$...$` for inline math or `$$...$$` for display math to ensure compatibility with the HTML file.\")\n    children: List[\"UI\"]\n    attributes: List[Attribute]\n    _valid_css: Dict[UIType, List[str]] = {}\n    @classmethod",
        "detail": "src.llm_module_generator.ui_generator.ui_response",
        "documentation": {}
    },
    {
        "label": "UI",
        "kind": 6,
        "importPath": "src.llm_module_generator.ui_generator.ui_response",
        "description": "src.llm_module_generator.ui_generator.ui_response",
        "peekOfCode": "class UI(BaseModel):\n    type: UIType\n    label: str = Field(..., description=\"Content to be placed inside HTML tags. If you need to write mathematical symbols or equations, use LaTeX enclosed within `$...$` for inline math or `$$...$$` for display math to ensure compatibility with the HTML file.\")\n    children: List[\"UI\"]\n    attributes: List[Attribute]\n    _valid_css: Dict[UIType, List[str]] = {}\n    @classmethod\n    def set_valid_css(cls, category_interest: str = None): # type: ignore\n        cls._valid_css = {}  # Resetting the valid CSS dictionary\n        selected_css_styles = css_styles.get(category_interest, {})",
        "detail": "src.llm_module_generator.ui_generator.ui_response",
        "documentation": {}
    },
    {
        "label": "get_css_description",
        "kind": 2,
        "importPath": "src.llm_module_generator.ui_generator.ui_response",
        "description": "src.llm_module_generator.ui_generator.ui_response",
        "peekOfCode": "def get_css_description(UItype: UIType,category_interest):\n    css_descriptions = \"\"\n    selected_css_styles = css_styles.get(category_interest, {})\n    generic_css_styles = css_styles.get(\"general_styles\", {})\n    # Combine selected and generic styles\n    available_styles = {**selected_css_styles, **generic_css_styles}\n    for uitype, css_items in available_styles.items():\n         if uitype in UIType.__members__:\n             for css_item in css_items:\n                css_descriptions += f\"\\nUI Type: {uitype}\\n\"",
        "detail": "src.llm_module_generator.ui_generator.ui_response",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.llm_module_generator.ui_generator.ui_response",
        "description": "src.llm_module_generator.ui_generator.ui_response",
        "peekOfCode": "logger = get_logger(__name__)\nbase_dir = os.path.dirname(os.path.abspath(__file__))\ncss_styles_file = os.path.join(base_dir, 'valid_css_styles_bootstrap.json')\nwith open(css_styles_file,\"r\") as file:\n    css_styles = json.load(file)\nclass UIType(str,Enum):\n        div = \"div\"\n        p = \"p\"\n        ul = \"ul\"\n        ol = \"ol\"",
        "detail": "src.llm_module_generator.ui_generator.ui_response",
        "documentation": {}
    },
    {
        "label": "base_dir",
        "kind": 5,
        "importPath": "src.llm_module_generator.ui_generator.ui_response",
        "description": "src.llm_module_generator.ui_generator.ui_response",
        "peekOfCode": "base_dir = os.path.dirname(os.path.abspath(__file__))\ncss_styles_file = os.path.join(base_dir, 'valid_css_styles_bootstrap.json')\nwith open(css_styles_file,\"r\") as file:\n    css_styles = json.load(file)\nclass UIType(str,Enum):\n        div = \"div\"\n        p = \"p\"\n        ul = \"ul\"\n        ol = \"ol\"\n        li = \"li\"",
        "detail": "src.llm_module_generator.ui_generator.ui_response",
        "documentation": {}
    },
    {
        "label": "css_styles_file",
        "kind": 5,
        "importPath": "src.llm_module_generator.ui_generator.ui_response",
        "description": "src.llm_module_generator.ui_generator.ui_response",
        "peekOfCode": "css_styles_file = os.path.join(base_dir, 'valid_css_styles_bootstrap.json')\nwith open(css_styles_file,\"r\") as file:\n    css_styles = json.load(file)\nclass UIType(str,Enum):\n        div = \"div\"\n        p = \"p\"\n        ul = \"ul\"\n        ol = \"ol\"\n        li = \"li\"\n        h1 = \"h1\"",
        "detail": "src.llm_module_generator.ui_generator.ui_response",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "kind": 2,
        "importPath": "src.logging_config.logging_config",
        "description": "src.logging_config.logging_config",
        "peekOfCode": "def get_logger(name):\n    return logging.getLogger(name)",
        "detail": "src.logging_config.logging_config",
        "documentation": {}
    },
    {
        "label": "import_module_from_path",
        "kind": 2,
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "peekOfCode": "def import_module_from_path(path):\n    \"\"\"imports a module and returs a module\n    Args:\n        path (str): path to module\n    Returns:\n        <class 'module'>: returns a module that i can run. \n    \"\"\"\n    # The function of interest is generate\n    spec = importlib.util.spec_from_file_location(\"generate\",path)\n    # Load the module from the created spec",
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "run_generate_py",
        "kind": 2,
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "peekOfCode": "def run_generate_py(path:str)->dict:\n    \"\"\"Imports a server.py module from a path, then we run the function generate found inside the function \n    Args:\n        path (str): path to the module\n    Returns:\n        dict: A dictionary containing params for question \n    \"\"\"\n    module = import_module_from_path(path)\n    data = module.generate()\n    return data",
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "run_generate_js",
        "kind": 2,
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "peekOfCode": "def run_generate_js(path):\n    with open(path, 'r') as file:\n        js_code = file.read()\n    context = execjs.compile(js_code)\n    return context.call(\"generate\")\ndef run_generate(path:str):\n    generators = {\n        \"server.js\": run_generate_js,\n        \"server.py\": run_generate_py\n    }",
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "run_generate",
        "kind": 2,
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "peekOfCode": "def run_generate(path:str):\n    generators = {\n        \"server.js\": run_generate_js,\n        \"server.py\": run_generate_py\n    }\n    if not os.path.isfile(path):\n        return ({\"error\": \"File not found\"}), 404\n    base_name = os.path.basename(path)\n    try:\n        if base_name in generators.keys():",
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "file_exist",
        "kind": 2,
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "peekOfCode": "def file_exist(file_path:str)->bool:\n    return os.path.exists(file_path)\ndef read_file(file_path:str):\n    file_exist(file_path)\n    with open(file_path,\"r\") as file:\n        return file.read()\ndef generateAdaptive(quiz_path:str,code_lang:str=\"python\"):\n    files_to_check = [\"question.html\", \"server.js\",\"server.py\",\"info.json\",\"solutions.html\"]\n    valid_files = {file:os.path.join(quiz_path, file) for file in files_to_check if file_exist(os.path.join(quiz_path, file))}\n    print(valid_files)",
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "read_file",
        "kind": 2,
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "peekOfCode": "def read_file(file_path:str):\n    file_exist(file_path)\n    with open(file_path,\"r\") as file:\n        return file.read()\ndef generateAdaptive(quiz_path:str,code_lang:str=\"python\"):\n    files_to_check = [\"question.html\", \"server.js\",\"server.py\",\"info.json\",\"solutions.html\"]\n    valid_files = {file:os.path.join(quiz_path, file) for file in files_to_check if file_exist(os.path.join(quiz_path, file))}\n    print(valid_files)\n    quiz_name = os.path.basename(quiz_path)\n    server_file = None",
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "generateAdaptive",
        "kind": 2,
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "peekOfCode": "def generateAdaptive(quiz_path:str,code_lang:str=\"python\"):\n    files_to_check = [\"question.html\", \"server.js\",\"server.py\",\"info.json\",\"solutions.html\"]\n    valid_files = {file:os.path.join(quiz_path, file) for file in files_to_check if file_exist(os.path.join(quiz_path, file))}\n    print(valid_files)\n    quiz_name = os.path.basename(quiz_path)\n    server_file = None\n    if code_lang.lower()==\"python\":\n        server_file = valid_files.get(\"server.py\")\n    elif code_lang.lower() == \"javascript\":\n        server_file = valid_files.get(\"server.js\")",
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "save_files_temp",
        "kind": 2,
        "importPath": "src.utils.file_handler",
        "description": "src.utils.file_handler",
        "peekOfCode": "def save_files_temp(question_title: str, files: Dict[str, Any]) -> str:\n    \"\"\"\n    Saves files with their respective content to a temporary directory.\n    This function creates a temporary directory, saves the provided files with their content \n    under a subdirectory named after `question_title`, and returns the path to the created directory.\n    Args:\n        question_title (str): The title of the question, which will be used as the name of the subdirectory.\n        files (Dict[str, Any]): A dictionary where the keys are filenames (str) and the values are the corresponding file contents. \n                                The content can be either a string or a dictionary.\n    Returns:",
        "detail": "src.utils.file_handler",
        "documentation": {}
    },
    {
        "label": "create_zip_file",
        "kind": 2,
        "importPath": "src.utils.file_handler",
        "description": "src.utils.file_handler",
        "peekOfCode": "def create_zip_file(file_paths: List[str]) -> io.BytesIO:\n    \"\"\"\n    Creates an in-memory ZIP file from the list of file paths, storing only the basename of each file in the archive.\n    Args:\n        file_paths (List[str]): A list of file paths to include in the ZIP archive.\n    Returns:\n        io.BytesIO: A BytesIO object containing the ZIP file data.\n    \"\"\"\n    memory_file = io.BytesIO()\n    with zipfile.ZipFile(memory_file, 'w') as zipf:",
        "detail": "src.utils.file_handler",
        "documentation": {}
    },
    {
        "label": "save_temp_dir_as_zip",
        "kind": 2,
        "importPath": "src.utils.file_handler",
        "description": "src.utils.file_handler",
        "peekOfCode": "def save_temp_dir_as_zip(temp_dir: str) -> io.BytesIO:\n    \"\"\"\n    Saves the contents of the temporary directory to a zip file and returns it as a BytesIO object.\n    Args:\n        temp_dir (str): The path to the temporary directory.\n    Returns:\n        io.BytesIO: A BytesIO object containing the zipped content of the temporary directory.\n    \"\"\"\n    # Verify if temp_dir exists and list its contents\n    if not os.path.exists(temp_dir):",
        "detail": "src.utils.file_handler",
        "documentation": {}
    },
    {
        "label": "pl_number_input",
        "kind": 2,
        "importPath": "src.utils.plutilities",
        "description": "src.utils.plutilities",
        "peekOfCode": "def pl_number_input(soup, tag_name: str, qdata: dict):\n    if not isinstance(soup, BeautifulSoup):\n        raise TypeError(\"The 'soup' argument must be a BeautifulSoup object.\")\n    # Find all old tags that match the provided tag name\n    old_tags = soup.find_all(tag_name)\n    for old_tag in old_tags:\n        # Extract attributes from the old tag\n        attribute = old_tag.attrs\n        answers_name = attribute.get(\"answers-name\",\"\")\n        # print(f'This is comparison f{attribute.get(\"comparison\")}')",
        "detail": "src.utils.plutilities",
        "documentation": {}
    },
    {
        "label": "pl_multiple_choice",
        "kind": 2,
        "importPath": "src.utils.plutilities",
        "description": "src.utils.plutilities",
        "peekOfCode": "def pl_multiple_choice(soup, tag_name, data):\n    if not isinstance(soup, BeautifulSoup):\n        raise TypeError(\"The 'soup' argument must be a BeautifulSoup object.\")\n    # Find all old tags that match the provided tag name\n    old_tags = soup.find_all(tag_name)\n    for old_tag in old_tags:\n        attributes = old_tag.attrs\n        name = attributes.get(\"answers-name\", \"\")\n        choices = old_tag.find_all(\"choice\", recursive=False)\n        indices = list(range(len(choices)))",
        "detail": "src.utils.plutilities",
        "documentation": {}
    },
    {
        "label": "wrap_input_fields_form",
        "kind": 2,
        "importPath": "src.utils.plutilities",
        "description": "src.utils.plutilities",
        "peekOfCode": "def wrap_input_fields_form(soup):\n    \"\"\"\n    Wraps all <input> fields in the given BeautifulSoup object within a <form> tag,\n    and adds a submit button at the end.\n    Args:\n        soup (BeautifulSoup): A BeautifulSoup object containing the HTML to modify.\n    Returns:\n        BeautifulSoup: The modified BeautifulSoup object with input fields wrapped in a form tag.\n    Raises:\n        TypeError: If the 'soup' argument is not a BeautifulSoup object.",
        "detail": "src.utils.plutilities",
        "documentation": {}
    },
    {
        "label": "wrap_inputs_with_fieldset",
        "kind": 2,
        "importPath": "src.utils.plutilities",
        "description": "src.utils.plutilities",
        "peekOfCode": "def wrap_inputs_with_fieldset(soup, name, class_):\n    \"\"\"\n    Wraps each <input> field with class 'response' in a <fieldset> tag and its corresponding hidden input.\n    Also adds a <label> for each input.\n    Args:\n        soup (BeautifulSoup): A BeautifulSoup object containing the HTML to modify.\n    Returns:\n        BeautifulSoup: The modified BeautifulSoup object with input fields wrapped in a fieldset tag.\n    Raises:\n        TypeError: If the 'soup' argument is not a BeautifulSoup object.",
        "detail": "src.utils.plutilities",
        "documentation": {}
    },
    {
        "label": "pl_question_panel",
        "kind": 2,
        "importPath": "src.utils.plutilities",
        "description": "src.utils.plutilities",
        "peekOfCode": "def pl_question_panel(soup):\n    \"\"\"\n    Wraps the contents of the <pl-question-panel> tag with a <div> element that has the class \"question-panel-wrapper\".\n    Args:\n        soup (BeautifulSoup): A BeautifulSoup object containing the HTML to modify.\n    Returns:\n        BeautifulSoup: The modified BeautifulSoup object.\n    Raises:\n        TypeError: If the 'soup' argument is not a BeautifulSoup object.\n    \"\"\"",
        "detail": "src.utils.plutilities",
        "documentation": {}
    },
    {
        "label": "pl_figure",
        "kind": 2,
        "importPath": "src.utils.plutilities",
        "description": "src.utils.plutilities",
        "peekOfCode": "def pl_figure(soup, qname):\n    \"\"\"\n    Creates an <img> tag with attributes derived from the provided tag and question name.\n    Args:\n        tag (BeautifulSoup.Tag): A BeautifulSoup tag containing attributes.\n        qname (str): The question name to construct the image file path.\n    Returns:\n        BeautifulSoup.Tag: The newly created <img> tag.\n    \"\"\"\n    if not isinstance(soup, BeautifulSoup):",
        "detail": "src.utils.plutilities",
        "documentation": {}
    },
    {
        "label": "process_prairielearn_html",
        "kind": 2,
        "importPath": "src.utils.plutilities",
        "description": "src.utils.plutilities",
        "peekOfCode": "def process_prairielearn_html(question_html: str, solution_html: str, qdata: dict, qname: str):\n    \"\"\"\n    Processes the PrairieLearn HTML by wrapping inputs, adding fieldsets and labels, changing question panels,\n    and adding images.\n    Args:\n        question_html (str): The input HTML string for the question.\n        solution_html (str): The input HTML string for the solution.\n        qdata (dict): The dictionary containing the question data and additional data for template rendering.\n        qname (str): The question name to construct the image file path.\n    Returns:",
        "detail": "src.utils.plutilities",
        "documentation": {}
    },
    {
        "label": "escape_jinja_in_latex",
        "kind": 2,
        "importPath": "src.utils.plutilities",
        "description": "src.utils.plutilities",
        "peekOfCode": "def escape_jinja_in_latex(template: str) -> str:\n    \"\"\"\n    Escapes Jinja2 curly braces within LaTeX math mode in an HTML template.\n    Args:\n        template (str): The HTML template string containing Jinja2 and LaTeX code.\n    Returns:\n        str: The modified template with Jinja2 expressions properly escaped within LaTeX math mode.\n    \"\"\"\n    # Regex to find Jinja2 expressions within LaTeX math mode (\\(...\\) or \\[...\\])\n    pattern = r'\\\\\\((.*?)\\\\\\)|\\\\\\[(.*?)\\\\\\]'",
        "detail": "src.utils.plutilities",
        "documentation": {}
    },
    {
        "label": "file_exist",
        "kind": 2,
        "importPath": "src.utils.run_modules",
        "description": "src.utils.run_modules",
        "peekOfCode": "def file_exist(file_path:str)->bool:\n    return os.path.exists(file_path)\ndef read_file(file_path:str):\n    file_exist(file_path)\n    with open(file_path,\"r\") as file:\n        return file.read()\ndef import_module_from_path(path:str):\n    # We are looking for the generate module in the python file\n    spec = importlib.util.spec_from_file_location(\"generate\",path)\n    # Load the module",
        "detail": "src.utils.run_modules",
        "documentation": {}
    },
    {
        "label": "read_file",
        "kind": 2,
        "importPath": "src.utils.run_modules",
        "description": "src.utils.run_modules",
        "peekOfCode": "def read_file(file_path:str):\n    file_exist(file_path)\n    with open(file_path,\"r\") as file:\n        return file.read()\ndef import_module_from_path(path:str):\n    # We are looking for the generate module in the python file\n    spec = importlib.util.spec_from_file_location(\"generate\",path)\n    # Load the module\n    module = importlib.util.module_from_spec(spec)  \n    # Execute the moduel to make attribute accessible",
        "detail": "src.utils.run_modules",
        "documentation": {}
    },
    {
        "label": "import_module_from_path",
        "kind": 2,
        "importPath": "src.utils.run_modules",
        "description": "src.utils.run_modules",
        "peekOfCode": "def import_module_from_path(path:str):\n    # We are looking for the generate module in the python file\n    spec = importlib.util.spec_from_file_location(\"generate\",path)\n    # Load the module\n    module = importlib.util.module_from_spec(spec)  \n    # Execute the moduel to make attribute accessible\n    spec.loader.exec_module(module)\n    # Return the imported module\n    return module\ndef run_generate_py(path_server_py:str):",
        "detail": "src.utils.run_modules",
        "documentation": {}
    },
    {
        "label": "run_generate_py",
        "kind": 2,
        "importPath": "src.utils.run_modules",
        "description": "src.utils.run_modules",
        "peekOfCode": "def run_generate_py(path_server_py:str):\n    \"\"\"Run the server.py module\n    Args:\n        path_server_py (str): path to server.py file\n    Returns:\n        module.generate(): Should be a dictionary containing valus, not sure need to check\n    \"\"\"\n    module = import_module_from_path(path_server_py)\n    return module.generate()\ndef run_generate_js(path):",
        "detail": "src.utils.run_modules",
        "documentation": {}
    },
    {
        "label": "run_generate_js",
        "kind": 2,
        "importPath": "src.utils.run_modules",
        "description": "src.utils.run_modules",
        "peekOfCode": "def run_generate_js(path):\n    with open(path, 'r') as file:\n        js_code = file.read()\n    context = execjs.compile(js_code)\n    return context.call(\"generate\")\ndef run_generate(path:str):\n    generators = {\n        \"server.js\": run_generate_js,\n        \"server.py\": run_generate_py\n    }",
        "detail": "src.utils.run_modules",
        "documentation": {}
    },
    {
        "label": "run_generate",
        "kind": 2,
        "importPath": "src.utils.run_modules",
        "description": "src.utils.run_modules",
        "peekOfCode": "def run_generate(path:str):\n    generators = {\n        \"server.js\": run_generate_js,\n        \"server.py\": run_generate_py\n    }\n    if not os.path.isfile(path):\n        return ({\"error\": \"File not found\"}), 404\n    base_name = os.path.basename(path)\n    try:\n        if base_name in generators.keys():",
        "detail": "src.utils.run_modules",
        "documentation": {}
    },
    {
        "label": "generateAdaptive",
        "kind": 2,
        "importPath": "src.utils.run_modules",
        "description": "src.utils.run_modules",
        "peekOfCode": "def generateAdaptive(quiz_path:str,code_lang:str=\"python\"):\n    files_to_check = [\"question.html\", \"server.js\",\"server.py\",\"info.json\",\"solution.html\"]\n    valid_files = {file:os.path.join(quiz_path, file) for file in files_to_check if file_exist(os.path.join(quiz_path, file))}\n    print(valid_files)\n    quiz_name = os.path.basename(quiz_path)\n    server_file = None\n    if code_lang.lower()==\"python\":\n        server_file = valid_files.get(\"server.py\")\n    elif code_lang.lower() == \"javascript\":\n        server_file = valid_files.get(\"server.js\")",
        "detail": "src.utils.run_modules",
        "documentation": {}
    },
    {
        "label": "double_curly_brackets",
        "kind": 2,
        "importPath": "src.utils.string_parser",
        "description": "src.utils.string_parser",
        "peekOfCode": "def double_curly_brackets(text):\n    text = re.sub(r\"{\", \"{{\",text)\n    text = re.sub(r\"}\", \"}}\",text)\n    return text\ndef extract_code_block(text, language):\n    pattern = re.compile(rf'```{language}\\n(.*?)\\n```', re.DOTALL)\n    matches = pattern.findall(text)\n    return matches[0]\ndef extract_triple_quotes(text:str)->str:\n    pattern = re.compile(r'```.*?\\n(.*?)\\n```', re.DOTALL)",
        "detail": "src.utils.string_parser",
        "documentation": {}
    },
    {
        "label": "extract_code_block",
        "kind": 2,
        "importPath": "src.utils.string_parser",
        "description": "src.utils.string_parser",
        "peekOfCode": "def extract_code_block(text, language):\n    pattern = re.compile(rf'```{language}\\n(.*?)\\n```', re.DOTALL)\n    matches = pattern.findall(text)\n    return matches[0]\ndef extract_triple_quotes(text:str)->str:\n    pattern = re.compile(r'```.*?\\n(.*?)\\n```', re.DOTALL)\n    matches = pattern.findall(text)\n    for match in matches:\n        if match:\n            return match",
        "detail": "src.utils.string_parser",
        "documentation": {}
    },
    {
        "label": "extract_triple_quotes",
        "kind": 2,
        "importPath": "src.utils.string_parser",
        "description": "src.utils.string_parser",
        "peekOfCode": "def extract_triple_quotes(text:str)->str:\n    pattern = re.compile(r'```.*?\\n(.*?)\\n```', re.DOTALL)\n    matches = pattern.findall(text)\n    for match in matches:\n        if match:\n            return match",
        "detail": "src.utils.string_parser",
        "documentation": {}
    },
    {
        "label": "api_key",
        "kind": 5,
        "importPath": "src.credentials",
        "description": "src.credentials",
        "peekOfCode": "api_key = os.environ.get('OPENAI_API_KEY')\nif not api_key:\n    raise ValueError(\"No API key found. Set the API_KEY environment variable.\")",
        "detail": "src.credentials",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "app = create_app()\n#Checks if the run.py file has executed directly and not imported\nif __name__ == '__main__':\n    print(\" Starting app...\")\n    app.run(debug=True)",
        "detail": "main",
        "documentation": {}
    }
]