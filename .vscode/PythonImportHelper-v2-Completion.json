[
    {
        "label": "typing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "typing",
        "description": "typing",
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Never",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "overload",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Deque",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "SQLAlchemy",
        "importPath": "flask_sqlalchemy",
        "description": "flask_sqlalchemy",
        "isExtraImport": true,
        "detail": "flask_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "UserMixin",
        "importPath": "flask_login",
        "description": "flask_login",
        "isExtraImport": true,
        "detail": "flask_login",
        "documentation": {}
    },
    {
        "label": "login_user",
        "importPath": "flask_login",
        "description": "flask_login",
        "isExtraImport": true,
        "detail": "flask_login",
        "documentation": {}
    },
    {
        "label": "login_required",
        "importPath": "flask_login",
        "description": "flask_login",
        "isExtraImport": true,
        "detail": "flask_login",
        "documentation": {}
    },
    {
        "label": "logout_user",
        "importPath": "flask_login",
        "description": "flask_login",
        "isExtraImport": true,
        "detail": "flask_login",
        "documentation": {}
    },
    {
        "label": "generate_password_hash",
        "importPath": "werkzeug.security",
        "description": "werkzeug.security",
        "isExtraImport": true,
        "detail": "werkzeug.security",
        "documentation": {}
    },
    {
        "label": "check_password_hash",
        "importPath": "werkzeug.security",
        "description": "werkzeug.security",
        "isExtraImport": true,
        "detail": "werkzeug.security",
        "documentation": {}
    },
    {
        "label": "Column",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Integer",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "String",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "ForeignKey",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "relationship",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Mapped",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "mapped_column",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "RelationshipProperty",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "current_app",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Blueprint",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "session",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "redirect",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "url_for",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "flash",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Blueprint",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "session",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "redirect",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "url_for",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "flash",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Blueprint",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "session",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "redirect",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "url_for",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "flash",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Blueprint",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "redirect",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "url_for",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "flash",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Blueprint",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Blueprint",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "session",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "redirect",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "url_for",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "flash",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Blueprint",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "session",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "redirect",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "url_for",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "flash",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Blueprint",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "session",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "redirect",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "url_for",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "flash",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Blueprint",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "session",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "redirect",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "url_for",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "flash",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Blueprint",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "send_file",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "session",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "redirect",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "url_for",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Response",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "flash",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "session",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "session",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "url_for",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask.app",
        "description": "flask.app",
        "isExtraImport": true,
        "detail": "flask.app",
        "documentation": {}
    },
    {
        "label": "FlaskForm",
        "importPath": "flask_wtf",
        "description": "flask_wtf",
        "isExtraImport": true,
        "detail": "flask_wtf",
        "documentation": {}
    },
    {
        "label": "PasswordField",
        "importPath": "wtforms",
        "description": "wtforms",
        "isExtraImport": true,
        "detail": "wtforms",
        "documentation": {}
    },
    {
        "label": "StringField",
        "importPath": "wtforms",
        "description": "wtforms",
        "isExtraImport": true,
        "detail": "wtforms",
        "documentation": {}
    },
    {
        "label": "SubmitField",
        "importPath": "wtforms",
        "description": "wtforms",
        "isExtraImport": true,
        "detail": "wtforms",
        "documentation": {}
    },
    {
        "label": "BooleanField",
        "importPath": "wtforms",
        "description": "wtforms",
        "isExtraImport": true,
        "detail": "wtforms",
        "documentation": {}
    },
    {
        "label": "TextAreaField",
        "importPath": "wtforms",
        "description": "wtforms",
        "isExtraImport": true,
        "detail": "wtforms",
        "documentation": {}
    },
    {
        "label": "PasswordField",
        "importPath": "wtforms",
        "description": "wtforms",
        "isExtraImport": true,
        "detail": "wtforms",
        "documentation": {}
    },
    {
        "label": "StringField",
        "importPath": "wtforms",
        "description": "wtforms",
        "isExtraImport": true,
        "detail": "wtforms",
        "documentation": {}
    },
    {
        "label": "SubmitField",
        "importPath": "wtforms",
        "description": "wtforms",
        "isExtraImport": true,
        "detail": "wtforms",
        "documentation": {}
    },
    {
        "label": "BooleanField",
        "importPath": "wtforms",
        "description": "wtforms",
        "isExtraImport": true,
        "detail": "wtforms",
        "documentation": {}
    },
    {
        "label": "TextAreaField",
        "importPath": "wtforms",
        "description": "wtforms",
        "isExtraImport": true,
        "detail": "wtforms",
        "documentation": {}
    },
    {
        "label": "ValidationError",
        "importPath": "wtforms",
        "description": "wtforms",
        "isExtraImport": true,
        "detail": "wtforms",
        "documentation": {}
    },
    {
        "label": "MultipleFileField",
        "importPath": "flask_wtf.file",
        "description": "flask_wtf.file",
        "isExtraImport": true,
        "detail": "flask_wtf.file",
        "documentation": {}
    },
    {
        "label": "FileRequired",
        "importPath": "flask_wtf.file",
        "description": "flask_wtf.file",
        "isExtraImport": true,
        "detail": "flask_wtf.file",
        "documentation": {}
    },
    {
        "label": "FileField",
        "importPath": "flask_wtf.file",
        "description": "flask_wtf.file",
        "isExtraImport": true,
        "detail": "flask_wtf.file",
        "documentation": {}
    },
    {
        "label": "DataRequired",
        "importPath": "wtforms.validators",
        "description": "wtforms.validators",
        "isExtraImport": true,
        "detail": "wtforms.validators",
        "documentation": {}
    },
    {
        "label": "Length",
        "importPath": "wtforms.validators",
        "description": "wtforms.validators",
        "isExtraImport": true,
        "detail": "wtforms.validators",
        "documentation": {}
    },
    {
        "label": "Email",
        "importPath": "wtforms.validators",
        "description": "wtforms.validators",
        "isExtraImport": true,
        "detail": "wtforms.validators",
        "documentation": {}
    },
    {
        "label": "EqualTo",
        "importPath": "wtforms.validators",
        "description": "wtforms.validators",
        "isExtraImport": true,
        "detail": "wtforms.validators",
        "documentation": {}
    },
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "secure_filename",
        "importPath": "werkzeug.utils",
        "description": "werkzeug.utils",
        "isExtraImport": true,
        "detail": "werkzeug.utils",
        "documentation": {}
    },
    {
        "label": "secure_filename",
        "importPath": "werkzeug.utils",
        "description": "werkzeug.utils",
        "isExtraImport": true,
        "detail": "werkzeug.utils",
        "documentation": {}
    },
    {
        "label": "generate_from_image",
        "importPath": "src.llm_content_assembly.assembly",
        "description": "src.llm_content_assembly.assembly",
        "isExtraImport": true,
        "detail": "src.llm_content_assembly.assembly",
        "documentation": {}
    },
    {
        "label": "lecture_assembly",
        "importPath": "src.llm_content_assembly.assembly",
        "description": "src.llm_content_assembly.assembly",
        "isExtraImport": true,
        "detail": "src.llm_content_assembly.assembly",
        "documentation": {}
    },
    {
        "label": "lecture_assembly_simple",
        "importPath": "src.llm_content_assembly.assembly",
        "description": "src.llm_content_assembly.assembly",
        "isExtraImport": true,
        "detail": "src.llm_content_assembly.assembly",
        "documentation": {}
    },
    {
        "label": "generate_module_text",
        "importPath": "src.llm_content_assembly.assembly",
        "description": "src.llm_content_assembly.assembly",
        "isExtraImport": true,
        "detail": "src.llm_content_assembly.assembly",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "src.logging_config.logging_config",
        "description": "src.logging_config.logging_config",
        "isExtraImport": true,
        "detail": "src.logging_config.logging_config",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "src.logging_config.logging_config",
        "description": "src.logging_config.logging_config",
        "isExtraImport": true,
        "detail": "src.logging_config.logging_config",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "src.logging_config.logging_config",
        "description": "src.logging_config.logging_config",
        "isExtraImport": true,
        "detail": "src.logging_config.logging_config",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "src.logging_config.logging_config",
        "description": "src.logging_config.logging_config",
        "isExtraImport": true,
        "detail": "src.logging_config.logging_config",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "src.logging_config.logging_config",
        "description": "src.logging_config.logging_config",
        "isExtraImport": true,
        "detail": "src.logging_config.logging_config",
        "documentation": {}
    },
    {
        "label": "le",
        "importPath": "operator",
        "description": "operator",
        "isExtraImport": true,
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "sub",
        "importPath": "operator",
        "description": "operator",
        "isExtraImport": true,
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "uuid",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "uuid",
        "description": "uuid",
        "detail": "uuid",
        "documentation": {}
    },
    {
        "label": "ast",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ast",
        "description": "ast",
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "literal_eval",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "literal_eval",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "literal_eval",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "literal_eval",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "literal_eval",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "generateAdaptive",
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "isExtraImport": true,
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "run_generate_py",
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "isExtraImport": true,
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "run_generate",
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "isExtraImport": true,
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "read_file",
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "isExtraImport": true,
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "generateAdaptive",
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "isExtraImport": true,
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "run_generate_py",
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "isExtraImport": true,
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "run_generate",
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "isExtraImport": true,
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "read_file",
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "isExtraImport": true,
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "generateAdaptive",
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "isExtraImport": true,
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "run_generate_py",
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "isExtraImport": true,
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "run_generate",
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "isExtraImport": true,
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "read_file",
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "isExtraImport": true,
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "generateAdaptive",
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "isExtraImport": true,
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "run_generate_py",
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "isExtraImport": true,
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "run_generate",
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "isExtraImport": true,
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "read_file",
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "isExtraImport": true,
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "process_prairielearn_html",
        "importPath": "src.utils.plutilities",
        "description": "src.utils.plutilities",
        "isExtraImport": true,
        "detail": "src.utils.plutilities",
        "documentation": {}
    },
    {
        "label": "process_prairielearn_html",
        "importPath": "src.utils.plutilities",
        "description": "src.utils.plutilities",
        "isExtraImport": true,
        "detail": "src.utils.plutilities",
        "documentation": {}
    },
    {
        "label": "process_prairielearn_html",
        "importPath": "src.utils.plutilities",
        "description": "src.utils.plutilities",
        "isExtraImport": true,
        "detail": "src.utils.plutilities",
        "documentation": {}
    },
    {
        "label": "process_prairielearn_html",
        "importPath": "src.utils.plutilities",
        "description": "src.utils.plutilities",
        "isExtraImport": true,
        "detail": "src.utils.plutilities",
        "documentation": {}
    },
    {
        "label": "process_prairielearn_html",
        "importPath": "src.utils.plutilities",
        "description": "src.utils.plutilities",
        "isExtraImport": true,
        "detail": "src.utils.plutilities",
        "documentation": {}
    },
    {
        "label": "traceback",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "traceback",
        "description": "traceback",
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "format_question_html",
        "importPath": "src.process_prairielearn.process_prairielearn",
        "description": "src.process_prairielearn.process_prairielearn",
        "isExtraImport": true,
        "detail": "src.process_prairielearn.process_prairielearn",
        "documentation": {}
    },
    {
        "label": "format_question_html",
        "importPath": "src.process_prairielearn.process_prairielearn",
        "description": "src.process_prairielearn.process_prairielearn",
        "isExtraImport": true,
        "detail": "src.process_prairielearn.process_prairielearn",
        "documentation": {}
    },
    {
        "label": "prairielearn",
        "importPath": "src.prairielearn.python",
        "description": "src.prairielearn.python",
        "isExtraImport": true,
        "detail": "src.prairielearn.python",
        "documentation": {}
    },
    {
        "label": "prairielearn",
        "importPath": "src.prairielearn.python",
        "description": "src.prairielearn.python",
        "isExtraImport": true,
        "detail": "src.prairielearn.python",
        "documentation": {}
    },
    {
        "label": "prairielearn",
        "importPath": "src.prairielearn.python",
        "description": "src.prairielearn.python",
        "isExtraImport": true,
        "detail": "src.prairielearn.python",
        "documentation": {}
    },
    {
        "label": "prairielearn",
        "importPath": "src.prairielearn.python",
        "description": "src.prairielearn.python",
        "isExtraImport": true,
        "detail": "src.prairielearn.python",
        "documentation": {}
    },
    {
        "label": "zipfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "zipfile",
        "description": "zipfile",
        "detail": "zipfile",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "create_zip_file",
        "importPath": "src.utils.file_handler",
        "description": "src.utils.file_handler",
        "isExtraImport": true,
        "detail": "src.utils.file_handler",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "api_key",
        "importPath": "src.credentials",
        "description": "src.credentials",
        "isExtraImport": true,
        "detail": "src.credentials",
        "documentation": {}
    },
    {
        "label": "api_key",
        "importPath": "src.credentials",
        "description": "src.credentials",
        "isExtraImport": true,
        "detail": "src.credentials",
        "documentation": {}
    },
    {
        "label": "GenerateEmbeddings",
        "importPath": "src.data_handler.generate_embeddings",
        "description": "src.data_handler.generate_embeddings",
        "isExtraImport": true,
        "detail": "src.data_handler.generate_embeddings",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "openai",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "openai",
        "description": "openai",
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "OpenAI",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "OpenAI",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "AsyncOpenAI",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "AsyncOpenAI",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "AsyncOpenAI",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "imag",
        "importPath": "numpy",
        "description": "numpy",
        "isExtraImport": true,
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "mean",
        "importPath": "numpy",
        "description": "numpy",
        "isExtraImport": true,
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "csv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "csv",
        "description": "csv",
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "fitz",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "fitz",
        "description": "fitz",
        "detail": "fitz",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "src.logging_config",
        "description": "src.logging_config",
        "isExtraImport": true,
        "detail": "src.logging_config",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "convert_from_path",
        "importPath": "pdf2image",
        "description": "pdf2image",
        "isExtraImport": true,
        "detail": "pdf2image",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "field_validator",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "validator",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "field_validator",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "validator",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "aiohttp",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "aiohttp",
        "description": "aiohttp",
        "detail": "aiohttp",
        "documentation": {}
    },
    {
        "label": "base64",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "base64",
        "description": "base64",
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "OpenAIEmbeddings",
        "importPath": "langchain_openai",
        "description": "langchain_openai",
        "isExtraImport": true,
        "detail": "langchain_openai",
        "documentation": {}
    },
    {
        "label": "ChatOpenAI",
        "importPath": "langchain_openai",
        "description": "langchain_openai",
        "isExtraImport": true,
        "detail": "langchain_openai",
        "documentation": {}
    },
    {
        "label": "OpenAIEmbeddings",
        "importPath": "langchain_openai",
        "description": "langchain_openai",
        "isExtraImport": true,
        "detail": "langchain_openai",
        "documentation": {}
    },
    {
        "label": "OpenAIEmbeddings",
        "importPath": "langchain_openai",
        "description": "langchain_openai",
        "isExtraImport": true,
        "detail": "langchain_openai",
        "documentation": {}
    },
    {
        "label": "ChatOpenAI",
        "importPath": "langchain_openai",
        "description": "langchain_openai",
        "isExtraImport": true,
        "detail": "langchain_openai",
        "documentation": {}
    },
    {
        "label": "OpenAIEmbeddings",
        "importPath": "langchain_openai",
        "description": "langchain_openai",
        "isExtraImport": true,
        "detail": "langchain_openai",
        "documentation": {}
    },
    {
        "label": "OpenAIEmbeddings",
        "importPath": "langchain_openai",
        "description": "langchain_openai",
        "isExtraImport": true,
        "detail": "langchain_openai",
        "documentation": {}
    },
    {
        "label": "Chroma",
        "importPath": "langchain_chroma",
        "description": "langchain_chroma",
        "isExtraImport": true,
        "detail": "langchain_chroma",
        "documentation": {}
    },
    {
        "label": "Chroma",
        "importPath": "langchain_chroma",
        "description": "langchain_chroma",
        "isExtraImport": true,
        "detail": "langchain_chroma",
        "documentation": {}
    },
    {
        "label": "Chroma",
        "importPath": "langchain_chroma",
        "description": "langchain_chroma",
        "isExtraImport": true,
        "detail": "langchain_chroma",
        "documentation": {}
    },
    {
        "label": "Chroma",
        "importPath": "langchain_chroma",
        "description": "langchain_chroma",
        "isExtraImport": true,
        "detail": "langchain_chroma",
        "documentation": {}
    },
    {
        "label": "Chroma",
        "importPath": "langchain_chroma",
        "description": "langchain_chroma",
        "isExtraImport": true,
        "detail": "langchain_chroma",
        "documentation": {}
    },
    {
        "label": "MultiQueryRetriever",
        "importPath": "langchain.retrievers.multi_query",
        "description": "langchain.retrievers.multi_query",
        "isExtraImport": true,
        "detail": "langchain.retrievers.multi_query",
        "documentation": {}
    },
    {
        "label": "MultiQueryRetriever",
        "importPath": "langchain.retrievers.multi_query",
        "description": "langchain.retrievers.multi_query",
        "isExtraImport": true,
        "detail": "langchain.retrievers.multi_query",
        "documentation": {}
    },
    {
        "label": "create_retrieval_chain",
        "importPath": "langchain.chains",
        "description": "langchain.chains",
        "isExtraImport": true,
        "detail": "langchain.chains",
        "documentation": {}
    },
    {
        "label": "create_retrieval_chain",
        "importPath": "langchain.chains",
        "description": "langchain.chains",
        "isExtraImport": true,
        "detail": "langchain.chains",
        "documentation": {}
    },
    {
        "label": "create_stuff_documents_chain",
        "importPath": "langchain.chains.combine_documents",
        "description": "langchain.chains.combine_documents",
        "isExtraImport": true,
        "detail": "langchain.chains.combine_documents",
        "documentation": {}
    },
    {
        "label": "create_stuff_documents_chain",
        "importPath": "langchain.chains.combine_documents",
        "description": "langchain.chains.combine_documents",
        "isExtraImport": true,
        "detail": "langchain.chains.combine_documents",
        "documentation": {}
    },
    {
        "label": "ChatPromptTemplate",
        "importPath": "langchain_core.prompts",
        "description": "langchain_core.prompts",
        "isExtraImport": true,
        "detail": "langchain_core.prompts",
        "documentation": {}
    },
    {
        "label": "ChatPromptTemplate",
        "importPath": "langchain_core.prompts",
        "description": "langchain_core.prompts",
        "isExtraImport": true,
        "detail": "langchain_core.prompts",
        "documentation": {}
    },
    {
        "label": "RunnablePassthrough",
        "importPath": "langchain_core.runnables",
        "description": "langchain_core.runnables",
        "isExtraImport": true,
        "detail": "langchain_core.runnables",
        "documentation": {}
    },
    {
        "label": "RunnablePassthrough",
        "importPath": "langchain_core.runnables",
        "description": "langchain_core.runnables",
        "isExtraImport": true,
        "detail": "langchain_core.runnables",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "bs4",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "bs4",
        "description": "bs4",
        "detail": "bs4",
        "documentation": {}
    },
    {
        "label": "BeautifulSoup",
        "importPath": "bs4",
        "description": "bs4",
        "isExtraImport": true,
        "detail": "bs4",
        "documentation": {}
    },
    {
        "label": "BeautifulSoup",
        "importPath": "bs4",
        "description": "bs4",
        "isExtraImport": true,
        "detail": "bs4",
        "documentation": {}
    },
    {
        "label": "BeautifulSoup",
        "importPath": "bs4",
        "description": "bs4",
        "isExtraImport": true,
        "detail": "bs4",
        "documentation": {}
    },
    {
        "label": "BeautifulSoup",
        "importPath": "bs4",
        "description": "bs4",
        "isExtraImport": true,
        "detail": "bs4",
        "documentation": {}
    },
    {
        "label": "BeautifulSoup",
        "importPath": "bs4",
        "description": "bs4",
        "isExtraImport": true,
        "detail": "bs4",
        "documentation": {}
    },
    {
        "label": "BeautifulSoup",
        "importPath": "bs4",
        "description": "bs4",
        "isExtraImport": true,
        "detail": "bs4",
        "documentation": {}
    },
    {
        "label": "Tag",
        "importPath": "bs4",
        "description": "bs4",
        "isExtraImport": true,
        "detail": "bs4",
        "documentation": {}
    },
    {
        "label": "BeautifulSoup",
        "importPath": "bs4",
        "description": "bs4",
        "isExtraImport": true,
        "detail": "bs4",
        "documentation": {}
    },
    {
        "label": "BeautifulSoup",
        "importPath": "bs4",
        "description": "bs4",
        "isExtraImport": true,
        "detail": "bs4",
        "documentation": {}
    },
    {
        "label": "urljoin",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "urljoin",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "urljoin",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "urljoin",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "HTMLHeaderTextSplitter",
        "importPath": "langchain_text_splitters",
        "description": "langchain_text_splitters",
        "isExtraImport": true,
        "detail": "langchain_text_splitters",
        "documentation": {}
    },
    {
        "label": "HTMLSectionSplitter",
        "importPath": "langchain_text_splitters",
        "description": "langchain_text_splitters",
        "isExtraImport": true,
        "detail": "langchain_text_splitters",
        "documentation": {}
    },
    {
        "label": "HTMLHeaderTextSplitter",
        "importPath": "langchain_text_splitters",
        "description": "langchain_text_splitters",
        "isExtraImport": true,
        "detail": "langchain_text_splitters",
        "documentation": {}
    },
    {
        "label": "HTMLSectionSplitter",
        "importPath": "langchain_text_splitters",
        "description": "langchain_text_splitters",
        "isExtraImport": true,
        "detail": "langchain_text_splitters",
        "documentation": {}
    },
    {
        "label": "HTMLHeaderTextSplitter",
        "importPath": "langchain_text_splitters",
        "description": "langchain_text_splitters",
        "isExtraImport": true,
        "detail": "langchain_text_splitters",
        "documentation": {}
    },
    {
        "label": "HTMLSectionSplitter",
        "importPath": "langchain_text_splitters",
        "description": "langchain_text_splitters",
        "isExtraImport": true,
        "detail": "langchain_text_splitters",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "venv",
        "description": "venv",
        "isExtraImport": true,
        "detail": "venv",
        "documentation": {}
    },
    {
        "label": "LLMConfig",
        "importPath": "src.llm_module_generator.llm_base",
        "description": "src.llm_module_generator.llm_base",
        "isExtraImport": true,
        "detail": "src.llm_module_generator.llm_base",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "token",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "token",
        "description": "token",
        "detail": "token",
        "documentation": {}
    },
    {
        "label": "llm",
        "importPath": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "description": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "isExtraImport": true,
        "detail": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "lxml.html",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "lxml.html",
        "description": "lxml.html",
        "detail": "lxml.html",
        "documentation": {}
    },
    {
        "label": "HtmlElement",
        "importPath": "lxml.html",
        "description": "lxml.html",
        "isExtraImport": true,
        "detail": "lxml.html",
        "documentation": {}
    },
    {
        "label": "python_helper_sympy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "python_helper_sympy",
        "description": "python_helper_sympy",
        "detail": "python_helper_sympy",
        "documentation": {}
    },
    {
        "label": "sympy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sympy",
        "description": "sympy",
        "detail": "sympy",
        "documentation": {}
    },
    {
        "label": "big_o_utils",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "big_o_utils",
        "description": "big_o_utils",
        "detail": "big_o_utils",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "choice",
        "importPath": "random",
        "description": "random",
        "isExtraImport": true,
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "chevron",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "chevron",
        "description": "chevron",
        "detail": "chevron",
        "documentation": {}
    },
    {
        "label": "prairielearn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "prairielearn",
        "description": "prairielearn",
        "detail": "prairielearn",
        "documentation": {}
    },
    {
        "label": "QuestionData",
        "importPath": "prairielearn",
        "description": "prairielearn",
        "isExtraImport": true,
        "detail": "prairielearn",
        "documentation": {}
    },
    {
        "label": "assert_never",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "assert_never",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "assert_never",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "assert_never",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "assert_never",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "assert_never",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "assert_never",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "assert_never",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "NotRequired",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "assert_never",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "assert_never",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "assert_never",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "assert_never",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "assert_never",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "NotRequired",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "assert_never",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "NotRequired",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "assert_never",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "prairielearn",
        "importPath": "prairielearn.python",
        "description": "prairielearn.python",
        "isExtraImport": true,
        "detail": "prairielearn.python",
        "documentation": {}
    },
    {
        "label": "prairielearn",
        "importPath": "prairielearn.python",
        "description": "prairielearn.python",
        "isExtraImport": true,
        "detail": "prairielearn.python",
        "documentation": {}
    },
    {
        "label": "prairielearn",
        "importPath": "prairielearn.python",
        "description": "prairielearn.python",
        "isExtraImport": true,
        "detail": "prairielearn.python",
        "documentation": {}
    },
    {
        "label": "prairielearn",
        "importPath": "prairielearn.python",
        "description": "prairielearn.python",
        "isExtraImport": true,
        "detail": "prairielearn.python",
        "documentation": {}
    },
    {
        "label": "prairielearn",
        "importPath": "prairielearn.python",
        "description": "prairielearn.python",
        "isExtraImport": true,
        "detail": "prairielearn.python",
        "documentation": {}
    },
    {
        "label": "prairielearn",
        "importPath": "prairielearn.python",
        "description": "prairielearn.python",
        "isExtraImport": true,
        "detail": "prairielearn.python",
        "documentation": {}
    },
    {
        "label": "prairielearn",
        "importPath": "prairielearn.python",
        "description": "prairielearn.python",
        "isExtraImport": true,
        "detail": "prairielearn.python",
        "documentation": {}
    },
    {
        "label": "prairielearn",
        "importPath": "prairielearn.python",
        "description": "prairielearn.python",
        "isExtraImport": true,
        "detail": "prairielearn.python",
        "documentation": {}
    },
    {
        "label": "prairielearn",
        "importPath": "prairielearn.python",
        "description": "prairielearn.python",
        "isExtraImport": true,
        "detail": "prairielearn.python",
        "documentation": {}
    },
    {
        "label": "prairielearn",
        "importPath": "prairielearn.python",
        "description": "prairielearn.python",
        "isExtraImport": true,
        "detail": "prairielearn.python",
        "documentation": {}
    },
    {
        "label": "prairielearn",
        "importPath": "prairielearn.python",
        "description": "prairielearn.python",
        "isExtraImport": true,
        "detail": "prairielearn.python",
        "documentation": {}
    },
    {
        "label": "prairielearn",
        "importPath": "prairielearn.python",
        "description": "prairielearn.python",
        "isExtraImport": true,
        "detail": "prairielearn.python",
        "documentation": {}
    },
    {
        "label": "prairielearn",
        "importPath": "prairielearn.python",
        "description": "prairielearn.python",
        "isExtraImport": true,
        "detail": "prairielearn.python",
        "documentation": {}
    },
    {
        "label": "python_helper_sympy",
        "importPath": "prairielearn.python",
        "description": "prairielearn.python",
        "isExtraImport": true,
        "detail": "prairielearn.python",
        "documentation": {}
    },
    {
        "label": "prairielearn",
        "importPath": "prairielearn.python",
        "description": "prairielearn.python",
        "isExtraImport": true,
        "detail": "prairielearn.python",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "parse_highlight_lines",
        "importPath": "code_utils",
        "description": "code_utils",
        "isExtraImport": true,
        "detail": "code_utils",
        "documentation": {}
    },
    {
        "label": "parse_highlight_lines",
        "importPath": "code_utils",
        "description": "code_utils",
        "isExtraImport": true,
        "detail": "code_utils",
        "documentation": {}
    },
    {
        "label": "html",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "html",
        "description": "html",
        "detail": "html",
        "documentation": {}
    },
    {
        "label": "escape",
        "importPath": "html",
        "description": "html",
        "isExtraImport": true,
        "detail": "html",
        "documentation": {}
    },
    {
        "label": "unescape",
        "importPath": "html",
        "description": "html",
        "isExtraImport": true,
        "detail": "html",
        "documentation": {}
    },
    {
        "label": "escape",
        "importPath": "html",
        "description": "html",
        "isExtraImport": true,
        "detail": "html",
        "documentation": {}
    },
    {
        "label": "escape",
        "importPath": "html",
        "description": "html",
        "isExtraImport": true,
        "detail": "html",
        "documentation": {}
    },
    {
        "label": "pygments",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pygments",
        "description": "pygments",
        "detail": "pygments",
        "documentation": {}
    },
    {
        "label": "pygments.formatters",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pygments.formatters",
        "description": "pygments.formatters",
        "detail": "pygments.formatters",
        "documentation": {}
    },
    {
        "label": "pygments.lexer",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pygments.lexer",
        "description": "pygments.lexer",
        "detail": "pygments.lexer",
        "documentation": {}
    },
    {
        "label": "pygments.lexers",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pygments.lexers",
        "description": "pygments.lexers",
        "detail": "pygments.lexers",
        "documentation": {}
    },
    {
        "label": "pygments.util",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pygments.util",
        "description": "pygments.util",
        "detail": "pygments.util",
        "documentation": {}
    },
    {
        "label": "STYLE_MAP",
        "importPath": "pygments.styles",
        "description": "pygments.styles",
        "isExtraImport": true,
        "detail": "pygments.styles",
        "documentation": {}
    },
    {
        "label": "get_style_by_name",
        "importPath": "pygments.styles",
        "description": "pygments.styles",
        "isExtraImport": true,
        "detail": "pygments.styles",
        "documentation": {}
    },
    {
        "label": "Token",
        "importPath": "pygments.token",
        "description": "pygments.token",
        "isExtraImport": true,
        "detail": "pygments.token",
        "documentation": {}
    },
    {
        "label": "_TokenType",
        "importPath": "pygments.token",
        "description": "pygments.token",
        "isExtraImport": true,
        "detail": "pygments.token",
        "documentation": {}
    },
    {
        "label": "color_tokens",
        "importPath": "pygments_ansi_color",
        "description": "pygments_ansi_color",
        "isExtraImport": true,
        "detail": "pygments_ansi_color",
        "documentation": {}
    },
    {
        "label": "pprint",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pprint",
        "description": "pprint",
        "detail": "pprint",
        "documentation": {}
    },
    {
        "label": "lxml",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "lxml",
        "description": "lxml",
        "detail": "lxml",
        "documentation": {}
    },
    {
        "label": "html",
        "importPath": "lxml",
        "description": "lxml",
        "isExtraImport": true,
        "detail": "lxml",
        "documentation": {}
    },
    {
        "label": "etree",
        "importPath": "lxml",
        "description": "lxml",
        "isExtraImport": true,
        "detail": "lxml",
        "documentation": {}
    },
    {
        "label": "html",
        "importPath": "lxml",
        "description": "lxml",
        "isExtraImport": true,
        "detail": "lxml",
        "documentation": {}
    },
    {
        "label": "etree",
        "importPath": "lxml",
        "description": "lxml",
        "isExtraImport": true,
        "detail": "lxml",
        "documentation": {}
    },
    {
        "label": "etree",
        "importPath": "lxml",
        "description": "lxml",
        "isExtraImport": true,
        "detail": "lxml",
        "documentation": {}
    },
    {
        "label": "etree",
        "importPath": "lxml",
        "description": "lxml",
        "isExtraImport": true,
        "detail": "lxml",
        "documentation": {}
    },
    {
        "label": "lxml.etree",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "lxml.etree",
        "description": "lxml.etree",
        "detail": "lxml.etree",
        "documentation": {}
    },
    {
        "label": "Comment",
        "importPath": "lxml.etree",
        "description": "lxml.etree",
        "isExtraImport": true,
        "detail": "lxml.etree",
        "documentation": {}
    },
    {
        "label": "_Element",
        "importPath": "lxml.etree",
        "description": "lxml.etree",
        "isExtraImport": true,
        "detail": "lxml.etree",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "defaults",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "defaults",
        "description": "defaults",
        "detail": "defaults",
        "documentation": {}
    },
    {
        "label": "elements",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "elements",
        "description": "elements",
        "detail": "elements",
        "documentation": {}
    },
    {
        "label": "pathlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pathlib",
        "description": "pathlib",
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "ansi2html.style",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ansi2html.style",
        "description": "ansi2html.style",
        "detail": "ansi2html.style",
        "documentation": {}
    },
    {
        "label": "Ansi2HTMLConverter",
        "importPath": "ansi2html",
        "description": "ansi2html",
        "isExtraImport": true,
        "detail": "ansi2html",
        "documentation": {}
    },
    {
        "label": "PLColor",
        "importPath": "colors",
        "description": "colors",
        "isExtraImport": true,
        "detail": "colors",
        "documentation": {}
    },
    {
        "label": "PLColor",
        "importPath": "colors",
        "description": "colors",
        "isExtraImport": true,
        "detail": "colors",
        "documentation": {}
    },
    {
        "label": "PLColor",
        "importPath": "colors",
        "description": "colors",
        "isExtraImport": true,
        "detail": "colors",
        "documentation": {}
    },
    {
        "label": "PLColor",
        "importPath": "colors",
        "description": "colors",
        "isExtraImport": true,
        "detail": "colors",
        "documentation": {}
    },
    {
        "label": "get_css_color",
        "importPath": "colors",
        "description": "colors",
        "isExtraImport": true,
        "detail": "colors",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "unidecode",
        "importPath": "text_unidecode",
        "description": "text_unidecode",
        "isExtraImport": true,
        "detail": "text_unidecode",
        "documentation": {}
    },
    {
        "label": "unidecode",
        "importPath": "text_unidecode",
        "description": "text_unidecode",
        "isExtraImport": true,
        "detail": "text_unidecode",
        "documentation": {}
    },
    {
        "label": "networkx",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "networkx",
        "description": "networkx",
        "detail": "networkx",
        "documentation": {}
    },
    {
        "label": "pygraphviz",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pygraphviz",
        "description": "pygraphviz",
        "detail": "pygraphviz",
        "documentation": {}
    },
    {
        "label": "numbers",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numbers",
        "description": "numbers",
        "detail": "numbers",
        "documentation": {}
    },
    {
        "label": "itertools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "itertools",
        "description": "itertools",
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "count",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "chain",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "chain",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "repeat",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "chain",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "collections",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "collections",
        "description": "collections",
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "importlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "importlib",
        "description": "importlib",
        "detail": "importlib",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "copy",
        "description": "copy",
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "dag_to_nx",
        "importPath": "dag_checker",
        "description": "dag_checker",
        "isExtraImport": true,
        "detail": "dag_checker",
        "documentation": {}
    },
    {
        "label": "grade_dag",
        "importPath": "dag_checker",
        "description": "dag_checker",
        "isExtraImport": true,
        "detail": "dag_checker",
        "documentation": {}
    },
    {
        "label": "lcs_partial_credit",
        "importPath": "dag_checker",
        "description": "dag_checker",
        "isExtraImport": true,
        "detail": "dag_checker",
        "documentation": {}
    },
    {
        "label": "solve_dag",
        "importPath": "dag_checker",
        "description": "dag_checker",
        "isExtraImport": true,
        "detail": "dag_checker",
        "documentation": {}
    },
    {
        "label": "grade_dag",
        "importPath": "dag_checker",
        "description": "dag_checker",
        "isExtraImport": true,
        "detail": "dag_checker",
        "documentation": {}
    },
    {
        "label": "lcs_partial_credit",
        "importPath": "dag_checker",
        "description": "dag_checker",
        "isExtraImport": true,
        "detail": "dag_checker",
        "documentation": {}
    },
    {
        "label": "solve_dag",
        "importPath": "dag_checker",
        "description": "dag_checker",
        "isExtraImport": true,
        "detail": "dag_checker",
        "documentation": {}
    },
    {
        "label": "pyquaternion",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pyquaternion",
        "description": "pyquaternion",
        "detail": "pyquaternion",
        "documentation": {}
    },
    {
        "label": "unit_utils",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unit_utils",
        "description": "unit_utils",
        "detail": "unit_utils",
        "documentation": {}
    },
    {
        "label": "pint",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pint",
        "description": "pint",
        "detail": "pint",
        "documentation": {}
    },
    {
        "label": "UnitRegistry",
        "importPath": "pint",
        "description": "pint",
        "isExtraImport": true,
        "detail": "pint",
        "documentation": {}
    },
    {
        "label": "errors",
        "importPath": "pint",
        "description": "pint",
        "isExtraImport": true,
        "detail": "pint",
        "documentation": {}
    },
    {
        "label": "UnitRegistry",
        "importPath": "pint",
        "description": "pint",
        "isExtraImport": true,
        "detail": "pint",
        "documentation": {}
    },
    {
        "label": "UnitRegistry",
        "importPath": "pint",
        "description": "pint",
        "isExtraImport": true,
        "detail": "pint",
        "documentation": {}
    },
    {
        "label": "UnitRegistry",
        "importPath": "pint",
        "description": "pint",
        "isExtraImport": true,
        "detail": "pint",
        "documentation": {}
    },
    {
        "label": "check_data",
        "importPath": "check_data",
        "description": "check_data",
        "isExtraImport": true,
        "detail": "check_data",
        "documentation": {}
    },
    {
        "label": "Phase",
        "importPath": "check_data",
        "description": "check_data",
        "isExtraImport": true,
        "detail": "check_data",
        "documentation": {}
    },
    {
        "label": "check_data",
        "importPath": "check_data",
        "description": "check_data",
        "isExtraImport": true,
        "detail": "check_data",
        "documentation": {}
    },
    {
        "label": "Color",
        "importPath": "coloraide",
        "description": "coloraide",
        "isExtraImport": true,
        "detail": "coloraide",
        "documentation": {}
    },
    {
        "label": "algebra",
        "importPath": "coloraide",
        "description": "coloraide",
        "isExtraImport": true,
        "detail": "coloraide",
        "documentation": {}
    },
    {
        "label": "Color",
        "importPath": "coloraide",
        "description": "coloraide",
        "isExtraImport": true,
        "detail": "coloraide",
        "documentation": {}
    },
    {
        "label": "serialize",
        "importPath": "coloraide.css",
        "description": "coloraide.css",
        "isExtraImport": true,
        "detail": "coloraide.css",
        "documentation": {}
    },
    {
        "label": "sRGB",
        "importPath": "coloraide.spaces.srgb.css",
        "description": "coloraide.spaces.srgb.css",
        "isExtraImport": true,
        "detail": "coloraide.spaces.srgb.css",
        "documentation": {}
    },
    {
        "label": "Vector",
        "importPath": "coloraide.types",
        "description": "coloraide.types",
        "isExtraImport": true,
        "detail": "coloraide.types",
        "documentation": {}
    },
    {
        "label": "importlib.util",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "importlib.util",
        "description": "importlib.util",
        "detail": "importlib.util",
        "documentation": {}
    },
    {
        "label": "string",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "string",
        "description": "string",
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "unicodedata",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unicodedata",
        "description": "unicodedata",
        "detail": "unicodedata",
        "documentation": {}
    },
    {
        "label": "ArrayLike",
        "importPath": "numpy.typing",
        "description": "numpy.typing",
        "isExtraImport": true,
        "detail": "numpy.typing",
        "documentation": {}
    },
    {
        "label": "TokenError",
        "importPath": "tokenize",
        "description": "tokenize",
        "isExtraImport": true,
        "detail": "tokenize",
        "documentation": {}
    },
    {
        "label": "eval_expr",
        "importPath": "sympy.parsing.sympy_parser",
        "description": "sympy.parsing.sympy_parser",
        "isExtraImport": true,
        "detail": "sympy.parsing.sympy_parser",
        "documentation": {}
    },
    {
        "label": "implicit_multiplication_application",
        "importPath": "sympy.parsing.sympy_parser",
        "description": "sympy.parsing.sympy_parser",
        "isExtraImport": true,
        "detail": "sympy.parsing.sympy_parser",
        "documentation": {}
    },
    {
        "label": "standard_transformations",
        "importPath": "sympy.parsing.sympy_parser",
        "description": "sympy.parsing.sympy_parser",
        "isExtraImport": true,
        "detail": "sympy.parsing.sympy_parser",
        "documentation": {}
    },
    {
        "label": "stringify_expr",
        "importPath": "sympy.parsing.sympy_parser",
        "description": "sympy.parsing.sympy_parser",
        "isExtraImport": true,
        "detail": "sympy.parsing.sympy_parser",
        "documentation": {}
    },
    {
        "label": "traverse_and_execute",
        "importPath": "traverse",
        "description": "traverse",
        "isExtraImport": true,
        "detail": "traverse",
        "documentation": {}
    },
    {
        "label": "traverse_and_replace",
        "importPath": "traverse",
        "description": "traverse",
        "isExtraImport": true,
        "detail": "traverse",
        "documentation": {}
    },
    {
        "label": "ElementReplacement",
        "importPath": "traverse",
        "description": "traverse",
        "isExtraImport": true,
        "detail": "traverse",
        "documentation": {}
    },
    {
        "label": "traverse_and_execute",
        "importPath": "traverse",
        "description": "traverse",
        "isExtraImport": true,
        "detail": "traverse",
        "documentation": {}
    },
    {
        "label": "traverse_and_replace",
        "importPath": "traverse",
        "description": "traverse",
        "isExtraImport": true,
        "detail": "traverse",
        "documentation": {}
    },
    {
        "label": "signal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "signal",
        "description": "signal",
        "detail": "signal",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "types",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "types",
        "description": "types",
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "MetaPathFinder",
        "importPath": "importlib.abc",
        "description": "importlib.abc",
        "isExtraImport": true,
        "detail": "importlib.abc",
        "documentation": {}
    },
    {
        "label": "signature",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "question_phases",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "question_phases",
        "description": "question_phases",
        "detail": "question_phases",
        "documentation": {}
    },
    {
        "label": "zygote_utils",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "zygote_utils",
        "description": "zygote_utils",
        "detail": "zygote_utils",
        "documentation": {}
    },
    {
        "label": "matplotlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib",
        "description": "matplotlib",
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "matplotlib.font_manager",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.font_manager",
        "description": "matplotlib.font_manager",
        "detail": "matplotlib.font_manager",
        "documentation": {}
    },
    {
        "label": "nltk",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "nltk",
        "description": "nltk",
        "detail": "nltk",
        "documentation": {}
    },
    {
        "label": "sklearn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sklearn",
        "description": "sklearn",
        "detail": "sklearn",
        "documentation": {}
    },
    {
        "label": "base",
        "importPath": "email.mime",
        "description": "email.mime",
        "isExtraImport": true,
        "detail": "email.mime",
        "documentation": {}
    },
    {
        "label": "Template",
        "importPath": "jinja2",
        "description": "jinja2",
        "isExtraImport": true,
        "detail": "jinja2",
        "documentation": {}
    },
    {
        "label": "Template",
        "importPath": "jinja2",
        "description": "jinja2",
        "isExtraImport": true,
        "detail": "jinja2",
        "documentation": {}
    },
    {
        "label": "Template",
        "importPath": "jinja2",
        "description": "jinja2",
        "isExtraImport": true,
        "detail": "jinja2",
        "documentation": {}
    },
    {
        "label": "Template",
        "importPath": "jinja2",
        "description": "jinja2",
        "isExtraImport": true,
        "detail": "jinja2",
        "documentation": {}
    },
    {
        "label": "Template",
        "importPath": "jinja2",
        "description": "jinja2",
        "isExtraImport": true,
        "detail": "jinja2",
        "documentation": {}
    },
    {
        "label": "execjs",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "execjs",
        "description": "execjs",
        "detail": "execjs",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "create_app",
        "importPath": "app",
        "description": "app",
        "isExtraImport": true,
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "EduModule",
        "kind": 6,
        "importPath": "app.db_models.models",
        "description": "app.db_models.models",
        "peekOfCode": "class EduModule(db.Model):\n    __tablename__ = \"edu_module\"\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(256), nullable=False)\n    folders = db.relationship(\"Folder\", backref=\"edu_module\", lazy=True)\n    def __repr__(self):\n        return f\"<EduModule {self.name}>\"\nclass Folder(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(256), nullable=False)",
        "detail": "app.db_models.models",
        "documentation": {}
    },
    {
        "label": "Folder",
        "kind": 6,
        "importPath": "app.db_models.models",
        "description": "app.db_models.models",
        "peekOfCode": "class Folder(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(256), nullable=False)\n    files = db.relationship('File', backref='folder', lazy=True)\n    question_metadata = db.relationship('QuestionMetadata', backref='folder', lazy=True)\n    module_id = db.Column(db.Integer, db.ForeignKey('edu_module.id'), nullable=False)\n    def __repr__(self):\n        return f\"<Folder {self.name}>\"\nclass QuestionMetadata(db.Model):\n    __tablename__ = 'questions'  # Consider if this is the desired table name",
        "detail": "app.db_models.models",
        "documentation": {}
    },
    {
        "label": "QuestionMetadata",
        "kind": 6,
        "importPath": "app.db_models.models",
        "description": "app.db_models.models",
        "peekOfCode": "class QuestionMetadata(db.Model):\n    __tablename__ = 'questions'  # Consider if this is the desired table name\n    uuid = db.Column(db.String(36), primary_key=True)  # Ensure UUID is properly formatted\n    title = db.Column(db.String(128), nullable=False)\n    stem = db.Column(db.Text, nullable=False)\n    topic = db.Column(db.String(64), nullable=False)\n    tags = db.Column(db.Text, nullable=False)  # JSON or comma-separated string\n    prereqs = db.Column(db.Text, nullable=False)  # JSON or comma-separated string\n    is_adaptive = db.Column(db.Boolean, default=False)\n    created_by = db.Column(db.String(128), nullable=False)",
        "detail": "app.db_models.models",
        "documentation": {}
    },
    {
        "label": "File",
        "kind": 6,
        "importPath": "app.db_models.models",
        "description": "app.db_models.models",
        "peekOfCode": "class File(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    filename = db.Column(db.String(256), nullable=False)\n    content = db.Column(db.Text, nullable=False)  # Changed to Text for potentially larger content\n    folder_id = db.Column(db.Integer, db.ForeignKey('folder.id'), nullable=False)\n    def __repr__(self):\n        return f\"<File {self.filename} in folder {self.folder_id}>\"\nclass User(db.Model, UserMixin):\n    __tablename__ = \"users\"\n    id = db.Column(db.Integer, primary_key=True)",
        "detail": "app.db_models.models",
        "documentation": {}
    },
    {
        "label": "User",
        "kind": 6,
        "importPath": "app.db_models.models",
        "description": "app.db_models.models",
        "peekOfCode": "class User(db.Model, UserMixin):\n    __tablename__ = \"users\"\n    id = db.Column(db.Integer, primary_key=True)\n    first_name = db.Column(db.String(64))\n    email = db.Column(db.String(64), unique=True, index=True)\n    password_hash = db.Column(db.String(128))\n    role_id = db.Column(db.Integer, db.ForeignKey('roles.id'))\n    def __init__(self, **kwargs):\n        super(User, self).__init__(**kwargs)\n        if self.role is None:",
        "detail": "app.db_models.models",
        "documentation": {}
    },
    {
        "label": "Permission",
        "kind": 6,
        "importPath": "app.db_models.models",
        "description": "app.db_models.models",
        "peekOfCode": "class Permission:\n    PRACTICE = 1\n    GENERATE = 2\n    MODIFY = 4\n    ADMIN = 8    \nclass Role(db.Model):\n    __tablename__ = \"roles\"\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(64), unique=True)\n    default = db.Column(db.Boolean, default=False, index=True)",
        "detail": "app.db_models.models",
        "documentation": {}
    },
    {
        "label": "Role",
        "kind": 6,
        "importPath": "app.db_models.models",
        "description": "app.db_models.models",
        "peekOfCode": "class Role(db.Model):\n    __tablename__ = \"roles\"\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(64), unique=True)\n    default = db.Column(db.Boolean, default=False, index=True)\n    permissions = db.Column(db.Integer, default=0)  # Ensure permissions is initialized to 0\n    users = db.relationship('User', backref='role', lazy='dynamic')\n    def __init__(self, **kwargs):\n        super(Role, self).__init__(**kwargs)\n        if self.permissions is None:",
        "detail": "app.db_models.models",
        "documentation": {}
    },
    {
        "label": "db",
        "kind": 5,
        "importPath": "app.db_models.models",
        "description": "app.db_models.models",
        "peekOfCode": "db = SQLAlchemy()\nclass EduModule(db.Model):\n    __tablename__ = \"edu_module\"\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(256), nullable=False)\n    folders = db.relationship(\"Folder\", backref=\"edu_module\", lazy=True)\n    def __repr__(self):\n        return f\"<EduModule {self.name}>\"\nclass Folder(db.Model):\n    id = db.Column(db.Integer, primary_key=True)",
        "detail": "app.db_models.models",
        "documentation": {}
    },
    {
        "label": "QuestionForm",
        "kind": 6,
        "importPath": "app.form.forms",
        "description": "app.form.forms",
        "peekOfCode": "class QuestionForm(FlaskForm):\n    \"\"\"\n    A FlaskForm for generating a question using a string input.\n    This form is used to input a question string, which will be processed to generate\n    content based on the user's input. It includes a text field for entering the question \n    and a submit button to initiate the generation process.\n    Attributes:\n        question (StringField): A text field where the user can input the question they want to generate.\n        submit (SubmitField): A button to submit the form and trigger the generation process.\n    Args:",
        "detail": "app.form.forms",
        "documentation": {}
    },
    {
        "label": "ImageForm",
        "kind": 6,
        "importPath": "app.form.forms",
        "description": "app.form.forms",
        "peekOfCode": "class ImageForm(FlaskForm):\n    \"\"\"\n    A FlaskForm for uploading multiple image files and submitting them for processing.\n    This form allows users to upload one or more image files, which can then be processed\n    based on the user's needs. It includes a file upload field for selecting multiple files\n    and a submit button to initiate the file processing.\n    Attributes:\n        files (MultipleFileField): A file upload field that allows the user to select and upload multiple files. \n                                   The field is validated to ensure that at least one file is selected.\n        submit (SubmitField): A button to submit the form and trigger the processing of the uploaded files.",
        "detail": "app.form.forms",
        "documentation": {}
    },
    {
        "label": "LoginForm",
        "kind": 6,
        "importPath": "app.form.forms",
        "description": "app.form.forms",
        "peekOfCode": "class LoginForm(FlaskForm):\n    email = StringField('Email', validators=[DataRequired(), Length(1, 64), Email()])\n    password = PasswordField(\"Password\",validators = [DataRequired()])\n    remember_me = BooleanField(\"Keep Me Logged In\")\n    submit = SubmitField(\"Log In\")\nclass SignUp(FlaskForm):\n    first_name = StringField(\"First Name\", validators=[DataRequired(), Length(1, 64)])\n    email = StringField('Email', validators=[DataRequired(), Length(1, 64), Email()])\n    password = PasswordField('Password', validators=[DataRequired(), EqualTo('password2', message='Passwords must match.')])\n    password2 = PasswordField('Confirm Password', validators=[DataRequired()])",
        "detail": "app.form.forms",
        "documentation": {}
    },
    {
        "label": "SignUp",
        "kind": 6,
        "importPath": "app.form.forms",
        "description": "app.form.forms",
        "peekOfCode": "class SignUp(FlaskForm):\n    first_name = StringField(\"First Name\", validators=[DataRequired(), Length(1, 64)])\n    email = StringField('Email', validators=[DataRequired(), Length(1, 64), Email()])\n    password = PasswordField('Password', validators=[DataRequired(), EqualTo('password2', message='Passwords must match.')])\n    password2 = PasswordField('Confirm Password', validators=[DataRequired()])\n    submit = SubmitField(\"Sign Up\")\n    def validate_email(self, field):\n        if User.query.filter_by(email=field.data).first():\n            raise ValidationError('Email already registered.')\nclass UPDATE_CODE(FlaskForm):",
        "detail": "app.form.forms",
        "documentation": {}
    },
    {
        "label": "UPDATE_CODE",
        "kind": 6,
        "importPath": "app.form.forms",
        "description": "app.form.forms",
        "peekOfCode": "class UPDATE_CODE(FlaskForm):\n    code = TextAreaField('Code', validators=[DataRequired()])\n    save = SubmitField(\"Save Code\")",
        "detail": "app.form.forms",
        "documentation": {}
    },
    {
        "label": "generate_image",
        "kind": 2,
        "importPath": "app.routes.content_generator.image_gen",
        "description": "app.routes.content_generator.image_gen",
        "peekOfCode": "def generate_image():\n    \"\"\"\n    Route for generating image-based modules from uploaded files.\n    Renders a form for the user to upload images. Upon form submission, the images\n    are processed asynchronously to generate modules. The generated content is then saved.\n    Returns:\n        Response: A Flask response object with either the generated content or an error message.\n    \"\"\"\n    form = ImageForm()\n    logger.info(\"Image form initialized.\")",
        "detail": "app.routes.content_generator.image_gen",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "app.routes.content_generator.image_gen",
        "description": "app.routes.content_generator.image_gen",
        "peekOfCode": "logger = get_logger(__name__)\n# User data to be used in the module generation\nuser_data = {\n    \"created_by\": \"lberm007@ucr.edu\",  # Replace with the actual creator identifier\n    \"code_language\": \"javascript\",\n}\nimage_generator_bp = Blueprint('image_generator_bp', __name__)\n@image_generator_bp.route(\"/image-generator\", methods=['GET', 'POST'])\ndef generate_image():\n    \"\"\"",
        "detail": "app.routes.content_generator.image_gen",
        "documentation": {}
    },
    {
        "label": "user_data",
        "kind": 5,
        "importPath": "app.routes.content_generator.image_gen",
        "description": "app.routes.content_generator.image_gen",
        "peekOfCode": "user_data = {\n    \"created_by\": \"lberm007@ucr.edu\",  # Replace with the actual creator identifier\n    \"code_language\": \"javascript\",\n}\nimage_generator_bp = Blueprint('image_generator_bp', __name__)\n@image_generator_bp.route(\"/image-generator\", methods=['GET', 'POST'])\ndef generate_image():\n    \"\"\"\n    Route for generating image-based modules from uploaded files.\n    Renders a form for the user to upload images. Upon form submission, the images",
        "detail": "app.routes.content_generator.image_gen",
        "documentation": {}
    },
    {
        "label": "image_generator_bp",
        "kind": 5,
        "importPath": "app.routes.content_generator.image_gen",
        "description": "app.routes.content_generator.image_gen",
        "peekOfCode": "image_generator_bp = Blueprint('image_generator_bp', __name__)\n@image_generator_bp.route(\"/image-generator\", methods=['GET', 'POST'])\ndef generate_image():\n    \"\"\"\n    Route for generating image-based modules from uploaded files.\n    Renders a form for the user to upload images. Upon form submission, the images\n    are processed asynchronously to generate modules. The generated content is then saved.\n    Returns:\n        Response: A Flask response object with either the generated content or an error message.\n    \"\"\"",
        "detail": "app.routes.content_generator.image_gen",
        "documentation": {}
    },
    {
        "label": "generate_lecture",
        "kind": 2,
        "importPath": "app.routes.content_generator.lecture_gen",
        "description": "app.routes.content_generator.lecture_gen",
        "peekOfCode": "def generate_lecture():\n    form = ImageForm()\n    session[\"module_name\"] = form.module_name.data\n    print(form)\n    if form.validate_on_submit():\n        print(\"Passed validation\")\n        try:\n            file_paths = []\n            with tempfile.TemporaryDirectory() as tmpdir:\n                print(\"About to save files\")",
        "detail": "app.routes.content_generator.lecture_gen",
        "documentation": {}
    },
    {
        "label": "user_data",
        "kind": 5,
        "importPath": "app.routes.content_generator.lecture_gen",
        "description": "app.routes.content_generator.lecture_gen",
        "peekOfCode": "user_data = {\n        \"created_by\": \"lberm007@ucr.edu\",  # Replace with the actual creator identifier\n        \"code_language\": \"javascript\",\n    }\nlecture_generator_bp = Blueprint('lecture_generator_bp', __name__)\n@lecture_generator_bp.route(\"/lecture-generator\", methods=['GET', 'POST'])\ndef generate_lecture():\n    form = ImageForm()\n    session[\"module_name\"] = form.module_name.data\n    print(form)",
        "detail": "app.routes.content_generator.lecture_gen",
        "documentation": {}
    },
    {
        "label": "lecture_generator_bp",
        "kind": 5,
        "importPath": "app.routes.content_generator.lecture_gen",
        "description": "app.routes.content_generator.lecture_gen",
        "peekOfCode": "lecture_generator_bp = Blueprint('lecture_generator_bp', __name__)\n@lecture_generator_bp.route(\"/lecture-generator\", methods=['GET', 'POST'])\ndef generate_lecture():\n    form = ImageForm()\n    session[\"module_name\"] = form.module_name.data\n    print(form)\n    if form.validate_on_submit():\n        print(\"Passed validation\")\n        try:\n            file_paths = []",
        "detail": "app.routes.content_generator.lecture_gen",
        "documentation": {}
    },
    {
        "label": "generate_text",
        "kind": 2,
        "importPath": "app.routes.content_generator.text_gen",
        "description": "app.routes.content_generator.text_gen",
        "peekOfCode": "def generate_text():\n    \"\"\"\n    Route for generating text-based modules from user input.\n    Renders a form for the user to input a question. Upon form submission, the question\n    is processed asynchronously to generate a module. The generated content is then saved.\n    Returns:\n        Response: A Flask response object with either the generated content or an error message.\n    \"\"\"\n    form = QuestionForm()\n    if form.validate_on_submit():",
        "detail": "app.routes.content_generator.text_gen",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "app.routes.content_generator.text_gen",
        "description": "app.routes.content_generator.text_gen",
        "peekOfCode": "logger = get_logger(__name__)\n# Create the Blueprint\ntext_generator_bp = Blueprint(\"text_generator_bp\", __name__)\n# User data to be used in the module generation\nuser_data = {\n    \"created_by\": \"lberm007@ucr.edu\",  # Replace with the actual creator identifier\n    \"code_language\": \"javascript\",\n}\n@text_generator_bp.route(\"/text-generator\", methods=['GET', 'POST'])\ndef generate_text():",
        "detail": "app.routes.content_generator.text_gen",
        "documentation": {}
    },
    {
        "label": "text_generator_bp",
        "kind": 5,
        "importPath": "app.routes.content_generator.text_gen",
        "description": "app.routes.content_generator.text_gen",
        "peekOfCode": "text_generator_bp = Blueprint(\"text_generator_bp\", __name__)\n# User data to be used in the module generation\nuser_data = {\n    \"created_by\": \"lberm007@ucr.edu\",  # Replace with the actual creator identifier\n    \"code_language\": \"javascript\",\n}\n@text_generator_bp.route(\"/text-generator\", methods=['GET', 'POST'])\ndef generate_text():\n    \"\"\"\n    Route for generating text-based modules from user input.",
        "detail": "app.routes.content_generator.text_gen",
        "documentation": {}
    },
    {
        "label": "user_data",
        "kind": 5,
        "importPath": "app.routes.content_generator.text_gen",
        "description": "app.routes.content_generator.text_gen",
        "peekOfCode": "user_data = {\n    \"created_by\": \"lberm007@ucr.edu\",  # Replace with the actual creator identifier\n    \"code_language\": \"javascript\",\n}\n@text_generator_bp.route(\"/text-generator\", methods=['GET', 'POST'])\ndef generate_text():\n    \"\"\"\n    Route for generating text-based modules from user input.\n    Renders a form for the user to input a question. Upon form submission, the question\n    is processed asynchronously to generate a module. The generated content is then saved.",
        "detail": "app.routes.content_generator.text_gen",
        "documentation": {}
    },
    {
        "label": "save_generated_content",
        "kind": 2,
        "importPath": "app.routes.content_generator.utils",
        "description": "app.routes.content_generator.utils",
        "peekOfCode": "def save_generated_content(generated_content, module_name:str = \"Module\"):\n    \"\"\"\n    Save the generated content to the database, including the module, folders, and files.\n    This function processes the generated content by:\n    1. Creating and saving an `EduModule` instance.\n    2. Iterating over the generated content to create and save corresponding `Folder` and `File` instances.\n    3. Temporarily storing files in a directory before saving their binary contents to the database.\n    Args:\n        generated_content (list of tuples): The content generated by the module, where each tuple contains:\n            - question_title (str): The title of the question (used as the folder name).",
        "detail": "app.routes.content_generator.utils",
        "documentation": {}
    },
    {
        "label": "login",
        "kind": 2,
        "importPath": "app.routes.generic_routes.auth",
        "description": "app.routes.generic_routes.auth",
        "peekOfCode": "def login():\n    form = LoginForm()\n    if form.validate_on_submit():\n        user = User.query.filter_by(email = form.email.data).first()\n        if user is not None and user.verify_password(form.password.data):\n            login_user(user,remember=form.remember_me.data)\n            next = request.args.get(\"next\")\n            if next is None or not next.startswith(\"/\"):\n                next = url_for(\"routes.home\")\n            return redirect(next)",
        "detail": "app.routes.generic_routes.auth",
        "documentation": {}
    },
    {
        "label": "logout",
        "kind": 2,
        "importPath": "app.routes.generic_routes.auth",
        "description": "app.routes.generic_routes.auth",
        "peekOfCode": "def logout():\n    logout_user()\n    return redirect(url_for('auth.login'))\n@auth.route('/signup', methods=[\"GET\", \"POST\"])\ndef signup():\n    form = SignUp()\n    print(form)\n    if form.validate_on_submit():\n        user = User(\n            email=form.email.data,",
        "detail": "app.routes.generic_routes.auth",
        "documentation": {}
    },
    {
        "label": "signup",
        "kind": 2,
        "importPath": "app.routes.generic_routes.auth",
        "description": "app.routes.generic_routes.auth",
        "peekOfCode": "def signup():\n    form = SignUp()\n    print(form)\n    if form.validate_on_submit():\n        user = User(\n            email=form.email.data,\n            first_name=form.first_name.data,\n            password=form.password.data  # Password will be hashed in the model\n        )\n        db.session.add(user)",
        "detail": "app.routes.generic_routes.auth",
        "documentation": {}
    },
    {
        "label": "auth",
        "kind": 5,
        "importPath": "app.routes.generic_routes.auth",
        "description": "app.routes.generic_routes.auth",
        "peekOfCode": "auth = Blueprint(\"auth\", __name__)\n@auth.route('/login', methods = [\"GET\", \"POST\"] )\ndef login():\n    form = LoginForm()\n    if form.validate_on_submit():\n        user = User.query.filter_by(email = form.email.data).first()\n        if user is not None and user.verify_password(form.password.data):\n            login_user(user,remember=form.remember_me.data)\n            next = request.args.get(\"next\")\n            if next is None or not next.startswith(\"/\"):",
        "detail": "app.routes.generic_routes.auth",
        "documentation": {}
    },
    {
        "label": "home",
        "kind": 2,
        "importPath": "app.routes.generic_routes.routes",
        "description": "app.routes.generic_routes.routes",
        "peekOfCode": "def home():\n    return render_template(\"home.html\")\n@routes.route('/license')\ndef license():\n    return render_template('license.html')",
        "detail": "app.routes.generic_routes.routes",
        "documentation": {}
    },
    {
        "label": "license",
        "kind": 2,
        "importPath": "app.routes.generic_routes.routes",
        "description": "app.routes.generic_routes.routes",
        "peekOfCode": "def license():\n    return render_template('license.html')",
        "detail": "app.routes.generic_routes.routes",
        "documentation": {}
    },
    {
        "label": "routes",
        "kind": 5,
        "importPath": "app.routes.generic_routes.routes",
        "description": "app.routes.generic_routes.routes",
        "peekOfCode": "routes = Blueprint(\"routes\", __name__)\n@routes.route('/', methods=['GET', 'POST'])\n@routes.route('/home', methods=['GET', 'POST'])\ndef home():\n    return render_template(\"home.html\")\n@routes.route('/license')\ndef license():\n    return render_template('license.html')",
        "detail": "app.routes.generic_routes.routes",
        "documentation": {}
    },
    {
        "label": "view_modules",
        "kind": 2,
        "importPath": "app.routes.module_retrieval.module_retrieval",
        "description": "app.routes.module_retrieval.module_retrieval",
        "peekOfCode": "def view_modules():\n    \"\"\"Gets the modules from the database and returns the module data which is just the name \n    and the id for now\n    Returns:\n        renders the template\n    \"\"\"\n    modules = EduModule.query.all()\n    module_data = []\n    for module in modules:\n        module_data.append({",
        "detail": "app.routes.module_retrieval.module_retrieval",
        "documentation": {}
    },
    {
        "label": "view_module_details",
        "kind": 2,
        "importPath": "app.routes.module_retrieval.module_retrieval",
        "description": "app.routes.module_retrieval.module_retrieval",
        "peekOfCode": "def view_module_details(module_name,module_id):\n    module = EduModule.query.filter_by(id=module_id).first()\n    folder_data = []\n    for folder in module.folders:\n        folder_data.append({\n            'id': folder.id,\n            'folder_name': folder.name,\n        })\n    print(f\"This is the folder data {folder_data}\")\n    session[\"folder_data\"] = folder_data",
        "detail": "app.routes.module_retrieval.module_retrieval",
        "documentation": {}
    },
    {
        "label": "module_retrieval_bp",
        "kind": 5,
        "importPath": "app.routes.module_retrieval.module_retrieval",
        "description": "app.routes.module_retrieval.module_retrieval",
        "peekOfCode": "module_retrieval_bp = Blueprint('module_retrieval_bp', __name__)\n@module_retrieval_bp.route(\"/retrieve_modules\", methods=['GET', 'POST'])\ndef view_modules():\n    \"\"\"Gets the modules from the database and returns the module data which is just the name \n    and the id for now\n    Returns:\n        renders the template\n    \"\"\"\n    modules = EduModule.query.all()\n    module_data = []",
        "detail": "app.routes.module_retrieval.module_retrieval",
        "documentation": {}
    },
    {
        "label": "view_modules",
        "kind": 2,
        "importPath": "app.routes.module_retrieval.view_modules",
        "description": "app.routes.module_retrieval.view_modules",
        "peekOfCode": "def view_modules():\n    modules = EduModule.query.all()\n    module_data = []\n    for module in modules:\n        module_data.append({\n            'id': module.id,\n            'name': module.name,\n        })\n    # Debugging\n    print(module_data)",
        "detail": "app.routes.module_retrieval.view_modules",
        "documentation": {}
    },
    {
        "label": "view_module_details",
        "kind": 2,
        "importPath": "app.routes.module_retrieval.view_modules",
        "description": "app.routes.module_retrieval.view_modules",
        "peekOfCode": "def view_module_details(module_name,module_id):\n    module = EduModule.query.filter_by(id=module_id).first()\n    folder_data = []\n    for folder in module.folders:\n        files_data = []\n        for file in folder.files:\n            files_data.append({\n                'id': file.id,\n                'filename': file.filename,\n                'content': file.content.decode('utf-8', errors='ignore') if file.content else ''",
        "detail": "app.routes.module_retrieval.view_modules",
        "documentation": {}
    },
    {
        "label": "view_folder",
        "kind": 2,
        "importPath": "app.routes.module_retrieval.view_modules",
        "description": "app.routes.module_retrieval.view_modules",
        "peekOfCode": "def view_folder(folder_name, folder_id):\n    folder = Folder.query.filter_by(id=folder_id).first()\n    if not folder:\n        return \"<h1>Folder not found</h1>\", 404\n    files_data = [{\n        \"filename\": file.filename,\n        \"content\": file.content\n    } for file in folder.files]\n    print(\"This is the files data\", files_data)  # Debugging\n    file_names = {file.get(\"filename\") for file in files_data}",
        "detail": "app.routes.module_retrieval.view_modules",
        "documentation": {}
    },
    {
        "label": "view_adaptive_quiz",
        "kind": 2,
        "importPath": "app.routes.module_retrieval.view_modules",
        "description": "app.routes.module_retrieval.view_modules",
        "peekOfCode": "def view_adaptive_quiz(folder_name, folder_id):\n    files_data = session.get(\"files_data\")\n    if not files_data:\n        return \"<h1>No files data found in session</h1>\", 404\n    # Re-fetch file contents if needed\n    folder = Folder.query.filter_by(id=folder_id).first()\n    if not folder:\n        return \"<h1>Folder not found</h1>\", 404\n    # Retrieve full file data based on filenames stored in the session\n    full_files_data = [{",
        "detail": "app.routes.module_retrieval.view_modules",
        "documentation": {}
    },
    {
        "label": "determine_file_type",
        "kind": 2,
        "importPath": "app.routes.module_retrieval.view_modules",
        "description": "app.routes.module_retrieval.view_modules",
        "peekOfCode": "def determine_file_type(file_names):\n    adaptive_files = {'question.html', 'server.js', 'server.py', 'solution.html', 'info.json'}\n    nonadaptive_files = {'question.html', 'info.json'}\n    if file_names == nonadaptive_files:\n        return \"NonAdaptive\"\n    elif file_names == adaptive_files:\n        return \"Adaptive\"\n    else:\n        return \"Lecture\"\n#     # Question Module Files",
        "detail": "app.routes.module_retrieval.view_modules",
        "documentation": {}
    },
    {
        "label": "view_modules_bp",
        "kind": 5,
        "importPath": "app.routes.module_retrieval.view_modules",
        "description": "app.routes.module_retrieval.view_modules",
        "peekOfCode": "view_modules_bp = Blueprint('view_modules_bp', __name__)\n@view_modules_bp.route(\"/view_modules\", methods=['GET', 'POST'])\ndef view_modules():\n    modules = EduModule.query.all()\n    module_data = []\n    for module in modules:\n        module_data.append({\n            'id': module.id,\n            'name': module.name,\n        })",
        "detail": "app.routes.module_retrieval.view_modules",
        "documentation": {}
    },
    {
        "label": "render_adaptive_quiz",
        "kind": 2,
        "importPath": "app.routes.quiz_views.adaptive_questions",
        "description": "app.routes.quiz_views.adaptive_questions",
        "peekOfCode": "def render_adaptive_quiz():\n    try:\n        # Retrieve folder information from session\n        folder_id = session.get(\"folder_id\")\n        if not folder_id:\n            return \"Folder ID not found in session\", 400\n        folder_name, full_files_data = retrieve_files_folder(folder_id)\n        # Create a temporary directory to handle file processing\n        with tempfile.TemporaryDirectory() as tmpdir:\n            for file in full_files_data:",
        "detail": "app.routes.quiz_views.adaptive_questions",
        "documentation": {}
    },
    {
        "label": "grade_quiz",
        "kind": 2,
        "importPath": "app.routes.quiz_views.adaptive_questions",
        "description": "app.routes.quiz_views.adaptive_questions",
        "peekOfCode": "def grade_quiz():\n    print(\"Grading\")\n    try:\n        # Retrieve folder information from session\n        folder_id = session.get(\"folder_id\")\n        if not folder_id:\n            return \"Folder ID not found in session\", 400\n        folder_name, full_files_data = retrieve_files_folder(folder_id)\n        quiz_name = folder_name\n        # Process form submission",
        "detail": "app.routes.quiz_views.adaptive_questions",
        "documentation": {}
    },
    {
        "label": "adaptive_quiz_bp",
        "kind": 5,
        "importPath": "app.routes.quiz_views.adaptive_questions",
        "description": "app.routes.quiz_views.adaptive_questions",
        "peekOfCode": "adaptive_quiz_bp = Blueprint('adaptive_quiz_bp', __name__)\n# Initialize logger\nlogger = get_logger(__name__)\n@adaptive_quiz_bp.route(\"/quiz_overview/_adaptive\", methods=['GET', 'POST'])\ndef render_adaptive_quiz():\n    try:\n        # Retrieve folder information from session\n        folder_id = session.get(\"folder_id\")\n        if not folder_id:\n            return \"Folder ID not found in session\", 400",
        "detail": "app.routes.quiz_views.adaptive_questions",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "app.routes.quiz_views.adaptive_questions",
        "description": "app.routes.quiz_views.adaptive_questions",
        "peekOfCode": "logger = get_logger(__name__)\n@adaptive_quiz_bp.route(\"/quiz_overview/_adaptive\", methods=['GET', 'POST'])\ndef render_adaptive_quiz():\n    try:\n        # Retrieve folder information from session\n        folder_id = session.get(\"folder_id\")\n        if not folder_id:\n            return \"Folder ID not found in session\", 400\n        folder_name, full_files_data = retrieve_files_folder(folder_id)\n        # Create a temporary directory to handle file processing",
        "detail": "app.routes.quiz_views.adaptive_questions",
        "documentation": {}
    },
    {
        "label": "render_non_adaptive_quiz",
        "kind": 2,
        "importPath": "app.routes.quiz_views.nonadaptive_questions",
        "description": "app.routes.quiz_views.nonadaptive_questions",
        "peekOfCode": "def render_non_adaptive_quiz():\n    try:\n        # Retrieve folder information from session\n        folder_id = session.get(\"folder_id\")\n        if not folder_id:\n            return \"Folder ID not found in session\", 400\n        folder_name, full_files_data = retrieve_files_folder(folder_id)\n        # Create a temporary directory to handle file processing\n        with tempfile.TemporaryDirectory() as tmpdir:\n            for file in full_files_data:",
        "detail": "app.routes.quiz_views.nonadaptive_questions",
        "documentation": {}
    },
    {
        "label": "non_adaptive_quiz_bp",
        "kind": 5,
        "importPath": "app.routes.quiz_views.nonadaptive_questions",
        "description": "app.routes.quiz_views.nonadaptive_questions",
        "peekOfCode": "non_adaptive_quiz_bp = Blueprint('non_adaptive_quiz_bp', __name__)\n# Initialize logger\nlogger = get_logger(__name__)\n@non_adaptive_quiz_bp.route(\"/quiz_overview/non_adaptive\", methods=['GET', 'POST'])\ndef render_non_adaptive_quiz():\n    try:\n        # Retrieve folder information from session\n        folder_id = session.get(\"folder_id\")\n        if not folder_id:\n            return \"Folder ID not found in session\", 400",
        "detail": "app.routes.quiz_views.nonadaptive_questions",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "app.routes.quiz_views.nonadaptive_questions",
        "description": "app.routes.quiz_views.nonadaptive_questions",
        "peekOfCode": "logger = get_logger(__name__)\n@non_adaptive_quiz_bp.route(\"/quiz_overview/non_adaptive\", methods=['GET', 'POST'])\ndef render_non_adaptive_quiz():\n    try:\n        # Retrieve folder information from session\n        folder_id = session.get(\"folder_id\")\n        if not folder_id:\n            return \"Folder ID not found in session\", 400\n        folder_name, full_files_data = retrieve_files_folder(folder_id)\n        # Create a temporary directory to handle file processing",
        "detail": "app.routes.quiz_views.nonadaptive_questions",
        "documentation": {}
    },
    {
        "label": "modules_action",
        "kind": 2,
        "importPath": "app.routes.quiz_views.quiz_overview",
        "description": "app.routes.quiz_views.quiz_overview",
        "peekOfCode": "def modules_action(folder_id):\n    folder = Folder.query.filter_by(id=folder_id).first_or_404(description=\"Quiz Not Found\")\n    session[\"folder_id\"] = folder.id\n    return render_template('module_actions.html',folder=folder)\n@quiz_overview_bp.route('/edit_code/<int:fileid>', methods=['GET', 'POST'])\ndef edit_code(fileid):\n    # Retrieve the file from the database using its ID\n    file = File.query.filter_by(id=fileid).first_or_404(description=\"File Not Found\")\n    session[\"fileid\"] = file.id\n    code_content = file.content.decode('utf-8')",
        "detail": "app.routes.quiz_views.quiz_overview",
        "documentation": {}
    },
    {
        "label": "edit_code",
        "kind": 2,
        "importPath": "app.routes.quiz_views.quiz_overview",
        "description": "app.routes.quiz_views.quiz_overview",
        "peekOfCode": "def edit_code(fileid):\n    # Retrieve the file from the database using its ID\n    file = File.query.filter_by(id=fileid).first_or_404(description=\"File Not Found\")\n    session[\"fileid\"] = file.id\n    code_content = file.content.decode('utf-8')\n    language_map = {\n        \"py\":\"python\",\n        \"js\":\"javascript\",\n        \"html\":\"html\"\n    }",
        "detail": "app.routes.quiz_views.quiz_overview",
        "documentation": {}
    },
    {
        "label": "save_code",
        "kind": 2,
        "importPath": "app.routes.quiz_views.quiz_overview",
        "description": "app.routes.quiz_views.quiz_overview",
        "peekOfCode": "def save_code():\n    data = request.get_json()\n    updated_code = data.get('code')\n    fileid = session.get(\"fileid\",\"\")\n    old_file = File.query.filter_by(id=fileid).first_or_404(description=\"File Not Found\")\n    old_file.content = updated_code.encode('utf-8')\n    db.session.commit()\n    flash('Code saved successfully!', 'success')\n    return redirect(url_for('quiz_overview_bp.edit_code', fileid=fileid))\n# All This needs to be fixed eventually with databases and the info.json file ",
        "detail": "app.routes.quiz_views.quiz_overview",
        "documentation": {}
    },
    {
        "label": "determine_file_type",
        "kind": 2,
        "importPath": "app.routes.quiz_views.quiz_overview",
        "description": "app.routes.quiz_views.quiz_overview",
        "peekOfCode": "def determine_file_type(file_names:dict)->str:\n    adaptive_files = {'question.html', 'server.js', 'server.py', 'solution.html', 'info.json'}\n    nonadaptive_files = {'question.html', 'info.json'}\n    if file_names == nonadaptive_files:\n        return \"NonAdaptive\"\n    elif file_names == adaptive_files:\n        return \"Adaptive\"\n    else:\n        return \"Lecture\"\n@quiz_overview_bp.route('/quiz_overview/<int:folder_id>', methods=['GET', 'POST'])",
        "detail": "app.routes.quiz_views.quiz_overview",
        "documentation": {}
    },
    {
        "label": "render_content",
        "kind": 2,
        "importPath": "app.routes.quiz_views.quiz_overview",
        "description": "app.routes.quiz_views.quiz_overview",
        "peekOfCode": "def render_content(folder_id):\n    # Retrieve the folder\n    folder = Folder.query.filter_by(id=folder_id).first_or_404(description=\"Quiz Not Found\")\n    # Try to retrieve the metadata file and lecture file\n    metadata_file = File.query.filter_by(folder_id=folder_id, filename=\"info.json\").first()\n    lecture_file = File.query.filter_by(folder_id=folder_id, filename=\"lecture.html\").first()\n    # Case 1: Adaptive/Non-Adaptive Content based on metadata\n    if metadata_file:\n        # Load the metadata content\n        metadata = json.loads(metadata_file.content.decode('utf-8'))",
        "detail": "app.routes.quiz_views.quiz_overview",
        "documentation": {}
    },
    {
        "label": "download_module",
        "kind": 2,
        "importPath": "app.routes.quiz_views.quiz_overview",
        "description": "app.routes.quiz_views.quiz_overview",
        "peekOfCode": "def download_module():\n    folder_id = session[\"folder_id\"]\n    print(folder_id)\n    folder_name, full_files_data = retrieve_files_folder(folder_id)\n    tempfile_paths = []\n    with tempfile.TemporaryDirectory() as tmpdir:\n        for file in full_files_data:\n            tempfile_path = os.path.join(tmpdir, file.get(\"filename\"))\n            content = file.get(\"content\", \"\")\n            # Ensure the content is in bytes, encoding if necessary",
        "detail": "app.routes.quiz_views.quiz_overview",
        "documentation": {}
    },
    {
        "label": "download_all_modules",
        "kind": 2,
        "importPath": "app.routes.quiz_views.quiz_overview",
        "description": "app.routes.quiz_views.quiz_overview",
        "peekOfCode": "def download_all_modules():\n    \"\"\"\n    Downloads a combined ZIP file containing ZIP files for all modules and folders in the session.\n    The function retrieves folder data from the session, processes each folder to create individual ZIP files, \n    and then combines these ZIP files into a single downloadable ZIP file.\n    Returns:\n        Response: A Flask response object that triggers the download of the combined ZIP file.\n    \"\"\"\n    folder_data = session.get(\"folder_data\", [])\n    print(\"Downloading all\")",
        "detail": "app.routes.quiz_views.quiz_overview",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "app.routes.quiz_views.quiz_overview",
        "description": "app.routes.quiz_views.quiz_overview",
        "peekOfCode": "logger = get_logger(__name__)\n# Local Application Imports\nfrom ...db_models.models import File, EduModule, Folder, db\nfrom .utils import retrieve_files_session, retrieve_files_folder\nfrom src.utils.file_handler import create_zip_file\nfrom ...form.forms import UPDATE_CODE\nquiz_overview_bp = Blueprint('quiz_overview_bp', __name__)\n# This is perfect as is \n@quiz_overview_bp.route(\"/quiz_overview/<folder_id>/actions\", methods=['GET', 'POST'])\ndef modules_action(folder_id):",
        "detail": "app.routes.quiz_views.quiz_overview",
        "documentation": {}
    },
    {
        "label": "quiz_overview_bp",
        "kind": 5,
        "importPath": "app.routes.quiz_views.quiz_overview",
        "description": "app.routes.quiz_views.quiz_overview",
        "peekOfCode": "quiz_overview_bp = Blueprint('quiz_overview_bp', __name__)\n# This is perfect as is \n@quiz_overview_bp.route(\"/quiz_overview/<folder_id>/actions\", methods=['GET', 'POST'])\ndef modules_action(folder_id):\n    folder = Folder.query.filter_by(id=folder_id).first_or_404(description=\"Quiz Not Found\")\n    session[\"folder_id\"] = folder.id\n    return render_template('module_actions.html',folder=folder)\n@quiz_overview_bp.route('/edit_code/<int:fileid>', methods=['GET', 'POST'])\ndef edit_code(fileid):\n    # Retrieve the file from the database using its ID",
        "detail": "app.routes.quiz_views.quiz_overview",
        "documentation": {}
    },
    {
        "label": "retrieve_files_session",
        "kind": 2,
        "importPath": "app.routes.quiz_views.utils",
        "description": "app.routes.quiz_views.utils",
        "peekOfCode": "def retrieve_files_session(module_name: str, folder_name: str, folder_id: int) -> Union[List[Dict[str, str]], tuple]:\n    \"\"\"\n    Retrieves file data from the session and filters it based on the folder content.\n    This function fetches the file data stored in the user's session. If the session does not contain\n    the expected data, it returns an error message and a 404 status code. The function then retrieves\n    the corresponding folder from the database, decodes the content of the files (assuming they are stored \n    as binary), and returns a list of dictionaries containing the filenames and their respective content.\n    Args:\n        module_name (str): The name of the module to which the files belong.\n        folder_name (str): The name of the folder containing the files.",
        "detail": "app.routes.quiz_views.utils",
        "documentation": {}
    },
    {
        "label": "retrieve_files_folder",
        "kind": 2,
        "importPath": "app.routes.quiz_views.utils",
        "description": "app.routes.quiz_views.utils",
        "peekOfCode": "def retrieve_files_folder(folder_id: int) -> Union[Tuple[str, List[Dict[str, str]]], str]:\n    \"\"\"\n    Retrieve the name of the current folder and its associated files from the database.\n    This function retrieves the folder ID from the current session, fetches the corresponding\n    folder from the database, and returns the folder's name along with the list of files contained\n    within the folder. Each file's data includes the filename and the content decoded as a UTF-8 string.\n    Returns:\n        Union[Tuple[str, List[Dict[str, str]]], str]: \n            - If successful, returns a tuple containing:\n                - folder_name (str): The name of the folder.",
        "detail": "app.routes.quiz_views.utils",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "src.data.data_analysis",
        "description": "src.data.data_analysis",
        "peekOfCode": "path = r\"C:\\Users\\lberm\\OneDrive\\Desktop\\GitHub_Repository\\mechedu\\website\\quizzes\"\ndata = []\nfor root, dirs, files in os.walk(path):\n    question_data ={}\n    for file in files:\n        if file ==\"question.html\":\n            full_path = os.path.join(root,file)\n            with open(full_path,\"rb\") as f:\n                content = f.read()\n                question_data[\"question.html\"] = content.decode(\"utf-8\")",
        "detail": "src.data.data_analysis",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "src.data.data_analysis",
        "description": "src.data.data_analysis",
        "peekOfCode": "data = []\nfor root, dirs, files in os.walk(path):\n    question_data ={}\n    for file in files:\n        if file ==\"question.html\":\n            full_path = os.path.join(root,file)\n            with open(full_path,\"rb\") as f:\n                content = f.read()\n                question_data[\"question.html\"] = content.decode(\"utf-8\")\n                data.append(question_data)",
        "detail": "src.data.data_analysis",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "src.data.data_analysis",
        "description": "src.data.data_analysis",
        "peekOfCode": "df = pd.DataFrame(data)\nprint(df.head())",
        "detail": "src.data.data_analysis",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "src.data.data_fix",
        "description": "src.data.data_fix",
        "peekOfCode": "df = pd.read_csv(r\"C:\\Users\\lberm\\OneDrive\\Desktop\\GitHub_Repository\\mechedu1.0\\mechedu1\\src\\data\\Question_Embedding_20240128.csv\")\nprint(type(json.loads(df[\"info.json\"][0])))\nprint(df.head())\ndf['info_dict'] = df['info.json'].apply(json.loads)\nprint(df.head())\nnormalized_df = pd.json_normalize(df['info_dict'])\nprint(normalized_df.head())\ndf = df.drop(['info.json', 'info_dict'], axis=1).join(normalized_df)\nprint((df[\"isAdaptive\"] == \"false\").sum())\ndf.to_csv(\"Question_embedding_20240902.csv\")",
        "detail": "src.data.data_fix",
        "documentation": {}
    },
    {
        "label": "df['info_dict']",
        "kind": 5,
        "importPath": "src.data.data_fix",
        "description": "src.data.data_fix",
        "peekOfCode": "df['info_dict'] = df['info.json'].apply(json.loads)\nprint(df.head())\nnormalized_df = pd.json_normalize(df['info_dict'])\nprint(normalized_df.head())\ndf = df.drop(['info.json', 'info_dict'], axis=1).join(normalized_df)\nprint((df[\"isAdaptive\"] == \"false\").sum())\ndf.to_csv(\"Question_embedding_20240902.csv\")",
        "detail": "src.data.data_fix",
        "documentation": {}
    },
    {
        "label": "normalized_df",
        "kind": 5,
        "importPath": "src.data.data_fix",
        "description": "src.data.data_fix",
        "peekOfCode": "normalized_df = pd.json_normalize(df['info_dict'])\nprint(normalized_df.head())\ndf = df.drop(['info.json', 'info_dict'], axis=1).join(normalized_df)\nprint((df[\"isAdaptive\"] == \"false\").sum())\ndf.to_csv(\"Question_embedding_20240902.csv\")",
        "detail": "src.data.data_fix",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "src.data.data_fix",
        "description": "src.data.data_fix",
        "peekOfCode": "df = df.drop(['info.json', 'info_dict'], axis=1).join(normalized_df)\nprint((df[\"isAdaptive\"] == \"false\").sum())\ndf.to_csv(\"Question_embedding_20240902.csv\")",
        "detail": "src.data.data_fix",
        "documentation": {}
    },
    {
        "label": "csv_path",
        "kind": 5,
        "importPath": "src.data.generate_embeddings_dataset",
        "description": "src.data.generate_embeddings_dataset",
        "peekOfCode": "csv_path = r\"src\\data\\question_embeddings_2024_9_11.csv\"\ndf = pd.read_csv(csv_path)\nfiltered_df= df.iloc[0]\nprint(df.columns)\nprint(df[\"question_embedding\"].iloc[:5])\nprint(df[\"embeddings-3-small\"].iloc[:5])\nprint(df.iloc[0][\"question\"])\nembedding_gen = GenerateEmbeddings(api_key,model=\"text-embedding-3-small\",temperature=0)\nprint(embedding_gen.get_embeddings_sync(df.iloc[0][\"question\"]))",
        "detail": "src.data.generate_embeddings_dataset",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "src.data.generate_embeddings_dataset",
        "description": "src.data.generate_embeddings_dataset",
        "peekOfCode": "df = pd.read_csv(csv_path)\nfiltered_df= df.iloc[0]\nprint(df.columns)\nprint(df[\"question_embedding\"].iloc[:5])\nprint(df[\"embeddings-3-small\"].iloc[:5])\nprint(df.iloc[0][\"question\"])\nembedding_gen = GenerateEmbeddings(api_key,model=\"text-embedding-3-small\",temperature=0)\nprint(embedding_gen.get_embeddings_sync(df.iloc[0][\"question\"]))",
        "detail": "src.data.generate_embeddings_dataset",
        "documentation": {}
    },
    {
        "label": "embedding_gen",
        "kind": 5,
        "importPath": "src.data.generate_embeddings_dataset",
        "description": "src.data.generate_embeddings_dataset",
        "peekOfCode": "embedding_gen = GenerateEmbeddings(api_key,model=\"text-embedding-3-small\",temperature=0)\nprint(embedding_gen.get_embeddings_sync(df.iloc[0][\"question\"]))",
        "detail": "src.data.generate_embeddings_dataset",
        "documentation": {}
    },
    {
        "label": "EmbeddingDataFrame",
        "kind": 6,
        "importPath": "src.data_handler.embedded_dataframe",
        "description": "src.data_handler.embedded_dataframe",
        "peekOfCode": "class EmbeddingDataFrame:\n    \"\"\"\n    Processes and validates a DataFrame for embedding-based searches.\n    This class is designed to load a CSV file, validate the structure of the DataFrame, \n    and ensure that the specified columns for embedding, input examples, and corresponding \n    outputs are valid. The `validate_dataframe` method checks for the presence of the \n    required columns and handles missing data in the output column.\n    Attributes:\n        csv_path (str): Path to the CSV file to be processed.\n        embedding_column (str): The name of the column containing the embeddings.",
        "detail": "src.data_handler.embedded_dataframe",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.data_handler.embedded_dataframe",
        "description": "src.data_handler.embedded_dataframe",
        "peekOfCode": "def main():\n    base_dir = os.path.dirname(os.path.abspath(__file__))\n    csv_path = os.path.join(base_dir, '..', 'data', 'Question_embedding_20240902.csv')\n    logger.debug(f\"Base directory set to: {base_dir}\")\n    logger.debug(f\"CSV path for question embeddings constructed: {csv_path}\")\n    try:\n        manager = EmbeddingDataFrame(csv_path,\"question_embedding\", \"question\", \"question.html\", filter_condition=(\"isAdaptive\",True))\n        df = manager.validate_dataframe()\n        print(df[\"isAdaptive\"])\n        print(df.head())",
        "detail": "src.data_handler.embedded_dataframe",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.data_handler.embedded_dataframe",
        "description": "src.data_handler.embedded_dataframe",
        "peekOfCode": "logger = get_logger(__name__)\n@dataclass\nclass EmbeddingDataFrame:\n    \"\"\"\n    Processes and validates a DataFrame for embedding-based searches.\n    This class is designed to load a CSV file, validate the structure of the DataFrame, \n    and ensure that the specified columns for embedding, input examples, and corresponding \n    outputs are valid. The `validate_dataframe` method checks for the presence of the \n    required columns and handles missing data in the output column.\n    Attributes:",
        "detail": "src.data_handler.embedded_dataframe",
        "documentation": {}
    },
    {
        "label": "ExampleBasedPromptDataFrame",
        "kind": 6,
        "importPath": "src.data_handler.example_based_prompt_formatter",
        "description": "src.data_handler.example_based_prompt_formatter",
        "peekOfCode": "class ExampleBasedPromptDataFrame:\n    example_input_column: str\n    example_output_column: str\n    api_key: str\n    embedding_engine: str = \"text-embedding-3-small\"\n    embedding_columns: str = \"embeddings-3-small\"\n    embedding_file: str = os.path.join(base_dir, '..', 'data', 'question_embeddings_2024_9_11.csv')\n    df_config: EmbeddingDataFrame = field(init=False)\n    is_adaptive: bool = True\n    llm_config: LLMConfig = field(init=False)",
        "detail": "src.data_handler.example_based_prompt_formatter",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.data_handler.example_based_prompt_formatter",
        "description": "src.data_handler.example_based_prompt_formatter",
        "peekOfCode": "def main():\n    # Define column names\n    search_column = \"question\"\n    output_column = \"question.html\"\n    # Import API key\n    from ..credentials import api_key\n    # Initialize the formatter with the provided API key and column names\n    formatter = ExampleBasedPromptDataFrame(\n        example_input_column=search_column, \n        example_output_column=output_column, ",
        "detail": "src.data_handler.example_based_prompt_formatter",
        "documentation": {}
    },
    {
        "label": "base_dir",
        "kind": 5,
        "importPath": "src.data_handler.example_based_prompt_formatter",
        "description": "src.data_handler.example_based_prompt_formatter",
        "peekOfCode": "base_dir = os.path.dirname(os.path.abspath(__file__))\n@dataclass\nclass ExampleBasedPromptDataFrame:\n    example_input_column: str\n    example_output_column: str\n    api_key: str\n    embedding_engine: str = \"text-embedding-3-small\"\n    embedding_columns: str = \"embeddings-3-small\"\n    embedding_file: str = os.path.join(base_dir, '..', 'data', 'question_embeddings_2024_9_11.csv')\n    df_config: EmbeddingDataFrame = field(init=False)",
        "detail": "src.data_handler.example_based_prompt_formatter",
        "documentation": {}
    },
    {
        "label": "GenerateEmbeddings",
        "kind": 6,
        "importPath": "src.data_handler.generate_embeddings",
        "description": "src.data_handler.generate_embeddings",
        "peekOfCode": "class GenerateEmbeddings(LLMConfig):\n    \"\"\"\n    A class to generate and display embeddings for given text queries using a specified language model.\n    Attributes:\n        llm_config (LLMConfig): Configuration object for the language model, including API key and model name.\n    Methods:\n        get_embeddings_sync(query: str) -> List[float]:\n            Generates embeddings for a given text query using the specified language model.\n        pretty_print_embeddings(queries: List[str], length_embeddings: int = 10) -> None:\n            Generates and prints embeddings for a list of text queries, showing only the first few values ",
        "detail": "src.data_handler.generate_embeddings",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.data_handler.generate_embeddings",
        "description": "src.data_handler.generate_embeddings",
        "peekOfCode": "def main():\n    queries = [\n        \"What is a car?\",\n        \"What is the capital of France?\",\n        \"This is just some text\"\n    ]\n    # Initialize the LLM configuration\n    llm_config = LLMConfig(\n        api_key=api_key,\n        model=\"text-embedding-ada-002\",",
        "detail": "src.data_handler.generate_embeddings",
        "documentation": {}
    },
    {
        "label": "process_embeddings",
        "kind": 2,
        "importPath": "src.data_handler.process_embeddings",
        "description": "src.data_handler.process_embeddings",
        "peekOfCode": "def process_embeddings(df: pd.DataFrame, embedding_column: str) -> pd.DataFrame:\n    \"\"\"Converts embedding column to float values\n    Args:\n        df (pd.DataFrame): DataFrame to be processed\n        embedding_column (str): Name of the question embeddings\n    Raises:\n        ValueError: Error in processing embeddings\n    Returns:\n        pd.DataFrame: DataFrame after being processed\n    \"\"\"",
        "detail": "src.data_handler.process_embeddings",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.data_handler.process_embeddings",
        "description": "src.data_handler.process_embeddings",
        "peekOfCode": "def main() -> None:\n    base_dir = os.path.dirname(os.path.abspath(__file__))\n    csv_path = os.path.join(base_dir, '..', 'data', 'Question_Embedding_20240128.csv')\n    logger.debug(f\"Base directory set to: {base_dir}\")\n    logger.debug(f\"CSV path for question embeddings constructed: {csv_path}\")\n    try:\n        df = pd.read_csv(csv_path)\n        logger.info(f\"Successfully loaded CSV file with {len(df)} records from {csv_path}\")\n    except FileNotFoundError:\n        logger.exception(f\"CSV file not found at {csv_path}\")",
        "detail": "src.data_handler.process_embeddings",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.data_handler.process_embeddings",
        "description": "src.data_handler.process_embeddings",
        "peekOfCode": "logger = get_logger(__name__)\ndef process_embeddings(df: pd.DataFrame, embedding_column: str) -> pd.DataFrame:\n    \"\"\"Converts embedding column to float values\n    Args:\n        df (pd.DataFrame): DataFrame to be processed\n        embedding_column (str): Name of the question embeddings\n    Raises:\n        ValueError: Error in processing embeddings\n    Returns:\n        pd.DataFrame: DataFrame after being processed",
        "detail": "src.data_handler.process_embeddings",
        "documentation": {}
    },
    {
        "label": "SemanticSearchManager",
        "kind": 6,
        "importPath": "src.data_handler.semantic_search",
        "description": "src.data_handler.semantic_search",
        "peekOfCode": "class SemanticSearchManager:\n    \"\"\"\n    A class to manage the configuration, validation, and processing of a DataFrame for semantic search operations.\n    This class handles validating the DataFrame, generating embeddings for input queries, \n    and calculating similarity scores between the query embeddings and the embeddings stored in the DataFrame.\n    Attributes:\n        embedded_dataframe_config (EmbeddingDataFrame): Configuration object containing the DataFrame \n            and information about the relevant columns used in the semantic search.\n        embedding_generator (GenerateEmbeddings): An instance responsible for generating embeddings \n            using a language model.",
        "detail": "src.data_handler.semantic_search",
        "documentation": {}
    },
    {
        "label": "cosine_similarity",
        "kind": 2,
        "importPath": "src.data_handler.semantic_search",
        "description": "src.data_handler.semantic_search",
        "peekOfCode": "def cosine_similarity(a, b):\n    return np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b))\n@dataclass\nclass SemanticSearchManager:\n    \"\"\"\n    A class to manage the configuration, validation, and processing of a DataFrame for semantic search operations.\n    This class handles validating the DataFrame, generating embeddings for input queries, \n    and calculating similarity scores between the query embeddings and the embeddings stored in the DataFrame.\n    Attributes:\n        embedded_dataframe_config (EmbeddingDataFrame): Configuration object containing the DataFrame ",
        "detail": "src.data_handler.semantic_search",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.data_handler.semantic_search",
        "description": "src.data_handler.semantic_search",
        "peekOfCode": "def main():\n    # Set up file paths and column names\n    base_dir = os.path.dirname(os.path.abspath(__file__))\n    csv_path = os.path.join(base_dir, '..', 'data', 'Question_Embedding_20240128.csv')\n    embedding_column = \"question_embedding\"\n    search_column = \"question\"\n    output_column = \"question.html\"\n    # Initialize the DataFrame configuration\n    df_config = EmbeddingDataFrame(csv_path, embedding_column, search_column, output_column)\n    # Initialize the LLM configuration",
        "detail": "src.data_handler.semantic_search",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.data_handler.test_stuff",
        "description": "src.data_handler.test_stuff",
        "peekOfCode": "def main():\n    # Set up the base directory and CSV path\n    base_dir = os.path.dirname(os.path.abspath(__file__))\n    csv_path = os.path.join(base_dir, '..', 'data', 'question_embeddings_2024_9_11.csv')\n    print(f\"CSV Path: {csv_path}\")\n    # List of questions\n    questions = [\n    # Linear Algebra / Matrix Algebra\n    \"I need to generate an online quiz for the following question: Given the system of equations below, solve for the variables \\\\( x \\\\), \\\\( y \\\\), and \\\\( z \\\\) using matrix algebra. \\n\\\\[ \\\\begin{align*} 2x + 3y - z &= 5 \\\\\\\\ x - 4y + 2z &= 3 \\\\\\\\ 3x + y + 4z &= 7 \\\\end{align*} \\\\]\\nWhat HTML elements should I use to allow students to input symbolic values for their solution, ensuring they can submit equations as part of their answer?\",\n    # Eigenvalues and Eigenvectors (Linear Algebra)",
        "detail": "src.data_handler.test_stuff",
        "documentation": {}
    },
    {
        "label": "isvalid_csv",
        "kind": 2,
        "importPath": "src.data_handler.utils",
        "description": "src.data_handler.utils",
        "peekOfCode": "def isvalid_csv(csv_path: str) -> bool:\n    \"\"\"\n    Checks if the given path is a valid CSV file.\n    Parameters:\n    - csv_path (str): The path to the CSV file.\n    Returns:\n    - bool: True if the file exists and is a valid CSV, False otherwise.\n    \"\"\"\n    return os.path.isfile(csv_path)\ndef load_df(csv_path: str) -> pd.DataFrame:",
        "detail": "src.data_handler.utils",
        "documentation": {}
    },
    {
        "label": "load_df",
        "kind": 2,
        "importPath": "src.data_handler.utils",
        "description": "src.data_handler.utils",
        "peekOfCode": "def load_df(csv_path: str) -> pd.DataFrame:\n    \"\"\"\n    Loads a CSV file into a DataFrame if the file is valid.\n    Parameters:\n    - csv_path (str): The path to the CSV file.\n    Returns:\n    - pd.DataFrame: The loaded DataFrame, or None if the file is not valid.\n    \"\"\"\n    if isvalid_csv(csv_path):\n        try:",
        "detail": "src.data_handler.utils",
        "documentation": {}
    },
    {
        "label": "is_valid_column",
        "kind": 2,
        "importPath": "src.data_handler.utils",
        "description": "src.data_handler.utils",
        "peekOfCode": "def is_valid_column(df:pd.DataFrame, column_to_check:str)->bool:\n    \"\"\"Checks to see if column is in dataframe\n    Args:\n        df (pd.DataFrame): dataframe\n        column_to_check (str): column to check \n    Returns:\n        bool: returns true if column in dataframe\n    \"\"\"\n    return (column_to_check in df.columns)\ndef is_valid_columns(df:pd.DataFrame, columns: List[str])-> bool:",
        "detail": "src.data_handler.utils",
        "documentation": {}
    },
    {
        "label": "is_valid_columns",
        "kind": 2,
        "importPath": "src.data_handler.utils",
        "description": "src.data_handler.utils",
        "peekOfCode": "def is_valid_columns(df:pd.DataFrame, columns: List[str])-> bool:\n    invalid_columns = [column for column in columns if not is_valid_column(df, column)]\n    if invalid_columns:\n        print(f\"Columns {[column for column in invalid_columns]} are not valid.\")\n        return False\n    else:\n        return True",
        "detail": "src.data_handler.utils",
        "documentation": {}
    },
    {
        "label": "validate_and_process_csv",
        "kind": 2,
        "importPath": "src.data_handler.validate_process_csv",
        "description": "src.data_handler.validate_process_csv",
        "peekOfCode": "def validate_and_process_csv(csv_path: str, embedding_column: str) -> pd.DataFrame:\n    \"\"\"\n    Validates the CSV file and processes the embedding column.\n    Parameters:\n    - csv_path (str): The path to the CSV file.\n    - embedding_column (str): The name of the column containing embeddings.\n    Returns:\n    - pd.DataFrame: The processed DataFrame with embeddings.\n    Raises:\n    - ValueError: If the CSV file is invalid or processing fails.",
        "detail": "src.data_handler.validate_process_csv",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.data_handler.validate_process_csv",
        "description": "src.data_handler.validate_process_csv",
        "peekOfCode": "def main() -> None:\n    base_dir = os.path.dirname(os.path.abspath(__file__))\n    csv_path = os.path.join(base_dir, '..', 'data', 'Question_Embedding_20240128.csv')\n    logger.debug(f\"Base directory set to: {base_dir}\")\n    logger.debug(f\"CSV path for question embeddings constructed: {csv_path}\")\n    try:\n        df = pd.read_csv(csv_path)\n        logger.info(f\"Successfully loaded CSV file with {len(df)} records from {csv_path}\")\n    except FileNotFoundError:\n        logger.exception(f\"CSV file not found at {csv_path}\")",
        "detail": "src.data_handler.validate_process_csv",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.data_handler.validate_process_csv",
        "description": "src.data_handler.validate_process_csv",
        "peekOfCode": "logger = get_logger(__name__)\ndef validate_and_process_csv(csv_path: str, embedding_column: str) -> pd.DataFrame:\n    \"\"\"\n    Validates the CSV file and processes the embedding column.\n    Parameters:\n    - csv_path (str): The path to the CSV file.\n    - embedding_column (str): The name of the column containing embeddings.\n    Returns:\n    - pd.DataFrame: The processed DataFrame with embeddings.\n    Raises:",
        "detail": "src.data_handler.validate_process_csv",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.llm_content_assembly.assembly",
        "description": "src.llm_content_assembly.assembly",
        "peekOfCode": "logger = get_logger(__name__)\n# User data for module generation\nuser_data = {\n    \"created_by\": \"lberm007@ucr.edu\",\n    \"code_language\": \"javascript\"\n}\nasync def lecture_assembly(paths: List[str], user_data:dict) -> Tuple[str, List[str], int]:\n    \"\"\"\n    Processes lecture files and generates the necessary outputs.\n    Args:",
        "detail": "src.llm_content_assembly.assembly",
        "documentation": {}
    },
    {
        "label": "user_data",
        "kind": 5,
        "importPath": "src.llm_content_assembly.assembly",
        "description": "src.llm_content_assembly.assembly",
        "peekOfCode": "user_data = {\n    \"created_by\": \"lberm007@ucr.edu\",\n    \"code_language\": \"javascript\"\n}\nasync def lecture_assembly(paths: List[str], user_data:dict) -> Tuple[str, List[str], int]:\n    \"\"\"\n    Processes lecture files and generates the necessary outputs.\n    Args:\n        paths (List[str]): List of file or directory paths to process.\n    Returns:",
        "detail": "src.llm_content_assembly.assembly",
        "documentation": {}
    },
    {
        "label": "FileConverter",
        "kind": 6,
        "importPath": "src.llm_content_assembly.file_converter",
        "description": "src.llm_content_assembly.file_converter",
        "peekOfCode": "class FileConverter:\n    def __init__(self):\n        self.manager = TemporaryDirectoryManager()\n        self.temporary_dir = self.manager.get_tempdir()\n    def convert_pdf_to_images(self,pdf_path: str):\n        image_paths = []\n        document = fitz.open(pdf_path)\n        base_name = os.path.basename(pdf_path).replace(\".pdf\", \"\")\n        logger.info(\"Converting PDF to Collection of Images\")\n        for page_number in range(document.page_count):",
        "detail": "src.llm_content_assembly.file_converter",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.llm_content_assembly.file_converter",
        "description": "src.llm_content_assembly.file_converter",
        "peekOfCode": "def main():\n    # Create an instance of BatchFileConverter\n    converter = FileConverter()\n    # Test cases\n    test_cases = [\n        r\"C:\\Users\\lberm\\OneDrive\\Desktop\\GitHub_Repository\\mechedu1.0\\mechedu1\\test_images\\Lecture_01_09.pdf\",\n        # [\"image1.jpg\", \"image2.png\", \"image3.gif\"],\n        [r\"C:\\Users\\lberm\\OneDrive\\Desktop\\GitHub_Repository\\mechedu1.0\\mechedu1\\test_images\\Lecture_01_09.pdf\", r\"C:\\Users\\lberm\\OneDrive\\Desktop\\GitHub_Repository\\mechedu1.0\\mechedu1\\test_images\\Lecture_01_11.pdf\"],\n        # [\"image1.jpg\", \"document.pdf\"],\n        \"unknownfile.xyz\"",
        "detail": "src.llm_content_assembly.file_converter",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.llm_content_assembly.file_converter",
        "description": "src.llm_content_assembly.file_converter",
        "peekOfCode": "logger = get_logger(__name__)\nclass FileConverter:\n    def __init__(self):\n        self.manager = TemporaryDirectoryManager()\n        self.temporary_dir = self.manager.get_tempdir()\n    def convert_pdf_to_images(self,pdf_path: str):\n        image_paths = []\n        document = fitz.open(pdf_path)\n        base_name = os.path.basename(pdf_path).replace(\".pdf\", \"\")\n        logger.info(\"Converting PDF to Collection of Images\")",
        "detail": "src.llm_content_assembly.file_converter",
        "documentation": {}
    },
    {
        "label": "prepare_additional_instructions",
        "kind": 2,
        "importPath": "src.llm_content_assembly.generate_adaptive_module",
        "description": "src.llm_content_assembly.generate_adaptive_module",
        "peekOfCode": "def prepare_additional_instructions(solution_guide: Optional[str] = None,analyzed_question:Optional[str]=None) -> Optional[str]:\n    \"\"\"\n    Prepares additional instructions based on the solution guide.\n    Args:\n        solution_guide (Optional[str], optional): Instructions for solution improvement. Defaults to None.\n    Returns:\n        Optional[str]: Formatted additional instructions or None.\n    \"\"\"\n    instructions = \"\"\n    if solution_guide:",
        "detail": "src.llm_content_assembly.generate_adaptive_module",
        "documentation": {}
    },
    {
        "label": "calculate_total_tokens",
        "kind": 2,
        "importPath": "src.llm_content_assembly.generate_adaptive_module",
        "description": "src.llm_content_assembly.generate_adaptive_module",
        "peekOfCode": "def calculate_total_tokens() -> int:\n    \"\"\"\n    Calculates the total number of tokens used across all generators.\n    Returns:\n        int: The total number of tokens used.\n    \"\"\"\n    try:\n        logger.info(\"Calculating total tokens used across all generators.\")\n        question_html_tokens = module_generator.question_html_generator.get_total_tokens()\n        server_js_tokens = module_generator.server_js_generator.get_total_tokens()",
        "detail": "src.llm_content_assembly.generate_adaptive_module",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.llm_content_assembly.generate_adaptive_module",
        "description": "src.llm_content_assembly.generate_adaptive_module",
        "peekOfCode": "logger = get_logger(__name__)\nasync def generate_question_html(question_instructions: str) -> str:\n    \"\"\"\n    Generates HTML content for the given question instructions.\n    Args:\n        question_instructions (str): Instructions for generating question HTML.\n    Returns:\n        str: Generated question HTML.\n    \"\"\"\n    logger.info(\"Generating question HTML...\")",
        "detail": "src.llm_content_assembly.generate_adaptive_module",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.llm_content_assembly.generate_module",
        "description": "src.llm_content_assembly.generate_module",
        "peekOfCode": "logger = get_logger(__name__)\nTOKEN_COUNT = 0\nfrom typing import Dict, Optional, Tuple\nasync def generate_module_from_question(\n    question: str, \n    user_data: Dict[str, str], \n    solution_guide: Optional[str] = None\n) -> Dict[str, Union[str, int]]:\n    \"\"\"\n    Generates a module from a given question by first generating metadata,",
        "detail": "src.llm_content_assembly.generate_module",
        "documentation": {}
    },
    {
        "label": "TOKEN_COUNT",
        "kind": 5,
        "importPath": "src.llm_content_assembly.generate_module",
        "description": "src.llm_content_assembly.generate_module",
        "peekOfCode": "TOKEN_COUNT = 0\nfrom typing import Dict, Optional, Tuple\nasync def generate_module_from_question(\n    question: str, \n    user_data: Dict[str, str], \n    solution_guide: Optional[str] = None\n) -> Dict[str, Union[str, int]]:\n    \"\"\"\n    Generates a module from a given question by first generating metadata,\n    then determining if the question is adaptive or non-adaptive to generate",
        "detail": "src.llm_content_assembly.generate_module",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.llm_content_assembly.generate_module_metadata",
        "description": "src.llm_content_assembly.generate_module_metadata",
        "peekOfCode": "logger = get_logger(__name__)\nasync def generate_module_metadata(question: str, user_data: Dict[str, str]) -> tuple[Dict[str, Union[str, bool, int]], int]:\n    logger.info(\"Generating initial metadata for the question.\")\n    # Generate the initial metadata\n    initial_metadata = await metadata_gen.generate_metadata(question)\n    logger.debug(f\"Initial metadata: {initial_metadata}\")\n    # Create the final metadata dictionary by adding additional fields\n    metadata = {\n        **initial_metadata.get(\"metadata\", {}),\n        \"createdBy\": user_data.get(\"created_by\", \"\"),",
        "detail": "src.llm_content_assembly.generate_module_metadata",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.llm_content_assembly.generate_nonadaptive_module",
        "description": "src.llm_content_assembly.generate_nonadaptive_module",
        "peekOfCode": "logger = get_logger(__name__)\nasync def generate_nonadaptive(question: str, metadata_dict: dict=None) -> dict:\n    \"\"\"Generates a module for questions that do not require code files, \n    such as multiple-choice questions.\n    Args:\n        question (str): Question to be used for module creation.\n        metadata_dict (dict): Metadata to be saved for the question.\n    Returns:\n        dict: A collection of generated content with file names and content.\n    \"\"\"",
        "detail": "src.llm_content_assembly.generate_nonadaptive_module",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.llm_content_assembly.llm_lecture_processor",
        "description": "src.llm_content_assembly.llm_lecture_processor",
        "peekOfCode": "logger = get_logger(__name__)\nTOTAL_TOKENS = 0\nuser_data = {\n    \"created_by\": \"lberm007@ucr.edu\",\n    \"code_language\": \"javascript\"\n}\nasync def extract_summary_and_key_concepts(image_paths: List[str]) -> str:\n    \"\"\"\n    Extracts summary and key concepts from lecture images and generates HTML.\n    Args:",
        "detail": "src.llm_content_assembly.llm_lecture_processor",
        "documentation": {}
    },
    {
        "label": "TOTAL_TOKENS",
        "kind": 5,
        "importPath": "src.llm_content_assembly.llm_lecture_processor",
        "description": "src.llm_content_assembly.llm_lecture_processor",
        "peekOfCode": "TOTAL_TOKENS = 0\nuser_data = {\n    \"created_by\": \"lberm007@ucr.edu\",\n    \"code_language\": \"javascript\"\n}\nasync def extract_summary_and_key_concepts(image_paths: List[str]) -> str:\n    \"\"\"\n    Extracts summary and key concepts from lecture images and generates HTML.\n    Args:\n        image_paths (List[str]): List of paths to the lecture images.",
        "detail": "src.llm_content_assembly.llm_lecture_processor",
        "documentation": {}
    },
    {
        "label": "user_data",
        "kind": 5,
        "importPath": "src.llm_content_assembly.llm_lecture_processor",
        "description": "src.llm_content_assembly.llm_lecture_processor",
        "peekOfCode": "user_data = {\n    \"created_by\": \"lberm007@ucr.edu\",\n    \"code_language\": \"javascript\"\n}\nasync def extract_summary_and_key_concepts(image_paths: List[str]) -> str:\n    \"\"\"\n    Extracts summary and key concepts from lecture images and generates HTML.\n    Args:\n        image_paths (List[str]): List of paths to the lecture images.\n    Returns:",
        "detail": "src.llm_content_assembly.llm_lecture_processor",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.llm_content_assembly.llm_lecture_processor_simple",
        "description": "src.llm_content_assembly.llm_lecture_processor_simple",
        "peekOfCode": "logger = get_logger(__name__)\nTOTAL_TOKENS = 0\nasync def extract_summary_and_key_concepts(image_paths: List[str]) -> str:\n    \"\"\"\n    Extracts summary and key concepts from lecture images and generates HTML.\n    Args:\n        image_paths (List[str]): List of paths to the lecture images.\n    Returns:\n        str: Generated HTML for the summary and key concepts section.\n    \"\"\"",
        "detail": "src.llm_content_assembly.llm_lecture_processor_simple",
        "documentation": {}
    },
    {
        "label": "TOTAL_TOKENS",
        "kind": 5,
        "importPath": "src.llm_content_assembly.llm_lecture_processor_simple",
        "description": "src.llm_content_assembly.llm_lecture_processor_simple",
        "peekOfCode": "TOTAL_TOKENS = 0\nasync def extract_summary_and_key_concepts(image_paths: List[str]) -> str:\n    \"\"\"\n    Extracts summary and key concepts from lecture images and generates HTML.\n    Args:\n        image_paths (List[str]): List of paths to the lecture images.\n    Returns:\n        str: Generated HTML for the summary and key concepts section.\n    \"\"\"\n    global TOTAL_TOKENS",
        "detail": "src.llm_content_assembly.llm_lecture_processor_simple",
        "documentation": {}
    },
    {
        "label": "TemporaryDirectoryManager",
        "kind": 6,
        "importPath": "src.llm_content_assembly.temporary_directory_manager",
        "description": "src.llm_content_assembly.temporary_directory_manager",
        "peekOfCode": "class TemporaryDirectoryManager:\n    def __init__(self):\n        self.tempdir = tempfile.mkdtemp()\n        logger.info(f\"Created Temporary Directory {self.tempdir}\")\n    def get_temp_file_path(self,filename):\n        return os.path.join(self.tempdir,filename)\n    def get_tempdir(self):\n        return self.tempdir\n    def cleanup(self):\n        if os.path.exists(self.tempdir):",
        "detail": "src.llm_content_assembly.temporary_directory_manager",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.llm_content_assembly.temporary_directory_manager",
        "description": "src.llm_content_assembly.temporary_directory_manager",
        "peekOfCode": "def main():\n    manager = TemporaryDirectoryManager()\n    print(manager.get_tempdir())\nif __name__ == \"__main__\":\n    main()",
        "detail": "src.llm_content_assembly.temporary_directory_manager",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.llm_content_assembly.temporary_directory_manager",
        "description": "src.llm_content_assembly.temporary_directory_manager",
        "peekOfCode": "logger = get_logger(__name__)\nclass TemporaryDirectoryManager:\n    def __init__(self):\n        self.tempdir = tempfile.mkdtemp()\n        logger.info(f\"Created Temporary Directory {self.tempdir}\")\n    def get_temp_file_path(self,filename):\n        return os.path.join(self.tempdir,filename)\n    def get_tempdir(self):\n        return self.tempdir\n    def cleanup(self):",
        "detail": "src.llm_content_assembly.temporary_directory_manager",
        "documentation": {}
    },
    {
        "label": "is_adaptive_question",
        "kind": 2,
        "importPath": "src.llm_content_assembly.utils",
        "description": "src.llm_content_assembly.utils",
        "peekOfCode": "def is_adaptive_question(metadata_dict: dict) -> bool:\n    if not isinstance(metadata_dict, dict):\n        raise TypeError(f\"Expected a dictionary, but got {type(metadata_dict).__name__} instead.\")\n    if \"isAdaptive\" not in metadata_dict:\n        raise KeyError(\"Key 'isAdaptive' not found in the dictionary.\")\n    return metadata_dict[\"isAdaptive\"]\ndef extract_question_title(metadata_dict: dict) -> str:\n    if \"title\" not in metadata_dict:\n        raise KeyError(\"Key 'title' not found in the dictionary.\")\n    return metadata_dict.get(\"title\", \"Undefined Title\")",
        "detail": "src.llm_content_assembly.utils",
        "documentation": {}
    },
    {
        "label": "extract_question_title",
        "kind": 2,
        "importPath": "src.llm_content_assembly.utils",
        "description": "src.llm_content_assembly.utils",
        "peekOfCode": "def extract_question_title(metadata_dict: dict) -> str:\n    if \"title\" not in metadata_dict:\n        raise KeyError(\"Key 'title' not found in the dictionary.\")\n    return metadata_dict.get(\"title\", \"Undefined Title\")\ndef is_image_file_extension(file_path: str) -> bool:\n    return file_path.endswith(('.png', '.jpg', '.jpeg'))\ndef is_pdf_file_extension(file_path: str) -> bool:\n    return file_path.endswith(('.pdf'))\ndef convert_pdf_to_images(pdf_path: str, tempdir: str) -> List[str]:\n    image_paths = []",
        "detail": "src.llm_content_assembly.utils",
        "documentation": {}
    },
    {
        "label": "is_image_file_extension",
        "kind": 2,
        "importPath": "src.llm_content_assembly.utils",
        "description": "src.llm_content_assembly.utils",
        "peekOfCode": "def is_image_file_extension(file_path: str) -> bool:\n    return file_path.endswith(('.png', '.jpg', '.jpeg'))\ndef is_pdf_file_extension(file_path: str) -> bool:\n    return file_path.endswith(('.pdf'))\ndef convert_pdf_to_images(pdf_path: str, tempdir: str) -> List[str]:\n    image_paths = []\n    document = fitz.open(pdf_path)\n    base_name = os.path.basename(pdf_path).replace(\".pdf\", \"\")\n    logger.info(\"Converting PDF to Collection of Images\")\n    for page_number in range(document.page_count):",
        "detail": "src.llm_content_assembly.utils",
        "documentation": {}
    },
    {
        "label": "is_pdf_file_extension",
        "kind": 2,
        "importPath": "src.llm_content_assembly.utils",
        "description": "src.llm_content_assembly.utils",
        "peekOfCode": "def is_pdf_file_extension(file_path: str) -> bool:\n    return file_path.endswith(('.pdf'))\ndef convert_pdf_to_images(pdf_path: str, tempdir: str) -> List[str]:\n    image_paths = []\n    document = fitz.open(pdf_path)\n    base_name = os.path.basename(pdf_path).replace(\".pdf\", \"\")\n    logger.info(\"Converting PDF to Collection of Images\")\n    for page_number in range(document.page_count):\n        filename = f\"{base_name}_pg_{page_number + 1}.jpg\"\n        filepath = os.path.join(tempdir, filename)",
        "detail": "src.llm_content_assembly.utils",
        "documentation": {}
    },
    {
        "label": "convert_pdf_to_images",
        "kind": 2,
        "importPath": "src.llm_content_assembly.utils",
        "description": "src.llm_content_assembly.utils",
        "peekOfCode": "def convert_pdf_to_images(pdf_path: str, tempdir: str) -> List[str]:\n    image_paths = []\n    document = fitz.open(pdf_path)\n    base_name = os.path.basename(pdf_path).replace(\".pdf\", \"\")\n    logger.info(\"Converting PDF to Collection of Images\")\n    for page_number in range(document.page_count):\n        filename = f\"{base_name}_pg_{page_number + 1}.jpg\"\n        filepath = os.path.join(tempdir, filename)\n        page = document.load_page(page_number)\n        pix = page.get_pixmap()",
        "detail": "src.llm_content_assembly.utils",
        "documentation": {}
    },
    {
        "label": "convert_pdf_to_images_in_memory",
        "kind": 2,
        "importPath": "src.llm_content_assembly.utils",
        "description": "src.llm_content_assembly.utils",
        "peekOfCode": "def convert_pdf_to_images_in_memory(pdf_path: str) -> List[BytesIO]:\n    \"\"\"\n    Converts each page of a PDF file to an image and returns the images as in-memory BytesIO objects.\n    Args:\n        pdf_path (str): The path to the PDF file.\n    Returns:\n        List[BytesIO]: A list of BytesIO objects containing the image data.\n    \"\"\"\n    image_data_list = []\n    document = fitz.open(pdf_path)",
        "detail": "src.llm_content_assembly.utils",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.llm_content_assembly.utils",
        "description": "src.llm_content_assembly.utils",
        "peekOfCode": "logger = get_logger(__name__)\n# Utility functions\ndef is_adaptive_question(metadata_dict: dict) -> bool:\n    if not isinstance(metadata_dict, dict):\n        raise TypeError(f\"Expected a dictionary, but got {type(metadata_dict).__name__} instead.\")\n    if \"isAdaptive\" not in metadata_dict:\n        raise KeyError(\"Key 'isAdaptive' not found in the dictionary.\")\n    return metadata_dict[\"isAdaptive\"]\ndef extract_question_title(metadata_dict: dict) -> str:\n    if \"title\" not in metadata_dict:",
        "detail": "src.llm_content_assembly.utils",
        "documentation": {}
    },
    {
        "label": "Response",
        "kind": 6,
        "importPath": "src.llm_module_generator.agent.lecture_triaging_agent",
        "description": "src.llm_module_generator.agent.lecture_triaging_agent",
        "peekOfCode": "class Response(BaseModel):\n    functions_call: List[str] = Field(...,description=\"An array of functions to call\")\n    summary: str = Field(\"A consise summary of the content of the content provided \")\n    pages: int = Field(\"A number of pages/slides you were given. This is meant to indicate how much content you were given\")\nagent_schema = Response.model_json_schema()\nlecture_triaging_agent = ImageToLLMProcessor(triaging_system_prompt,agent_schema)\nlecture_triaging_agent_simple = ImageToLLMProcessor(triaging_system_prompt_simple,agent_schema)\nasync def main():\n    try:\n        print(\"Please enter the absolute paths to the image files, separated by commas:\")",
        "detail": "src.llm_module_generator.agent.lecture_triaging_agent",
        "documentation": {}
    },
    {
        "label": "triaging_system_prompt",
        "kind": 5,
        "importPath": "src.llm_module_generator.agent.lecture_triaging_agent",
        "description": "src.llm_module_generator.agent.lecture_triaging_agent",
        "peekOfCode": "triaging_system_prompt = \"\"\"\nYou are responsible for assessing the user's query and analyzing the provided material. Route the query to the appropriate functions based on the content. The available functions are:\n- **extract_summary_and_key_concepts**: This function is typically the default choice and should be used to extract the summary and key concepts when the material is formatted like a lecture. It should be called in most cases where the content is detailed and lecture-like.\n- **conceptual_question_extraction**: This function is also generally a default choice, particularly when **extract_summary_and_key_concepts** is used. It complements the extraction by generating or identifying related conceptual questions. For shorter materials, such as collections of questions, apply the same conditions as for the **computational_question_extraction** function.\n- **extract_derivations**:  This function should be called on a case-by-case basis, specifically when the material includes formal mathematical derivations. A derivation refers to a detailed, step-by-step explanation or proof that shows how a particular mathematical formula, equation, or result is derived. This function is most applicable when dealing with content related to physics or engineering subjects, where such detailed mathematical processes are often presented.\n- **computational_question_extraction**: Like **extract_derivations**, this function is used on a case-by-case basis. It should be called when the material includes problems with solutions, ranging from single to multiple questions.\nIn most scenarios, **extract_summary_and_key_concepts** and **conceptual_question_extraction** are the primary functions to use, while **extract_derivations** and **computational_question_extraction** are more specialized and should be used based on specific content characteristics.\nForward the user's query to the relevant functions using the send_query_to_functions tool based on the material's content and format.\nAdditionally, provide an overall summary of the content you are analyzing. If possible, indicate how many pages or slides were provided and whether the material consists of a single page or multiple pages/slides.\n\"\"\"",
        "detail": "src.llm_module_generator.agent.lecture_triaging_agent",
        "documentation": {}
    },
    {
        "label": "triaging_system_prompt_simple",
        "kind": 5,
        "importPath": "src.llm_module_generator.agent.lecture_triaging_agent",
        "description": "src.llm_module_generator.agent.lecture_triaging_agent",
        "peekOfCode": "triaging_system_prompt_simple = \"\"\"\nYou are responsible for assessing the user's query and analyzing the provided material. Route the query to the appropriate functions based on the content. The available functions are:\n- **extract_summary_and_key_concepts**: This function must always be called to extract the summary and key concepts, especially when the material is formatted like a lecture. It should be used in all cases where the content is detailed and lecture-like, ensuring that the core ideas and concepts are captured.\n- **conceptual_question_extraction**: This function should also always be called, complementing **extract_summary_and_key_concepts** by generating or identifying related conceptual questions. These two functions work together to ensure that the key points and related questions are clearly defined. For shorter materials, such as collections of questions, apply the same conditions as for the **computational_question_extraction** function.\n- **extract_derivations**: This function must be used whenever the material contains any sort of formal proof or mathematical derivation. A derivation refers to a detailed, step-by-step explanation or proof that shows how a particular mathematical formula, equation, or result is derived. It is essential for handling content related to physics, engineering, or other subjects involving detailed mathematical processes.\nIn every scenario, **extract_summary_and_key_concepts** and **conceptual_question_extraction** should always be executed. **extract_derivations** should be used whenever there are any proofs, derivations, or step-by-step mathematical explanations.\nForward the user's query to the relevant functions using the send_query_to_functions tool based on the material's content and format.\nAdditionally, provide an overall summary of the content you are analyzing. If possible, indicate how many pages or slides were provided and whether the material consists of a single page or multiple pages/slides.\n\"\"\"\nclass Response(BaseModel):",
        "detail": "src.llm_module_generator.agent.lecture_triaging_agent",
        "documentation": {}
    },
    {
        "label": "agent_schema",
        "kind": 5,
        "importPath": "src.llm_module_generator.agent.lecture_triaging_agent",
        "description": "src.llm_module_generator.agent.lecture_triaging_agent",
        "peekOfCode": "agent_schema = Response.model_json_schema()\nlecture_triaging_agent = ImageToLLMProcessor(triaging_system_prompt,agent_schema)\nlecture_triaging_agent_simple = ImageToLLMProcessor(triaging_system_prompt_simple,agent_schema)\nasync def main():\n    try:\n        print(\"Please enter the absolute paths to the image files, separated by commas:\")\n        image_paths_input = input()\n        # Split the input into a list of paths\n        image_paths = [path.strip() for path in image_paths_input.split(',')]\n        # Validate each provided path",
        "detail": "src.llm_module_generator.agent.lecture_triaging_agent",
        "documentation": {}
    },
    {
        "label": "lecture_triaging_agent",
        "kind": 5,
        "importPath": "src.llm_module_generator.agent.lecture_triaging_agent",
        "description": "src.llm_module_generator.agent.lecture_triaging_agent",
        "peekOfCode": "lecture_triaging_agent = ImageToLLMProcessor(triaging_system_prompt,agent_schema)\nlecture_triaging_agent_simple = ImageToLLMProcessor(triaging_system_prompt_simple,agent_schema)\nasync def main():\n    try:\n        print(\"Please enter the absolute paths to the image files, separated by commas:\")\n        image_paths_input = input()\n        # Split the input into a list of paths\n        image_paths = [path.strip() for path in image_paths_input.split(',')]\n        # Validate each provided path\n        for image_path in image_paths:",
        "detail": "src.llm_module_generator.agent.lecture_triaging_agent",
        "documentation": {}
    },
    {
        "label": "lecture_triaging_agent_simple",
        "kind": 5,
        "importPath": "src.llm_module_generator.agent.lecture_triaging_agent",
        "description": "src.llm_module_generator.agent.lecture_triaging_agent",
        "peekOfCode": "lecture_triaging_agent_simple = ImageToLLMProcessor(triaging_system_prompt_simple,agent_schema)\nasync def main():\n    try:\n        print(\"Please enter the absolute paths to the image files, separated by commas:\")\n        image_paths_input = input()\n        # Split the input into a list of paths\n        image_paths = [path.strip() for path in image_paths_input.split(',')]\n        # Validate each provided path\n        for image_path in image_paths:\n            if not os.path.isabs(image_path):",
        "detail": "src.llm_module_generator.agent.lecture_triaging_agent",
        "documentation": {}
    },
    {
        "label": "conceptual_question_prompt",
        "kind": 5,
        "importPath": "src.llm_module_generator.image_extraction.image_extraction_prompts",
        "description": "src.llm_module_generator.image_extraction.image_extraction_prompts",
        "peekOfCode": "conceptual_question_prompt = \"\"\"\n    You are tasked with analyzing the following lecture slides covering a specific class topic. Please address the following:\n    1. **Conceptual Questions**: Generate 4 multiple-choice conceptual questions based on the lecture material, each with 4 options. Indicate the correct answer for each question.\n    These questions can either be derived based on the information from the lecture slides or they can be generated by you. If you decide to generate, you need to indicate this in the response as a bool.\n    Always return the sources of where these questions are derived from.\n    Format any mathematical symbols or equations using LaTeX.\n    \"\"\"\nlecture_analysis_prompt =\"\"\"\n    You are tasked with analyzing the following lecture slides covering a specific class topic. Please address the following questions and return the results as a JSON structure with the specified keys:\n    1. **summary**: Provide a comprehensive summary of the lecture material.",
        "detail": "src.llm_module_generator.image_extraction.image_extraction_prompts",
        "documentation": {}
    },
    {
        "label": "extract_derivations_prompt",
        "kind": 5,
        "importPath": "src.llm_module_generator.image_extraction.image_extraction_prompts",
        "description": "src.llm_module_generator.image_extraction.image_extraction_prompts",
        "peekOfCode": "extract_derivations_prompt = \"\"\"\n    You are tasked with analyzing the following lecture slides covering a specific class topic. Please address the following points and return the results as a JSON structure with the specified keys:\n    1. **Derivations**: Extract all derivations found in the lecture material. For each derivation:\n        - Provide a descriptive name that clearly explains what the derivation is trying to demonstrate.\n        - Extract the full solution, including all steps as if explaining to a student. Ensure that any mathematical expressions, symbols, or equations are properly formatted using LaTeX, enclosed within `$` symbols for inline math and `$$` symbols for block-level equations.\n        - Be aware that similar derivations may exist for different cases. These distinctions are often marked by changes in images or unique contexts. Ensure that these derivations are correctly identified and separated.\n        - Indicate the completeness of each derivation. If a derivation appears incomplete, explicitly state this.\n        - If no derivations are found in the material, return \"NaN\".\n\"\"\"\nextract_computation_questions_prompt = \"\"\"",
        "detail": "src.llm_module_generator.image_extraction.image_extraction_prompts",
        "documentation": {}
    },
    {
        "label": "extract_computation_questions_prompt",
        "kind": 5,
        "importPath": "src.llm_module_generator.image_extraction.image_extraction_prompts",
        "description": "src.llm_module_generator.image_extraction.image_extraction_prompts",
        "peekOfCode": "extract_computation_questions_prompt = \"\"\"\nExtract and process the content from the provided image according to these guidelines:\n1. **Question Extraction:**\n   - Extract all the computational questions from the image or lecture material. Ensure that all necessary details, data, and parameters are included to fully understand the question.\n   - Represent any special characters, such as mathematical symbols, in LaTeX format.\n   - Clearly identify and extract the source of the question.\n2. **Solution Steps:**\n   - For each question, provide a detailed solution with step-by-step explanations. Use LaTeX for formatting any mathematical symbols or equations.\n   - Ensure that the solution guide strictly adheres to the symbolic representation requirement, with no numerical values included in the steps.\n3. **Image Requirements:**",
        "detail": "src.llm_module_generator.image_extraction.image_extraction_prompts",
        "documentation": {}
    },
    {
        "label": "LectureSummary",
        "kind": 6,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "class LectureSummary(BaseModel):\n    summary: str = Field(..., description=\"A summary of the lecture material, describing the essence of what the lecture was about. Use LaTeX for any mathematical symbols or equations.\")\n    key_concepts: List[str] = Field(..., description=\"A list of key concepts covered in the lecture. Use LaTeX for any mathematical symbols or equations.\")\n    keywords: List[str] = Field(..., description=\"A list of keywords that describe the lecture. Use LaTeX for any mathematical symbols or equations.\")\n    foundational_concepts: List[str] = Field(..., description=\"A list of prerequisite concepts that the lecture builds upon. Use LaTeX for any mathematical symbols or equations.\")\nclass LectureAnalysis(BaseModel):\n    analysis: LectureSummary = Field(..., description=\"The analysis of the lecture material.\")\nclass Step(BaseModel):\n    explanation: str = Field(..., description=\"An explanation of the step involved in solving the problem, using LaTeX for any mathematical symbols or equations.\")\n    output: str = Field(..., description=\"The output or result of the step, formatted in LaTeX if it includes any mathematical symbols or equations.\")",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "LectureAnalysis",
        "kind": 6,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "class LectureAnalysis(BaseModel):\n    analysis: LectureSummary = Field(..., description=\"The analysis of the lecture material.\")\nclass Step(BaseModel):\n    explanation: str = Field(..., description=\"An explanation of the step involved in solving the problem, using LaTeX for any mathematical symbols or equations.\")\n    output: str = Field(..., description=\"The output or result of the step, formatted in LaTeX if it includes any mathematical symbols or equations.\")\nclass ImageReq(BaseModel):\n    requires_image: bool = Field(..., description=\"Indicate whether the question requires an image to solve.\")\n    image_description: Optional[str] = Field(None, description=\"If the question requires an image to solve, provide a description of the image that is needed.\")\nclass ExternalDataReq(BaseModel):\n    requires_external_data: bool = Field(..., description=\"Indicates whether external data, such as tabular data or charts, is needed to solve the question.\")",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "Step",
        "kind": 6,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "class Step(BaseModel):\n    explanation: str = Field(..., description=\"An explanation of the step involved in solving the problem, using LaTeX for any mathematical symbols or equations.\")\n    output: str = Field(..., description=\"The output or result of the step, formatted in LaTeX if it includes any mathematical symbols or equations.\")\nclass ImageReq(BaseModel):\n    requires_image: bool = Field(..., description=\"Indicate whether the question requires an image to solve.\")\n    image_description: Optional[str] = Field(None, description=\"If the question requires an image to solve, provide a description of the image that is needed.\")\nclass ExternalDataReq(BaseModel):\n    requires_external_data: bool = Field(..., description=\"Indicates whether external data, such as tabular data or charts, is needed to solve the question.\")\n    external_data: Optional[str] = Field(None, description=\"If external data is required, indicate the required data.\")\nclass ComputationalQuestion(BaseModel):",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "ImageReq",
        "kind": 6,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "class ImageReq(BaseModel):\n    requires_image: bool = Field(..., description=\"Indicate whether the question requires an image to solve.\")\n    image_description: Optional[str] = Field(None, description=\"If the question requires an image to solve, provide a description of the image that is needed.\")\nclass ExternalDataReq(BaseModel):\n    requires_external_data: bool = Field(..., description=\"Indicates whether external data, such as tabular data or charts, is needed to solve the question.\")\n    external_data: Optional[str] = Field(None, description=\"If external data is required, indicate the required data.\")\nclass ComputationalQuestion(BaseModel):\n    question: str = Field(..., description=\"A computational question that requires computation. Format any mathematical symbols or equations using LaTeX.\")\n    solution: Optional[List[Step]] = Field(None, description=\"A detailed solution with steps for the computational question, using LaTeX for formatting any mathematical symbols or equations. This field is optional and should be `None` if a solution is not present, particularly if the `complete` field is `false`.\")\n    source: str = Field(..., description=\"The source from which this question is derived.\")",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "ExternalDataReq",
        "kind": 6,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "class ExternalDataReq(BaseModel):\n    requires_external_data: bool = Field(..., description=\"Indicates whether external data, such as tabular data or charts, is needed to solve the question.\")\n    external_data: Optional[str] = Field(None, description=\"If external data is required, indicate the required data.\")\nclass ComputationalQuestion(BaseModel):\n    question: str = Field(..., description=\"A computational question that requires computation. Format any mathematical symbols or equations using LaTeX.\")\n    solution: Optional[List[Step]] = Field(None, description=\"A detailed solution with steps for the computational question, using LaTeX for formatting any mathematical symbols or equations. This field is optional and should be `None` if a solution is not present, particularly if the `complete` field is `false`.\")\n    source: str = Field(..., description=\"The source from which this question is derived.\")\n    complete: bool = Field(..., description=\"Indicates if the computational question is completed with the solutions. If `false`, the `solution` field can be `None`.\")\n    image_req: List[ImageReq] = Field(..., description=\"A list of image requirements for understanding the question, if any.\")\n    external_data_req: ExternalDataReq",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "ComputationalQuestion",
        "kind": 6,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "class ComputationalQuestion(BaseModel):\n    question: str = Field(..., description=\"A computational question that requires computation. Format any mathematical symbols or equations using LaTeX.\")\n    solution: Optional[List[Step]] = Field(None, description=\"A detailed solution with steps for the computational question, using LaTeX for formatting any mathematical symbols or equations. This field is optional and should be `None` if a solution is not present, particularly if the `complete` field is `false`.\")\n    source: str = Field(..., description=\"The source from which this question is derived.\")\n    complete: bool = Field(..., description=\"Indicates if the computational question is completed with the solutions. If `false`, the `solution` field can be `None`.\")\n    image_req: List[ImageReq] = Field(..., description=\"A list of image requirements for understanding the question, if any.\")\n    external_data_req: ExternalDataReq\nclass ExtractedCompuationalQuestions(BaseModel):\n    extracted_question: List[ComputationalQuestion] = Field(...,description=\"A list of all the extracted questions\")\nclass ImageRequirements(BaseModel):",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "ExtractedCompuationalQuestions",
        "kind": 6,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "class ExtractedCompuationalQuestions(BaseModel):\n    extracted_question: List[ComputationalQuestion] = Field(...,description=\"A list of all the extracted questions\")\nclass ImageRequirements(BaseModel):\n    requires_image: str = Field(..., description=\"Indicates if the derivation requires an image to fully understand the derivation. Should be 'True' or 'False'.\")\n    recommended_image: str = Field(..., description=\"If the image is required, provide a recommendation of what the image should depict.\")\nclass SingleDerivation(BaseModel):\n    derivation_name: str = Field(..., description=\"The name of the derivation and what it aims to demonstrate.\")\n    derivation_steps: List[Step] = Field(..., description=\"A list of steps involved in the derivation, each step explained and formatted using LaTeX for mathematical symbols or equations.\")\n    derivation_source: str = Field(..., description=\"The source from which this derivation is derived.\")\n    image_stats: List[ImageRequirements] = Field(..., description=\"A list of image requirements for understanding the derivation, if any.\")",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "ImageRequirements",
        "kind": 6,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "class ImageRequirements(BaseModel):\n    requires_image: str = Field(..., description=\"Indicates if the derivation requires an image to fully understand the derivation. Should be 'True' or 'False'.\")\n    recommended_image: str = Field(..., description=\"If the image is required, provide a recommendation of what the image should depict.\")\nclass SingleDerivation(BaseModel):\n    derivation_name: str = Field(..., description=\"The name of the derivation and what it aims to demonstrate.\")\n    derivation_steps: List[Step] = Field(..., description=\"A list of steps involved in the derivation, each step explained and formatted using LaTeX for mathematical symbols or equations.\")\n    derivation_source: str = Field(..., description=\"The source from which this derivation is derived.\")\n    image_stats: List[ImageRequirements] = Field(..., description=\"A list of image requirements for understanding the derivation, if any.\")\nclass DerivationResponse(BaseModel):\n    derivations: List[SingleDerivation] = Field(..., description=\"A list of derivations, each containing its name, steps, source, and image requirements if applicable.\")",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "SingleDerivation",
        "kind": 6,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "class SingleDerivation(BaseModel):\n    derivation_name: str = Field(..., description=\"The name of the derivation and what it aims to demonstrate.\")\n    derivation_steps: List[Step] = Field(..., description=\"A list of steps involved in the derivation, each step explained and formatted using LaTeX for mathematical symbols or equations.\")\n    derivation_source: str = Field(..., description=\"The source from which this derivation is derived.\")\n    image_stats: List[ImageRequirements] = Field(..., description=\"A list of image requirements for understanding the derivation, if any.\")\nclass DerivationResponse(BaseModel):\n    derivations: List[SingleDerivation] = Field(..., description=\"A list of derivations, each containing its name, steps, source, and image requirements if applicable.\")\nclass ConceptualQuestion(BaseModel):\n    question: str = Field(..., description=\"A conceptual question based on the lecture material that does not require any computation. Format any mathematical symbols or equations using LaTeX.\")\n    multiple_choice_options: List[str] = Field(..., description=\"Four multiple-choice options for the conceptual question. Format any mathematical symbols or equations using LaTeX.\")",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "DerivationResponse",
        "kind": 6,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "class DerivationResponse(BaseModel):\n    derivations: List[SingleDerivation] = Field(..., description=\"A list of derivations, each containing its name, steps, source, and image requirements if applicable.\")\nclass ConceptualQuestion(BaseModel):\n    question: str = Field(..., description=\"A conceptual question based on the lecture material that does not require any computation. Format any mathematical symbols or equations using LaTeX.\")\n    multiple_choice_options: List[str] = Field(..., description=\"Four multiple-choice options for the conceptual question. Format any mathematical symbols or equations using LaTeX.\")\n    correct_answer: str = Field(..., description=\"The correct option from the multiple-choice options. Format any mathematical symbols or equations using LaTeX.\")\n    source: str = Field(..., description=\"The source from which this question is derived.\")\n    generated: bool = Field(..., description=\"Whether the question was generated or extracted from the lecture material.\")\nclass Questions(BaseModel):\n    questions: List[ConceptualQuestion] = Field(..., description=\"A list of conceptual questions based on the lecture material.\")",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "ConceptualQuestion",
        "kind": 6,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "class ConceptualQuestion(BaseModel):\n    question: str = Field(..., description=\"A conceptual question based on the lecture material that does not require any computation. Format any mathematical symbols or equations using LaTeX.\")\n    multiple_choice_options: List[str] = Field(..., description=\"Four multiple-choice options for the conceptual question. Format any mathematical symbols or equations using LaTeX.\")\n    correct_answer: str = Field(..., description=\"The correct option from the multiple-choice options. Format any mathematical symbols or equations using LaTeX.\")\n    source: str = Field(..., description=\"The source from which this question is derived.\")\n    generated: bool = Field(..., description=\"Whether the question was generated or extracted from the lecture material.\")\nclass Questions(BaseModel):\n    questions: List[ConceptualQuestion] = Field(..., description=\"A list of conceptual questions based on the lecture material.\")\n# Define the JSON schemas\nlecture_schema = LectureAnalysis.model_json_schema()",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "Questions",
        "kind": 6,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "class Questions(BaseModel):\n    questions: List[ConceptualQuestion] = Field(..., description=\"A list of conceptual questions based on the lecture material.\")\n# Define the JSON schemas\nlecture_schema = LectureAnalysis.model_json_schema()\ncomputational_schema = ExtractedCompuationalQuestions.model_json_schema()\nderivation_schema = DerivationResponse.model_json_schema()\nconceputual_question_schema = Questions.model_json_schema()\n## Define all the extractors\nextract_summary = ImageToLLMProcessor(prompt=lecture_analysis_prompt,response_schema=lecture_schema)\nextract_computational_questions = ImageToLLMProcessor(prompt=extract_computation_questions_prompt,response_schema=computational_schema)",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "lecture_schema",
        "kind": 5,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "lecture_schema = LectureAnalysis.model_json_schema()\ncomputational_schema = ExtractedCompuationalQuestions.model_json_schema()\nderivation_schema = DerivationResponse.model_json_schema()\nconceputual_question_schema = Questions.model_json_schema()\n## Define all the extractors\nextract_summary = ImageToLLMProcessor(prompt=lecture_analysis_prompt,response_schema=lecture_schema)\nextract_computational_questions = ImageToLLMProcessor(prompt=extract_computation_questions_prompt,response_schema=computational_schema)\nextract_derivations = ImageToLLMProcessor(prompt = extract_derivations_prompt, response_schema = derivation_schema)\nextract_conceptual_questions = ImageToLLMProcessor(prompt = conceptual_question_prompt, response_schema = conceputual_question_schema)\nasync def process_with_extractor(extractor: ImageToLLMProcessor, image_paths: List[str]) -> dict:",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "computational_schema",
        "kind": 5,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "computational_schema = ExtractedCompuationalQuestions.model_json_schema()\nderivation_schema = DerivationResponse.model_json_schema()\nconceputual_question_schema = Questions.model_json_schema()\n## Define all the extractors\nextract_summary = ImageToLLMProcessor(prompt=lecture_analysis_prompt,response_schema=lecture_schema)\nextract_computational_questions = ImageToLLMProcessor(prompt=extract_computation_questions_prompt,response_schema=computational_schema)\nextract_derivations = ImageToLLMProcessor(prompt = extract_derivations_prompt, response_schema = derivation_schema)\nextract_conceptual_questions = ImageToLLMProcessor(prompt = conceptual_question_prompt, response_schema = conceputual_question_schema)\nasync def process_with_extractor(extractor: ImageToLLMProcessor, image_paths: List[str]) -> dict:\n    \"\"\"",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "derivation_schema",
        "kind": 5,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "derivation_schema = DerivationResponse.model_json_schema()\nconceputual_question_schema = Questions.model_json_schema()\n## Define all the extractors\nextract_summary = ImageToLLMProcessor(prompt=lecture_analysis_prompt,response_schema=lecture_schema)\nextract_computational_questions = ImageToLLMProcessor(prompt=extract_computation_questions_prompt,response_schema=computational_schema)\nextract_derivations = ImageToLLMProcessor(prompt = extract_derivations_prompt, response_schema = derivation_schema)\nextract_conceptual_questions = ImageToLLMProcessor(prompt = conceptual_question_prompt, response_schema = conceputual_question_schema)\nasync def process_with_extractor(extractor: ImageToLLMProcessor, image_paths: List[str]) -> dict:\n    \"\"\"\n    Process the images using the specified extractor and return the structured response.",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "conceputual_question_schema",
        "kind": 5,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "conceputual_question_schema = Questions.model_json_schema()\n## Define all the extractors\nextract_summary = ImageToLLMProcessor(prompt=lecture_analysis_prompt,response_schema=lecture_schema)\nextract_computational_questions = ImageToLLMProcessor(prompt=extract_computation_questions_prompt,response_schema=computational_schema)\nextract_derivations = ImageToLLMProcessor(prompt = extract_derivations_prompt, response_schema = derivation_schema)\nextract_conceptual_questions = ImageToLLMProcessor(prompt = conceptual_question_prompt, response_schema = conceputual_question_schema)\nasync def process_with_extractor(extractor: ImageToLLMProcessor, image_paths: List[str]) -> dict:\n    \"\"\"\n    Process the images using the specified extractor and return the structured response.\n    Args:",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "extract_summary",
        "kind": 5,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "extract_summary = ImageToLLMProcessor(prompt=lecture_analysis_prompt,response_schema=lecture_schema)\nextract_computational_questions = ImageToLLMProcessor(prompt=extract_computation_questions_prompt,response_schema=computational_schema)\nextract_derivations = ImageToLLMProcessor(prompt = extract_derivations_prompt, response_schema = derivation_schema)\nextract_conceptual_questions = ImageToLLMProcessor(prompt = conceptual_question_prompt, response_schema = conceputual_question_schema)\nasync def process_with_extractor(extractor: ImageToLLMProcessor, image_paths: List[str]) -> dict:\n    \"\"\"\n    Process the images using the specified extractor and return the structured response.\n    Args:\n        extractor (ImageToLLMProcessor): The extractor instance to process the images.\n        image_paths (List[str]): A list of paths to the images to be processed.",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "extract_computational_questions",
        "kind": 5,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "extract_computational_questions = ImageToLLMProcessor(prompt=extract_computation_questions_prompt,response_schema=computational_schema)\nextract_derivations = ImageToLLMProcessor(prompt = extract_derivations_prompt, response_schema = derivation_schema)\nextract_conceptual_questions = ImageToLLMProcessor(prompt = conceptual_question_prompt, response_schema = conceputual_question_schema)\nasync def process_with_extractor(extractor: ImageToLLMProcessor, image_paths: List[str]) -> dict:\n    \"\"\"\n    Process the images using the specified extractor and return the structured response.\n    Args:\n        extractor (ImageToLLMProcessor): The extractor instance to process the images.\n        image_paths (List[str]): A list of paths to the images to be processed.\n        prompt (str): The prompt to send along with the images.",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "extract_derivations",
        "kind": 5,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "extract_derivations = ImageToLLMProcessor(prompt = extract_derivations_prompt, response_schema = derivation_schema)\nextract_conceptual_questions = ImageToLLMProcessor(prompt = conceptual_question_prompt, response_schema = conceputual_question_schema)\nasync def process_with_extractor(extractor: ImageToLLMProcessor, image_paths: List[str]) -> dict:\n    \"\"\"\n    Process the images using the specified extractor and return the structured response.\n    Args:\n        extractor (ImageToLLMProcessor): The extractor instance to process the images.\n        image_paths (List[str]): A list of paths to the images to be processed.\n        prompt (str): The prompt to send along with the images.\n    Returns:",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "extract_conceptual_questions",
        "kind": 5,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "description": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "peekOfCode": "extract_conceptual_questions = ImageToLLMProcessor(prompt = conceptual_question_prompt, response_schema = conceputual_question_schema)\nasync def process_with_extractor(extractor: ImageToLLMProcessor, image_paths: List[str]) -> dict:\n    \"\"\"\n    Process the images using the specified extractor and return the structured response.\n    Args:\n        extractor (ImageToLLMProcessor): The extractor instance to process the images.\n        image_paths (List[str]): A list of paths to the images to be processed.\n        prompt (str): The prompt to send along with the images.\n    Returns:\n        dict: The structured response obtained from the images.",
        "detail": "src.llm_module_generator.image_extraction.image_llm_extraction",
        "documentation": {}
    },
    {
        "label": "ImageToLLMProcessor",
        "kind": 6,
        "importPath": "src.llm_module_generator.image_extraction.image_llm_processor",
        "description": "src.llm_module_generator.image_extraction.image_llm_processor",
        "peekOfCode": "class ImageToLLMProcessor:\n    \"\"\"\n    A class responsible for processing images and interacting with an LLM.\n    Attributes\n        total_tokens (int): The total number of tokens used in LLM responses.\n    \"\"\"\n    prompt:str \n    response_schema:str \n    total_tokens: int = field(default=0, init=False)\n    def __post_init__(self):",
        "detail": "src.llm_module_generator.image_extraction.image_llm_processor",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.llm_module_generator.image_extraction.send_image_request",
        "description": "src.llm_module_generator.image_extraction.send_image_request",
        "peekOfCode": "logger = get_logger(__name__)\nasync def create_image_content_payload(image_paths: List[str]) -> List[dict]:\n    \"\"\"\n    Encodes images to base64 and creates a content payload for each image.\n    Args:\n        image_paths (List[str]): A list of file paths for the images to encode.\n    Returns:\n        List[dict]: A list of dictionaries, each representing an image content payload.\n    \"\"\"\n    images = await encode_multiple_images(image_paths)",
        "detail": "src.llm_module_generator.image_extraction.send_image_request",
        "documentation": {}
    },
    {
        "label": "LLM_Call",
        "kind": 6,
        "importPath": "src.llm_module_generator.llm_base.llm_call",
        "description": "src.llm_module_generator.llm_base.llm_call",
        "peekOfCode": "class LLM_Call():\n    llm_config: LLMConfig\n    total_tokens: int = field(default=0,init=False)\n    def __post_init__(self):\n        self.client_async = AsyncOpenAI(api_key = self.llm_config.api_key)\n    async def acall(self, prompt: str, response_format: Union[Dict, BaseModel] = None): # type: ignore\n        try:\n            response_format = response_format if response_format is not None else {\"type\": \"json_object\" }\n            print(response_format)\n            response = await self.client_async.beta.chat.completions.parse( # type: ignore",
        "detail": "src.llm_module_generator.llm_base.llm_call",
        "documentation": {}
    },
    {
        "label": "extract_json",
        "kind": 2,
        "importPath": "src.llm_module_generator.llm_base.llm_call",
        "description": "src.llm_module_generator.llm_base.llm_call",
        "peekOfCode": "def extract_json(response:str):\n    pattern = r'\\{[^}]*\\}'\n    match = re.search(pattern, response)\n    if match:\n        json_string = match.group(0) \n        return json_string.strip()\n    else:\n        return None\n@dataclass\nclass LLM_Call():",
        "detail": "src.llm_module_generator.llm_base.llm_call",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.llm_module_generator.llm_base.llm_call",
        "description": "src.llm_module_generator.llm_base.llm_call",
        "peekOfCode": "def main():\n    llm_config = LLMConfig(api_key=api_key, model=\"chatgpt-4o-latest\", temperature=0)\n    completion_model = LLM_Call(llm_config)\n    print(asyncio.run(completion_model.acall(\"Hello\")))\n    print(asyncio.run(completion_model.acall(\"How are you\")))\n    print(completion_model.get_total_tokens())\nif __name__ == \"__main__\":\n    main()",
        "detail": "src.llm_module_generator.llm_base.llm_call",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.llm_module_generator.llm_base.llm_call",
        "description": "src.llm_module_generator.llm_base.llm_call",
        "peekOfCode": "logger = get_logger(__name__)\ndef extract_json(response:str):\n    pattern = r'\\{[^}]*\\}'\n    match = re.search(pattern, response)\n    if match:\n        json_string = match.group(0) \n        return json_string.strip()\n    else:\n        return None\n@dataclass",
        "detail": "src.llm_module_generator.llm_base.llm_call",
        "documentation": {}
    },
    {
        "label": "LLMConfig",
        "kind": 6,
        "importPath": "src.llm_module_generator.llm_base.llm_config",
        "description": "src.llm_module_generator.llm_base.llm_config",
        "peekOfCode": "class LLMConfig:\n    api_key:str\n    model:str\n    temperature:float",
        "detail": "src.llm_module_generator.llm_base.llm_config",
        "documentation": {}
    },
    {
        "label": "conceptual_questions_parser",
        "kind": 2,
        "importPath": "src.llm_module_generator.parsers.parser",
        "description": "src.llm_module_generator.parsers.parser",
        "peekOfCode": "def conceptual_questions_parser(result: dict) -> list[str]:\n    extracted_questions = result.get(\"questions\",\"\")\n    all_questions = []\n    for question in extracted_questions:\n        question_text = f\"Question: {question.get('question', 'Unknown')}\"\n        multiple_choice_options = question.get('multiple_choice_options', [])\n        options_text = \"\\n\".join(f\" - Option: {option}\" for option in multiple_choice_options)\n        correct_answer = f\"Correct Answer: {question.get('correct_answer', 'No answer provided')}\"\n        combined_text = f\"{question_text}\\n{options_text}\\n{correct_answer}\"\n        all_questions.append(combined_text)",
        "detail": "src.llm_module_generator.parsers.parser",
        "documentation": {}
    },
    {
        "label": "derivations_parser",
        "kind": 2,
        "importPath": "src.llm_module_generator.parsers.parser",
        "description": "src.llm_module_generator.parsers.parser",
        "peekOfCode": "def derivations_parser(response: dict) -> list[str]:\n    derivations = response.get(\"derivations\", [])\n    all_derivations = []\n    for derivation in derivations:\n        # Extract derivation name\n        derivation_name = f\"Derivation Name: {derivation.get('derivation_name', 'Unknown')}\"\n        # Extract derivation steps, ensuring LaTeX backslashes are properly escaped\n        derivation_steps = \"\\n\".join(\n            \"- Explanation: \" + step.get('explanation', 'No explanation provided').replace('\\\\', '\\\\\\\\') +  # Escaping LaTeX backslashes\n            \"\\n  Step: \" + step.get('output', 'No output provided').replace('\\\\', '\\\\\\\\')  # Escaping LaTeX backslashes",
        "detail": "src.llm_module_generator.parsers.parser",
        "documentation": {}
    },
    {
        "label": "lecture_summary_parser",
        "kind": 2,
        "importPath": "src.llm_module_generator.parsers.parser",
        "description": "src.llm_module_generator.parsers.parser",
        "peekOfCode": "def lecture_summary_parser(response: dict) -> list[str]:\n    analysis = response.get(\"analysis\", {})\n    if analysis:\n        summary = analysis.get('summary', \"No summary provided.\")\n        key_concepts_list = analysis.get('key_concepts', [])\n        foundational_concepts_list = analysis.get('foundational_concepts', [])\n    else:\n        summary = response.get('summary', \"No summary provided.\")\n        key_concepts_list = response.get('key_concepts', [])\n        foundational_concepts_list = response.get('foundational_concepts', [])",
        "detail": "src.llm_module_generator.parsers.parser",
        "documentation": {}
    },
    {
        "label": "computational_question_parser",
        "kind": 2,
        "importPath": "src.llm_module_generator.parsers.parser",
        "description": "src.llm_module_generator.parsers.parser",
        "peekOfCode": "def computational_question_parser(response: dict)->list[dict]:\n    \"\"\"\n    Parses the response dictionary to extract computational questions and their corresponding solutions.\n    Args:\n        response (dict): A dictionary containing the extracted questions and their details.\n                         The expected structure includes a list under the key \"extracted_question\",\n                         where each entry is a dictionary with keys like \"question\", \"complete\", \"solution\",\n                         \"image_req\", and \"external_data_req\".\n    Returns:\n        list: A list of dictionaries, where each dictionary represents a question and its solution.",
        "detail": "src.llm_module_generator.parsers.parser",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.llm_module_generator.parsers.parser",
        "description": "src.llm_module_generator.parsers.parser",
        "peekOfCode": "logger = get_logger(__name__)\ndef conceptual_questions_parser(result: dict) -> list[str]:\n    extracted_questions = result.get(\"questions\",\"\")\n    all_questions = []\n    for question in extracted_questions:\n        question_text = f\"Question: {question.get('question', 'Unknown')}\"\n        multiple_choice_options = question.get('multiple_choice_options', [])\n        options_text = \"\\n\".join(f\" - Option: {option}\" for option in multiple_choice_options)\n        correct_answer = f\"Correct Answer: {question.get('correct_answer', 'No answer provided')}\"\n        combined_text = f\"{question_text}\\n{options_text}\\n{correct_answer}\"",
        "detail": "src.llm_module_generator.parsers.parser",
        "documentation": {}
    },
    {
        "label": "GenerateMetadata",
        "kind": 6,
        "importPath": "src.llm_module_generator.physics_module_generator.generate_metadata",
        "description": "src.llm_module_generator.physics_module_generator.generate_metadata",
        "peekOfCode": "class GenerateMetadata(LLM_Call):\n    llm_config: LLMConfig\n    response_format: BaseModel\n    base_prompt: str = generate_metadata_template\n    def __post_init__(self):\n        super().__post_init__()\n    async def generate_metadata(self, question: str):\n        prompt = self.base_prompt.format(question=question)\n        return await self.acall(prompt, response_format=self.response_format)\nclass MetaData(BaseModel):",
        "detail": "src.llm_module_generator.physics_module_generator.generate_metadata",
        "documentation": {}
    },
    {
        "label": "MetaData",
        "kind": 6,
        "importPath": "src.llm_module_generator.physics_module_generator.generate_metadata",
        "description": "src.llm_module_generator.physics_module_generator.generate_metadata",
        "peekOfCode": "class MetaData(BaseModel):\n    title: str = Field(..., description=\"An appropriate title for the given question, returned using CamelCase format\")\n    stem: str = Field(..., description=\"Additional context or a subtopic related to the main topic\")\n    topic: str = Field(..., description=\"The main topic or subject of the educational content\")\n    tags: List[str] = Field(..., description=\"An array of keywords or tags associated with the content\")\n    prereqs: List[str] = Field(..., description=\"An array of prerequisites needed to access or understand the content\")\n    isAdaptive: bool = Field(..., description=\"Designates whether the content necessitates any form of numerical computation. 'true' if the question involves numerical computation, otherwise 'false'\")\nclass Response(BaseModel):\n    question: str = Field(..., description=\"The original question that was classified\")\n    metadata: MetaData",
        "detail": "src.llm_module_generator.physics_module_generator.generate_metadata",
        "documentation": {}
    },
    {
        "label": "Response",
        "kind": 6,
        "importPath": "src.llm_module_generator.physics_module_generator.generate_metadata",
        "description": "src.llm_module_generator.physics_module_generator.generate_metadata",
        "peekOfCode": "class Response(BaseModel):\n    question: str = Field(..., description=\"The original question that was classified\")\n    metadata: MetaData\nmetadata_gen = GenerateMetadata(llm_config=llm_config, response_format=Response)\nasync def run_tests():\n    test_questions = [\n        \"What is the capital of France?\",\n        \"Explain the process of photosynthesis.\"\n    ]\n    for question in test_questions:",
        "detail": "src.llm_module_generator.physics_module_generator.generate_metadata",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.llm_module_generator.physics_module_generator.generate_metadata",
        "description": "src.llm_module_generator.physics_module_generator.generate_metadata",
        "peekOfCode": "def main():\n    asyncio.run(run_tests())\nif __name__ == \"__main__\":\n    main()",
        "detail": "src.llm_module_generator.physics_module_generator.generate_metadata",
        "documentation": {}
    },
    {
        "label": "llm_config",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.generate_metadata",
        "description": "src.llm_module_generator.physics_module_generator.generate_metadata",
        "peekOfCode": "llm_config = LLMConfig(api_key=api_key, model=\"gpt-4o-mini\", temperature=0)\n@dataclass\nclass GenerateMetadata(LLM_Call):\n    llm_config: LLMConfig\n    response_format: BaseModel\n    base_prompt: str = generate_metadata_template\n    def __post_init__(self):\n        super().__post_init__()\n    async def generate_metadata(self, question: str):\n        prompt = self.base_prompt.format(question=question)",
        "detail": "src.llm_module_generator.physics_module_generator.generate_metadata",
        "documentation": {}
    },
    {
        "label": "metadata_gen",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.generate_metadata",
        "description": "src.llm_module_generator.physics_module_generator.generate_metadata",
        "peekOfCode": "metadata_gen = GenerateMetadata(llm_config=llm_config, response_format=Response)\nasync def run_tests():\n    test_questions = [\n        \"What is the capital of France?\",\n        \"Explain the process of photosynthesis.\"\n    ]\n    for question in test_questions:\n        result = await metadata_gen.generate_metadata(question)\n        print(f\"Question: {question}\")\n        print(f\"Metadata: {result}\")",
        "detail": "src.llm_module_generator.physics_module_generator.generate_metadata",
        "documentation": {}
    },
    {
        "label": "Code_Analysis",
        "kind": 6,
        "importPath": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "description": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "peekOfCode": "class Code_Analysis(BaseModel):\n    \"\"\"Analyze the code related to the given question.\"\"\"\n    analysis: str = Field(description=\"A brief description of the functionality that the code implements.\")\n    code_snippet: str = Field(description=\"A code snippet delimit the code using triple backticks\")\nclass Response(BaseModel):\n    response: Optional[list[Code_Analysis]] = Field(description=\"A list of potential code implementations based on documentation that matches the given question. If no matches are found, return None.\")\n## Format the retrieved information\ndef format_docs(docs):\n    return \"\\n\\n\".join(doc.page_content for doc in docs)\n## Define the RAG Chain",
        "detail": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "documentation": {}
    },
    {
        "label": "Response",
        "kind": 6,
        "importPath": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "description": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "peekOfCode": "class Response(BaseModel):\n    response: Optional[list[Code_Analysis]] = Field(description=\"A list of potential code implementations based on documentation that matches the given question. If no matches are found, return None.\")\n## Format the retrieved information\ndef format_docs(docs):\n    return \"\\n\\n\".join(doc.page_content for doc in docs)\n## Define the RAG Chain\nrag_chain_from_docs = (\n    {\n        \"input\": lambda x: x[\"input\"],\n        \"context\": lambda x: format_docs(x[\"context\"]),",
        "detail": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "documentation": {}
    },
    {
        "label": "format_docs",
        "kind": 2,
        "importPath": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "description": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "peekOfCode": "def format_docs(docs):\n    return \"\\n\\n\".join(doc.page_content for doc in docs)\n## Define the RAG Chain\nrag_chain_from_docs = (\n    {\n        \"input\": lambda x: x[\"input\"],\n        \"context\": lambda x: format_docs(x[\"context\"]),\n    }\n    | prompt\n    | llm.with_structured_output(Response)",
        "detail": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "description": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "peekOfCode": "logger = get_logger(__name__)\n## Define the LLM and Load the Vector Store\nllm = ChatOpenAI(model=\"gpt-4o-mini\")\nembedding_function = OpenAIEmbeddings()\nvectorstore = Chroma(persist_directory=r\"src\\llm_module_generator\\physics_module_generator\\chroma_db\", embedding_function=embedding_function)\ndocs = vectorstore.similarity_search(\"Matrices\")\nretriever = vectorstore.as_retriever()\nretriever_from_llm = MultiQueryRetriever.from_llm(\n    retriever=vectorstore.as_retriever(), llm=llm\n)",
        "detail": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "documentation": {}
    },
    {
        "label": "llm",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "description": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "peekOfCode": "llm = ChatOpenAI(model=\"gpt-4o-mini\")\nembedding_function = OpenAIEmbeddings()\nvectorstore = Chroma(persist_directory=r\"src\\llm_module_generator\\physics_module_generator\\chroma_db\", embedding_function=embedding_function)\ndocs = vectorstore.similarity_search(\"Matrices\")\nretriever = vectorstore.as_retriever()\nretriever_from_llm = MultiQueryRetriever.from_llm(\n    retriever=vectorstore.as_retriever(), llm=llm\n)\n## Define the system prompt \n## This will be given to the RAG Chain",
        "detail": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "documentation": {}
    },
    {
        "label": "embedding_function",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "description": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "peekOfCode": "embedding_function = OpenAIEmbeddings()\nvectorstore = Chroma(persist_directory=r\"src\\llm_module_generator\\physics_module_generator\\chroma_db\", embedding_function=embedding_function)\ndocs = vectorstore.similarity_search(\"Matrices\")\nretriever = vectorstore.as_retriever()\nretriever_from_llm = MultiQueryRetriever.from_llm(\n    retriever=vectorstore.as_retriever(), llm=llm\n)\n## Define the system prompt \n## This will be given to the RAG Chain\nsystem_prompt = (",
        "detail": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "documentation": {}
    },
    {
        "label": "vectorstore",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "description": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "peekOfCode": "vectorstore = Chroma(persist_directory=r\"src\\llm_module_generator\\physics_module_generator\\chroma_db\", embedding_function=embedding_function)\ndocs = vectorstore.similarity_search(\"Matrices\")\nretriever = vectorstore.as_retriever()\nretriever_from_llm = MultiQueryRetriever.from_llm(\n    retriever=vectorstore.as_retriever(), llm=llm\n)\n## Define the system prompt \n## This will be given to the RAG Chain\nsystem_prompt = (\n    \"You are an assistant for question-answering tasks. \"",
        "detail": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "documentation": {}
    },
    {
        "label": "docs",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "description": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "peekOfCode": "docs = vectorstore.similarity_search(\"Matrices\")\nretriever = vectorstore.as_retriever()\nretriever_from_llm = MultiQueryRetriever.from_llm(\n    retriever=vectorstore.as_retriever(), llm=llm\n)\n## Define the system prompt \n## This will be given to the RAG Chain\nsystem_prompt = (\n    \"You are an assistant for question-answering tasks. \"\n    \"Use the following pieces of retrieved context to answer \"",
        "detail": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "documentation": {}
    },
    {
        "label": "retriever",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "description": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "peekOfCode": "retriever = vectorstore.as_retriever()\nretriever_from_llm = MultiQueryRetriever.from_llm(\n    retriever=vectorstore.as_retriever(), llm=llm\n)\n## Define the system prompt \n## This will be given to the RAG Chain\nsystem_prompt = (\n    \"You are an assistant for question-answering tasks. \"\n    \"Use the following pieces of retrieved context to answer \"\n    \"the question. If you don't know the answer, say that you \"",
        "detail": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "documentation": {}
    },
    {
        "label": "retriever_from_llm",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "description": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "peekOfCode": "retriever_from_llm = MultiQueryRetriever.from_llm(\n    retriever=vectorstore.as_retriever(), llm=llm\n)\n## Define the system prompt \n## This will be given to the RAG Chain\nsystem_prompt = (\n    \"You are an assistant for question-answering tasks. \"\n    \"Use the following pieces of retrieved context to answer \"\n    \"the question. If you don't know the answer, say that you \"\n    \"don't know.If the context provided does not offer information \"",
        "detail": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "documentation": {}
    },
    {
        "label": "system_prompt",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "description": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "peekOfCode": "system_prompt = (\n    \"You are an assistant for question-answering tasks. \"\n    \"Use the following pieces of retrieved context to answer \"\n    \"the question. If you don't know the answer, say that you \"\n    \"don't know.If the context provided does not offer information \"\n    \"that directly answers the question, make it clear that the context \"\n    \"does not provide the necessary information.\"\n    \"\\n\\n\"\n    \"{context}\"\n)",
        "detail": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "documentation": {}
    },
    {
        "label": "prompt",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "description": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "peekOfCode": "prompt = ChatPromptTemplate.from_messages(\n    [\n        (\"system\", system_prompt),\n        (\"human\", \"{input}\"),\n    ]\n)\n## This prompt will go in for the human input of the question\nhuman_prompt = f\"\"\"\nYou are tasked with analyzing a given question and generating relevant code snippets in Javascript based on the Math Js documentation.\nEach response should contain a brief description of the functionality the code implements (analysis)",
        "detail": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "documentation": {}
    },
    {
        "label": "human_prompt",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "description": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "peekOfCode": "human_prompt = f\"\"\"\nYou are tasked with analyzing a given question and generating relevant code snippets in Javascript based on the Math Js documentation.\nEach response should contain a brief description of the functionality the code implements (analysis)\nand a short, concise code snippet that demonstrates the functionality (code_snippet).\nEach code snippet should be unique, avoiding repetition of similar code, and serve a distinct purpose.\nA single response can contain multiple components if needed, but the goal is to be direct with the appropriate code snippets.\nThe response should return a list of potential code implementations.\nIf no suitable code implementations are found, return None.\nReturn a max of 0-2 analysis, code_snippet pairs.\nQuestion: {{question}}",
        "detail": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "documentation": {}
    },
    {
        "label": "rag_chain_from_docs",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "description": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "peekOfCode": "rag_chain_from_docs = (\n    {\n        \"input\": lambda x: x[\"input\"],\n        \"context\": lambda x: format_docs(x[\"context\"]),\n    }\n    | prompt\n    | llm.with_structured_output(Response)\n)\nretrieve_docs = (lambda x: x[\"input\"]) | retriever_from_llm\nchain = RunnablePassthrough.assign(context=retrieve_docs).assign(",
        "detail": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "documentation": {}
    },
    {
        "label": "retrieve_docs",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "description": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "peekOfCode": "retrieve_docs = (lambda x: x[\"input\"]) | retriever_from_llm\nchain = RunnablePassthrough.assign(context=retrieve_docs).assign(\n    answer=rag_chain_from_docs\n)\n## Wrap it all in a funciton \nasync def mathjs_code_snippet_chain(question:str)->str:\n    code_search = await chain.ainvoke({\"input\": human_prompt.format(question=question)})\n    response_instance = json.loads(code_search[\"answer\"].model_dump_json())\n    response = response_instance[\"response\"]\n    # Build the example code snippets",
        "detail": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "documentation": {}
    },
    {
        "label": "chain",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "description": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "peekOfCode": "chain = RunnablePassthrough.assign(context=retrieve_docs).assign(\n    answer=rag_chain_from_docs\n)\n## Wrap it all in a funciton \nasync def mathjs_code_snippet_chain(question:str)->str:\n    code_search = await chain.ainvoke({\"input\": human_prompt.format(question=question)})\n    response_instance = json.loads(code_search[\"answer\"].model_dump_json())\n    response = response_instance[\"response\"]\n    # Build the example code snippets\n    example_code_snippets = \"\\nThe following are useful code snippets\\n\"",
        "detail": "src.llm_module_generator.physics_module_generator.math_js_retriever",
        "documentation": {}
    },
    {
        "label": "is_href_invalid",
        "kind": 2,
        "importPath": "src.llm_module_generator.physics_module_generator.math_js_vectorstore",
        "description": "src.llm_module_generator.physics_module_generator.math_js_vectorstore",
        "peekOfCode": "def is_href_invalid(href: str) -> bool:\n    \"\"\"\n    Checks if the href is an invalid link based on specific conditions.\n    Args:\n        href (str): The link to check.\n    Returns:\n        bool: True if the link is invalid, otherwise False.\n    \"\"\"\n    if (href.startswith(\"https://en.wikipedia.org\") or\n        href.startswith(\"https://github.com\") or",
        "detail": "src.llm_module_generator.physics_module_generator.math_js_vectorstore",
        "documentation": {}
    },
    {
        "label": "extract_all_links",
        "kind": 2,
        "importPath": "src.llm_module_generator.physics_module_generator.math_js_vectorstore",
        "description": "src.llm_module_generator.physics_module_generator.math_js_vectorstore",
        "peekOfCode": "def extract_all_links(link: str) -> Set[str]:\n    \"\"\"\n    Recursively extracts all unique links from a given webpage and its child pages.\n    Args:\n        link (str): The URL of the webpage to extract links from.\n    Returns:\n        Set[str]: A set of all unique links found.\n    \"\"\"\n    all_links = set()\n    html = requests.get(link)",
        "detail": "src.llm_module_generator.physics_module_generator.math_js_vectorstore",
        "documentation": {}
    },
    {
        "label": "check_and_return_html",
        "kind": 2,
        "importPath": "src.llm_module_generator.physics_module_generator.math_js_vectorstore",
        "description": "src.llm_module_generator.physics_module_generator.math_js_vectorstore",
        "peekOfCode": "def check_and_return_html(url: str) -> str:\n    \"\"\"\n    Attempts to request the HTML content from a given URL, handling common errors.\n    Args:\n        url (str): The URL to make the request to.\n    Returns:\n        str: The HTML content of the webpage if the request is successful. If the request fails, \n        it prints an error message and returns an empty string.\n    \"\"\"\n    # Fix any backslashes in the URL by replacing them with forward slashes",
        "detail": "src.llm_module_generator.physics_module_generator.math_js_vectorstore",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.llm_module_generator.physics_module_generator.math_js_vectorstore",
        "description": "src.llm_module_generator.physics_module_generator.math_js_vectorstore",
        "peekOfCode": "def main():\n    \"\"\"\n    Main function to extract links, split the content of the webpages,\n    and store the results in a vectorstore for future use.\n    \"\"\"\n    # Base URL to extract links from\n    original_link = \"https://mathjs.org/docs/index.html\"\n    # Extract all links from the base URL\n    all_links = extract_all_links(original_link)\n    # Headers to split the HTML content on",
        "detail": "src.llm_module_generator.physics_module_generator.math_js_vectorstore",
        "documentation": {}
    },
    {
        "label": "ModuleCodeGenerator",
        "kind": 6,
        "importPath": "src.llm_module_generator.physics_module_generator.module_generator",
        "description": "src.llm_module_generator.physics_module_generator.module_generator",
        "peekOfCode": "class ModuleCodeGenerator(LLM_Call):\n    llm_config: LLMConfig\n    base_prompt: str\n    example_input_column: str\n    example_output_column: str\n    threshold: float = 0.1\n    num_examples: int = field(default=1)\n    is_adaptive: bool = True\n    def __post_init__(self):\n        super().__post_init__()",
        "detail": "src.llm_module_generator.physics_module_generator.module_generator",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.module_generator",
        "description": "src.llm_module_generator.physics_module_generator.module_generator",
        "peekOfCode": "logger = get_logger(__name__)\nfrom .templates import question_html_gen_template,server_js_template_base,server_py_template_base,solution_html_template,question_html_gen_template_nonadaptive\n@dataclass\nclass ModuleCodeGenerator(LLM_Call):\n    llm_config: LLMConfig\n    base_prompt: str\n    example_input_column: str\n    example_output_column: str\n    threshold: float = 0.1\n    num_examples: int = field(default=1)",
        "detail": "src.llm_module_generator.physics_module_generator.module_generator",
        "documentation": {}
    },
    {
        "label": "llm_config",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.module_generator",
        "description": "src.llm_module_generator.physics_module_generator.module_generator",
        "peekOfCode": "llm_config = LLMConfig(api_key=api_key, model=\"gpt-4o-2024-08-06\", temperature=0)\n# Initialize all the generators\nquestion_html_generator = ModuleCodeGenerator(\n    base_prompt=question_html_gen_template,\n    example_input_column=\"question\",\n    example_output_column=\"question.html\",\n    llm_config=llm_config,\n    num_examples = 3\n)\nquestion_html_generator_nonadaptive = ModuleCodeGenerator(",
        "detail": "src.llm_module_generator.physics_module_generator.module_generator",
        "documentation": {}
    },
    {
        "label": "question_html_generator",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.module_generator",
        "description": "src.llm_module_generator.physics_module_generator.module_generator",
        "peekOfCode": "question_html_generator = ModuleCodeGenerator(\n    base_prompt=question_html_gen_template,\n    example_input_column=\"question\",\n    example_output_column=\"question.html\",\n    llm_config=llm_config,\n    num_examples = 3\n)\nquestion_html_generator_nonadaptive = ModuleCodeGenerator(\n    base_prompt=question_html_gen_template_nonadaptive,\n    example_input_column=\"question\",",
        "detail": "src.llm_module_generator.physics_module_generator.module_generator",
        "documentation": {}
    },
    {
        "label": "question_html_generator_nonadaptive",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.module_generator",
        "description": "src.llm_module_generator.physics_module_generator.module_generator",
        "peekOfCode": "question_html_generator_nonadaptive = ModuleCodeGenerator(\n    base_prompt=question_html_gen_template_nonadaptive,\n    example_input_column=\"question\",\n    example_output_column=\"question.html\",\n    llm_config=llm_config,\n    is_adaptive=False,\n    num_examples = 3\n)\nquestion_solution_generator = ModuleCodeGenerator(\n    base_prompt=solution_html_template,",
        "detail": "src.llm_module_generator.physics_module_generator.module_generator",
        "documentation": {}
    },
    {
        "label": "question_solution_generator",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.module_generator",
        "description": "src.llm_module_generator.physics_module_generator.module_generator",
        "peekOfCode": "question_solution_generator = ModuleCodeGenerator(\n    base_prompt=solution_html_template,\n    example_input_column=\"question.html\",\n    example_output_column=\"solution.html\",\n    llm_config=llm_config,\n    num_examples = 1\n)\nserver_js_generator = ModuleCodeGenerator(\n    base_prompt=server_js_template_base,\n    example_input_column=\"question.html\",",
        "detail": "src.llm_module_generator.physics_module_generator.module_generator",
        "documentation": {}
    },
    {
        "label": "server_js_generator",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.module_generator",
        "description": "src.llm_module_generator.physics_module_generator.module_generator",
        "peekOfCode": "server_js_generator = ModuleCodeGenerator(\n    base_prompt=server_js_template_base,\n    example_input_column=\"question.html\",\n    example_output_column=\"server.js\",\n    llm_config=llm_config,\n    num_examples = 1\n)\nserver_py_generator = ModuleCodeGenerator(\n    base_prompt=server_py_template_base,\n    example_input_column=\"question.html\",",
        "detail": "src.llm_module_generator.physics_module_generator.module_generator",
        "documentation": {}
    },
    {
        "label": "server_py_generator",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.module_generator",
        "description": "src.llm_module_generator.physics_module_generator.module_generator",
        "peekOfCode": "server_py_generator = ModuleCodeGenerator(\n    base_prompt=server_py_template_base,\n    example_input_column=\"question.html\",\n    example_output_column=\"server.py\",\n    llm_config=llm_config,\n    num_examples = 1\n)\nasync def main():\n    # The question to be processed\n    question = \"A ball travels a distance of 5 meters during a period of 5 minutes determine its average speed\"",
        "detail": "src.llm_module_generator.physics_module_generator.module_generator",
        "documentation": {}
    },
    {
        "label": "Code_Analysis",
        "kind": 6,
        "importPath": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "description": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "peekOfCode": "class Code_Analysis(BaseModel):\n    \"\"\"Analyze the code related to the given question.\"\"\"\n    analysis: str = Field(description=\"A brief description of the functionality that the code implements.\")\n    code_snippet: str = Field(description=\"A code snippet delimit the code using triple backticks\")\nclass Response(BaseModel):\n    response: Optional[list[Code_Analysis]] = Field(description=\"A list of potential code implementations based on documentation that matches the given question. If no matches are found, return None.\")\n## Format the retrieved information\ndef format_docs(docs):\n    return \"\\n\\n\".join(doc.page_content for doc in docs)\n## Define the RAG Chain",
        "detail": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "documentation": {}
    },
    {
        "label": "Response",
        "kind": 6,
        "importPath": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "description": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "peekOfCode": "class Response(BaseModel):\n    response: Optional[list[Code_Analysis]] = Field(description=\"A list of potential code implementations based on documentation that matches the given question. If no matches are found, return None.\")\n## Format the retrieved information\ndef format_docs(docs):\n    return \"\\n\\n\".join(doc.page_content for doc in docs)\n## Define the RAG Chain\nrag_chain_from_docs = (\n    {\n        \"input\": lambda x: x[\"input\"],\n        \"context\": lambda x: format_docs(x[\"context\"]),",
        "detail": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "documentation": {}
    },
    {
        "label": "format_docs",
        "kind": 2,
        "importPath": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "description": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "peekOfCode": "def format_docs(docs):\n    return \"\\n\\n\".join(doc.page_content for doc in docs)\n## Define the RAG Chain\nrag_chain_from_docs = (\n    {\n        \"input\": lambda x: x[\"input\"],\n        \"context\": lambda x: format_docs(x[\"context\"]),\n    }\n    | prompt\n    | llm.with_structured_output(Response)",
        "detail": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "description": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "peekOfCode": "logger = get_logger(__name__)\n## Define the LLM and Load the Vector Store\nllm = ChatOpenAI(model=\"gpt-4o-mini\")\nembedding_function = OpenAIEmbeddings()\nvectorstore = Chroma(persist_directory=r\"src\\llm_module_generator\\physics_module_generator\\pl_chroma_db\", embedding_function=embedding_function)\ndocs = vectorstore.similarity_search(\"Matrices\")\nretriever = vectorstore.as_retriever()\nretriever_from_llm = MultiQueryRetriever.from_llm(\n    retriever=vectorstore.as_retriever(), llm=llm\n)",
        "detail": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "documentation": {}
    },
    {
        "label": "llm",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "description": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "peekOfCode": "llm = ChatOpenAI(model=\"gpt-4o-mini\")\nembedding_function = OpenAIEmbeddings()\nvectorstore = Chroma(persist_directory=r\"src\\llm_module_generator\\physics_module_generator\\pl_chroma_db\", embedding_function=embedding_function)\ndocs = vectorstore.similarity_search(\"Matrices\")\nretriever = vectorstore.as_retriever()\nretriever_from_llm = MultiQueryRetriever.from_llm(\n    retriever=vectorstore.as_retriever(), llm=llm\n)\n## Define the system prompt \n## This will be given to the RAG Chain",
        "detail": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "documentation": {}
    },
    {
        "label": "embedding_function",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "description": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "peekOfCode": "embedding_function = OpenAIEmbeddings()\nvectorstore = Chroma(persist_directory=r\"src\\llm_module_generator\\physics_module_generator\\pl_chroma_db\", embedding_function=embedding_function)\ndocs = vectorstore.similarity_search(\"Matrices\")\nretriever = vectorstore.as_retriever()\nretriever_from_llm = MultiQueryRetriever.from_llm(\n    retriever=vectorstore.as_retriever(), llm=llm\n)\n## Define the system prompt \n## This will be given to the RAG Chain\nsystem_prompt = (",
        "detail": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "documentation": {}
    },
    {
        "label": "vectorstore",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "description": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "peekOfCode": "vectorstore = Chroma(persist_directory=r\"src\\llm_module_generator\\physics_module_generator\\pl_chroma_db\", embedding_function=embedding_function)\ndocs = vectorstore.similarity_search(\"Matrices\")\nretriever = vectorstore.as_retriever()\nretriever_from_llm = MultiQueryRetriever.from_llm(\n    retriever=vectorstore.as_retriever(), llm=llm\n)\n## Define the system prompt \n## This will be given to the RAG Chain\nsystem_prompt = (\n    \"You are an assistant for question-answering tasks. \"",
        "detail": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "documentation": {}
    },
    {
        "label": "docs",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "description": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "peekOfCode": "docs = vectorstore.similarity_search(\"Matrices\")\nretriever = vectorstore.as_retriever()\nretriever_from_llm = MultiQueryRetriever.from_llm(\n    retriever=vectorstore.as_retriever(), llm=llm\n)\n## Define the system prompt \n## This will be given to the RAG Chain\nsystem_prompt = (\n    \"You are an assistant for question-answering tasks. \"\n    \"Use the following pieces of retrieved context to answer \"",
        "detail": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "documentation": {}
    },
    {
        "label": "retriever",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "description": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "peekOfCode": "retriever = vectorstore.as_retriever()\nretriever_from_llm = MultiQueryRetriever.from_llm(\n    retriever=vectorstore.as_retriever(), llm=llm\n)\n## Define the system prompt \n## This will be given to the RAG Chain\nsystem_prompt = (\n    \"You are an assistant for question-answering tasks. \"\n    \"Use the following pieces of retrieved context to answer \"\n    \"the question. If you don't know the answer, say that you \"",
        "detail": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "documentation": {}
    },
    {
        "label": "retriever_from_llm",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "description": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "peekOfCode": "retriever_from_llm = MultiQueryRetriever.from_llm(\n    retriever=vectorstore.as_retriever(), llm=llm\n)\n## Define the system prompt \n## This will be given to the RAG Chain\nsystem_prompt = (\n    \"You are an assistant for question-answering tasks. \"\n    \"Use the following pieces of retrieved context to answer \"\n    \"the question. If you don't know the answer, say that you \"\n    \"don't know.If the context provided does not offer information \"",
        "detail": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "documentation": {}
    },
    {
        "label": "system_prompt",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "description": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "peekOfCode": "system_prompt = (\n    \"You are an assistant for question-answering tasks. \"\n    \"Use the following pieces of retrieved context to answer \"\n    \"the question. If you don't know the answer, say that you \"\n    \"don't know.If the context provided does not offer information \"\n    \"that directly answers the question, make it clear that the context \"\n    \"does not provide the necessary information.\"\n    \"\\n\\n\"\n    \"{context}\"\n)",
        "detail": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "documentation": {}
    },
    {
        "label": "prompt",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "description": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "peekOfCode": "prompt = ChatPromptTemplate.from_messages(\n    [\n        (\"system\", system_prompt),\n        (\"human\", \"{input}\"),\n    ]\n)\n## This prompt will go in for the human input of the question\nhuman_prompt = f\"\"\"\nYou have access to documentation on formatting questions using custom HTML tags. Your task is to format user-input questions in a valid format.\nFor each response, please include:",
        "detail": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "documentation": {}
    },
    {
        "label": "human_prompt",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "description": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "peekOfCode": "human_prompt = f\"\"\"\nYou have access to documentation on formatting questions using custom HTML tags. Your task is to format user-input questions in a valid format.\nFor each response, please include:\n1. **Analysis**: A brief description of the functionality that the code implements.\n2. **Code Snippet**: A short, concise code snippet demonstrating the functionality.\nGuidelines:\n- Each code snippet should be unique and serve a distinct purpose, avoiding repetition of similar code.\n- A single response may contain multiple components if necessary, but aim to be direct and relevant.\n- Return a list of potential code implementations. If no suitable implementations are found, return `None`.\n- If possible, return the entire formatted HTML. If you're unsure, provide the response in chunks of code snippets.",
        "detail": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "documentation": {}
    },
    {
        "label": "rag_chain_from_docs",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "description": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "peekOfCode": "rag_chain_from_docs = (\n    {\n        \"input\": lambda x: x[\"input\"],\n        \"context\": lambda x: format_docs(x[\"context\"]),\n    }\n    | prompt\n    | llm.with_structured_output(Response)\n)\nretrieve_docs = (lambda x: x[\"input\"]) | retriever_from_llm\nchain = RunnablePassthrough.assign(context=retrieve_docs).assign(",
        "detail": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "documentation": {}
    },
    {
        "label": "retrieve_docs",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "description": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "peekOfCode": "retrieve_docs = (lambda x: x[\"input\"]) | retriever_from_llm\nchain = RunnablePassthrough.assign(context=retrieve_docs).assign(\n    answer=rag_chain_from_docs\n)\n## Wrap it all in a funciton \nasync def pl_code_snippet_chain(question:str)->str:\n    code_search = await chain.ainvoke({\"input\": human_prompt.format(question=question)})\n    response_instance = json.loads(code_search[\"answer\"].model_dump_json())\n    response = response_instance[\"response\"]\n    # Build the example code snippets",
        "detail": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "documentation": {}
    },
    {
        "label": "chain",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "description": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "peekOfCode": "chain = RunnablePassthrough.assign(context=retrieve_docs).assign(\n    answer=rag_chain_from_docs\n)\n## Wrap it all in a funciton \nasync def pl_code_snippet_chain(question:str)->str:\n    code_search = await chain.ainvoke({\"input\": human_prompt.format(question=question)})\n    response_instance = json.loads(code_search[\"answer\"].model_dump_json())\n    response = response_instance[\"response\"]\n    # Build the example code snippets\n    example_code_snippets = \"\\nThe following are useful code snippets\\n\"",
        "detail": "src.llm_module_generator.physics_module_generator.pl_retriever",
        "documentation": {}
    },
    {
        "label": "is_github_link",
        "kind": 2,
        "importPath": "src.llm_module_generator.physics_module_generator.pl_vectorstore",
        "description": "src.llm_module_generator.physics_module_generator.pl_vectorstore",
        "peekOfCode": "def is_github_link(href: str) -> bool:\n    return href.startswith(\"https://github.com/\")\n# Main function to scrape the webpage and process elements\ndef main():\n    print('running')\n    # Set to hold all GitHub links found\n    all_links = set()\n    # Original link to scrape\n    original_link = \"https://prairielearn.readthedocs.io/en/latest/elements/\"\n    # Send a GET request to the link",
        "detail": "src.llm_module_generator.physics_module_generator.pl_vectorstore",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.llm_module_generator.physics_module_generator.pl_vectorstore",
        "description": "src.llm_module_generator.physics_module_generator.pl_vectorstore",
        "peekOfCode": "def main():\n    print('running')\n    # Set to hold all GitHub links found\n    all_links = set()\n    # Original link to scrape\n    original_link = \"https://prairielearn.readthedocs.io/en/latest/elements/\"\n    # Send a GET request to the link\n    html = requests.get(original_link)\n    # Parse the HTML content\n    soup = bs4.BeautifulSoup(html.text, 'html.parser')",
        "detail": "src.llm_module_generator.physics_module_generator.pl_vectorstore",
        "documentation": {}
    },
    {
        "label": "is_github_link",
        "kind": 2,
        "importPath": "src.llm_module_generator.physics_module_generator.prairielearn_vectorstore",
        "description": "src.llm_module_generator.physics_module_generator.prairielearn_vectorstore",
        "peekOfCode": "def is_github_link(href:str):\n  return href.startswith(\"https://github.com/\")\nall_links = set()\noriginal_link = \"https://prairielearn.readthedocs.io/en/latest/elements/\"\nhtml = requests.get(original_link)\nsoup = bs4.BeautifulSoup(html.text, 'html.parser')\n# Define the valid elements that we can render\nVALID_ELEMENTS: list[str] = [\n    \"pl-question-panel\", \"pl-number-input\", \"pl-checkbox\", \"pl-figure\",\n    \"pl-integer-input\", \"pl-matching\", \"pl-matrix-component-input\",",
        "detail": "src.llm_module_generator.physics_module_generator.prairielearn_vectorstore",
        "documentation": {}
    },
    {
        "label": "all_links",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.prairielearn_vectorstore",
        "description": "src.llm_module_generator.physics_module_generator.prairielearn_vectorstore",
        "peekOfCode": "all_links = set()\noriginal_link = \"https://prairielearn.readthedocs.io/en/latest/elements/\"\nhtml = requests.get(original_link)\nsoup = bs4.BeautifulSoup(html.text, 'html.parser')\n# Define the valid elements that we can render\nVALID_ELEMENTS: list[str] = [\n    \"pl-question-panel\", \"pl-number-input\", \"pl-checkbox\", \"pl-figure\",\n    \"pl-integer-input\", \"pl-matching\", \"pl-matrix-component-input\",\n    \"pl-matrix-input\", \"pl-multiple-choice\", \"pl-order-blocks\",\n    \"pl-symbolic-input\", \"pl-units-input\",\"pl-matrix-latex\",\"pl-card\",\"pl-answer-panel\"",
        "detail": "src.llm_module_generator.physics_module_generator.prairielearn_vectorstore",
        "documentation": {}
    },
    {
        "label": "original_link",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.prairielearn_vectorstore",
        "description": "src.llm_module_generator.physics_module_generator.prairielearn_vectorstore",
        "peekOfCode": "original_link = \"https://prairielearn.readthedocs.io/en/latest/elements/\"\nhtml = requests.get(original_link)\nsoup = bs4.BeautifulSoup(html.text, 'html.parser')\n# Define the valid elements that we can render\nVALID_ELEMENTS: list[str] = [\n    \"pl-question-panel\", \"pl-number-input\", \"pl-checkbox\", \"pl-figure\",\n    \"pl-integer-input\", \"pl-matching\", \"pl-matrix-component-input\",\n    \"pl-matrix-input\", \"pl-multiple-choice\", \"pl-order-blocks\",\n    \"pl-symbolic-input\", \"pl-units-input\",\"pl-matrix-latex\",\"pl-card\",\"pl-answer-panel\"\n]",
        "detail": "src.llm_module_generator.physics_module_generator.prairielearn_vectorstore",
        "documentation": {}
    },
    {
        "label": "html",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.prairielearn_vectorstore",
        "description": "src.llm_module_generator.physics_module_generator.prairielearn_vectorstore",
        "peekOfCode": "html = requests.get(original_link)\nsoup = bs4.BeautifulSoup(html.text, 'html.parser')\n# Define the valid elements that we can render\nVALID_ELEMENTS: list[str] = [\n    \"pl-question-panel\", \"pl-number-input\", \"pl-checkbox\", \"pl-figure\",\n    \"pl-integer-input\", \"pl-matching\", \"pl-matrix-component-input\",\n    \"pl-matrix-input\", \"pl-multiple-choice\", \"pl-order-blocks\",\n    \"pl-symbolic-input\", \"pl-units-input\",\"pl-matrix-latex\",\"pl-card\",\"pl-answer-panel\"\n]\n# Modify the string so that it matches the id of the header",
        "detail": "src.llm_module_generator.physics_module_generator.prairielearn_vectorstore",
        "documentation": {}
    },
    {
        "label": "soup",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.prairielearn_vectorstore",
        "description": "src.llm_module_generator.physics_module_generator.prairielearn_vectorstore",
        "peekOfCode": "soup = bs4.BeautifulSoup(html.text, 'html.parser')\n# Define the valid elements that we can render\nVALID_ELEMENTS: list[str] = [\n    \"pl-question-panel\", \"pl-number-input\", \"pl-checkbox\", \"pl-figure\",\n    \"pl-integer-input\", \"pl-matching\", \"pl-matrix-component-input\",\n    \"pl-matrix-input\", \"pl-multiple-choice\", \"pl-order-blocks\",\n    \"pl-symbolic-input\", \"pl-units-input\",\"pl-matrix-latex\",\"pl-card\",\"pl-answer-panel\"\n]\n# Modify the string so that it matches the id of the header\nVALID_ELEMENTS_EX = [(v + \"-element\") for v in VALID_ELEMENTS]",
        "detail": "src.llm_module_generator.physics_module_generator.prairielearn_vectorstore",
        "documentation": {}
    },
    {
        "label": "VALID_ELEMENTS_EX",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.prairielearn_vectorstore",
        "description": "src.llm_module_generator.physics_module_generator.prairielearn_vectorstore",
        "peekOfCode": "VALID_ELEMENTS_EX = [(v + \"-element\") for v in VALID_ELEMENTS]\ncontent =[]\nh3_tags = soup.find_all(\"h3\")\nfor h3 in h3_tags:\n  if h3.get(\"id\") in VALID_ELEMENTS_EX:\n    element_info =[]\n    element_info.append(h3)\n    current_tag = h3.find_next_sibling()\n    while current_tag and current_tag != h3.find_next(\"h3\"):\n      element_info.append(current_tag)",
        "detail": "src.llm_module_generator.physics_module_generator.prairielearn_vectorstore",
        "documentation": {}
    },
    {
        "label": "h3_tags",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.prairielearn_vectorstore",
        "description": "src.llm_module_generator.physics_module_generator.prairielearn_vectorstore",
        "peekOfCode": "h3_tags = soup.find_all(\"h3\")\nfor h3 in h3_tags:\n  if h3.get(\"id\") in VALID_ELEMENTS_EX:\n    element_info =[]\n    element_info.append(h3)\n    current_tag = h3.find_next_sibling()\n    while current_tag and current_tag != h3.find_next(\"h3\"):\n      element_info.append(current_tag)\n      extracted_links = current_tag.find_all(\"a\")\n      for link in extracted_links:",
        "detail": "src.llm_module_generator.physics_module_generator.prairielearn_vectorstore",
        "documentation": {}
    },
    {
        "label": "headers_to_split_on",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.prairielearn_vectorstore",
        "description": "src.llm_module_generator.physics_module_generator.prairielearn_vectorstore",
        "peekOfCode": "headers_to_split_on = [\n    (\"h3\", \"Header 3\"),\n]\nhtml_splitter = HTMLSectionSplitter(\n    headers_to_split_on\n)\nall_docs = []\nall_docs.extend(html_splitter.split_text(html_text))\nvectorstore = Chroma.from_documents(all_docs, OpenAIEmbeddings(), persist_directory=\"./pl_chroma_db\")",
        "detail": "src.llm_module_generator.physics_module_generator.prairielearn_vectorstore",
        "documentation": {}
    },
    {
        "label": "html_splitter",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.prairielearn_vectorstore",
        "description": "src.llm_module_generator.physics_module_generator.prairielearn_vectorstore",
        "peekOfCode": "html_splitter = HTMLSectionSplitter(\n    headers_to_split_on\n)\nall_docs = []\nall_docs.extend(html_splitter.split_text(html_text))\nvectorstore = Chroma.from_documents(all_docs, OpenAIEmbeddings(), persist_directory=\"./pl_chroma_db\")",
        "detail": "src.llm_module_generator.physics_module_generator.prairielearn_vectorstore",
        "documentation": {}
    },
    {
        "label": "all_docs",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.prairielearn_vectorstore",
        "description": "src.llm_module_generator.physics_module_generator.prairielearn_vectorstore",
        "peekOfCode": "all_docs = []\nall_docs.extend(html_splitter.split_text(html_text))\nvectorstore = Chroma.from_documents(all_docs, OpenAIEmbeddings(), persist_directory=\"./pl_chroma_db\")",
        "detail": "src.llm_module_generator.physics_module_generator.prairielearn_vectorstore",
        "documentation": {}
    },
    {
        "label": "vectorstore",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.prairielearn_vectorstore",
        "description": "src.llm_module_generator.physics_module_generator.prairielearn_vectorstore",
        "peekOfCode": "vectorstore = Chroma.from_documents(all_docs, OpenAIEmbeddings(), persist_directory=\"./pl_chroma_db\")",
        "detail": "src.llm_module_generator.physics_module_generator.prairielearn_vectorstore",
        "documentation": {}
    },
    {
        "label": "generate",
        "kind": 2,
        "importPath": "src.llm_module_generator.physics_module_generator.templates",
        "description": "src.llm_module_generator.physics_module_generator.templates",
        "peekOfCode": "def generate():\n    # 1. Dynamic Parameter Selection:\n    # - Thoroughly analyze the HTML or data source to identify relevant categories and units for computation.\n    # - Ensure the inclusion of a diverse set of units and values, covering different global measurement systems (SI and USCS).\n    # - Implement a randomized selection algorithm that fairly alternates between unit systems (SI and USCS), ensuring balanced representation.\n    # - Avoid embedding HTML within the Python code.\n    # 2. Value Generation:\n    # - Randomly generate values relevant to the problem context, ensuring they fall within specified, realistic ranges.\n    # - Define static ranges for value generation to avoid conversion issues.\n    # - Ensure that values are generated specifically for either SI or USCS without converting between the two unless explicitly stated in the problem.",
        "detail": "src.llm_module_generator.physics_module_generator.templates",
        "documentation": {}
    },
    {
        "label": "question_html_gen_template",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.templates",
        "description": "src.llm_module_generator.physics_module_generator.templates",
        "peekOfCode": "question_html_gen_template = \"\"\"\n1. Analyze the Question\nBegin by carefully reading the physics question to determine its naturewhether it demands computational solutions or is purely theoretical. \nThis initial analysis is critical as it dictates the necessity of incorporating placeholders for numerical values. \nConsider the context and specifics of the question thoroughly to ensure the correct categorization.\n2. Identify Parameters for Computation\nFor questions requiring computational analysis:\nIdentify all numerical values that could potentially vary or would be essential for calculations. This step is paramount and must be prioritized for computational questions.\nReplace these values with placeholders using the format {{params.variable_name}}. Ensure you choose descriptive and unique names for each variable to prevent any confusion and to clearly indicate their roles in the computations.\n3. Emphasize Placeholder Implementation",
        "detail": "src.llm_module_generator.physics_module_generator.templates",
        "documentation": {}
    },
    {
        "label": "question_html_gen_template_nonadaptive",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.templates",
        "description": "src.llm_module_generator.physics_module_generator.templates",
        "peekOfCode": "question_html_gen_template_nonadaptive = \"\"\"\nGenerate a html file given the following examples\n\"\"\"\nserver_js_template_base = \"\"\"\n    Design a robust JavaScript module capable of generating computational problems across various STEM disciplines. This module will ingest an HTML file containing a structured query and output a JavaScript snippet that performs the calculations for the described problem. The JavaScript code must conform to the following outline:\n    Additionally, the only JavaScript library you are allowed to import is the mathjs library.\n    You do not have access to any external files. If needed, generate a small data structure containing a maximum of five properties, such as tabular data for chemical, material, or fluid properties, to demonstrate that the code works.\n    const generate = () => {{\n        // 1. Dynamic Parameter Selection:\n        // - Thoroughly analyze the HTML or data source to identify an extensive range of categories and units for computation.",
        "detail": "src.llm_module_generator.physics_module_generator.templates",
        "documentation": {}
    },
    {
        "label": "server_js_template_base",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.templates",
        "description": "src.llm_module_generator.physics_module_generator.templates",
        "peekOfCode": "server_js_template_base = \"\"\"\n    Design a robust JavaScript module capable of generating computational problems across various STEM disciplines. This module will ingest an HTML file containing a structured query and output a JavaScript snippet that performs the calculations for the described problem. The JavaScript code must conform to the following outline:\n    Additionally, the only JavaScript library you are allowed to import is the mathjs library.\n    You do not have access to any external files. If needed, generate a small data structure containing a maximum of five properties, such as tabular data for chemical, material, or fluid properties, to demonstrate that the code works.\n    const generate = () => {{\n        // 1. Dynamic Parameter Selection:\n        // - Thoroughly analyze the HTML or data source to identify an extensive range of categories and units for computation.\n        // - Ensure the inclusion of a wide variety of units and values, covering different global measurement systems.\n        // - Develop a randomized selection algorithm to fairly choose a category or unit system, ensuring equitable representation.\n        // - When applicable, ensure that it alternates between SI and USCS for unit selection.",
        "detail": "src.llm_module_generator.physics_module_generator.templates",
        "documentation": {}
    },
    {
        "label": "server_template_code_guide",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.templates",
        "description": "src.llm_module_generator.physics_module_generator.templates",
        "peekOfCode": "server_template_code_guide = \"\"\"\n    Additionally, you have access to both a code guide and a solution guide. The solution guide provides an accurate, step-by-step method for solving the problem, dictating the logical approach. \n    The code guide offers guidance on how to implement this solution in code, including formatting and other relevant considerations.\n\"\"\"\nsolution_html_template= \"\"\"\nObjective:\n        Develop an HTML module to generate comprehensive solutions and step-by-step guides for STEM problems. Utilize specific HTML tags for structural organization and LaTeX for mathematical equations and symbols.\n        HTML Tags and LaTeX Integration:\n        - <pl-solution-panel>: Used to encapsulate the entire solution guide.\n        - <pl-hint level=\"1\" data-type=\"text\">: Employed for providing hints and detailed step-by-step explanations within the guide.",
        "detail": "src.llm_module_generator.physics_module_generator.templates",
        "documentation": {}
    },
    {
        "label": "solution_improvement_prompt",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.templates",
        "description": "src.llm_module_generator.physics_module_generator.templates",
        "peekOfCode": "solution_improvement_prompt = \"\"\"Given the current HTML module for STEM problem-solving, your task is to enhance it using the provided code as a foundational guide. This code is designed to dynamically generate problem parameters and their correct answers. Your objective is to integrate these elements into the HTML solution guide effectively.\n        Your Specific Tasks:\n        1. **Review the Current ssolution guide  **: \n        Begin by examining the provided HTML solution guide  {solution_generated}. \n        2. **Integrate Dynamic Content Using Placeholders**: Insert placeholders into the HTML that correspond to the outputs of the code found in the params datastructure. Use placeholders like `{{params.placeholder_value}}` or `{{correct_answers.placeholder_value}}` that align with the variable names and data formats in the code. This ensures the HTML will dynamically display the correct data when the module runs.\n         Reference Code for Integration:\n         {code_guide}\n          Include your revised HTML code below:\n        return the generated code\n        \"\"\"",
        "detail": "src.llm_module_generator.physics_module_generator.templates",
        "documentation": {}
    },
    {
        "label": "server_py_template_base",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.templates",
        "description": "src.llm_module_generator.physics_module_generator.templates",
        "peekOfCode": "server_py_template_base = \"\"\"\nYou have access to Python modules such as `numpy`, `sympy`, and `pandas`, which you may use when necessary.\nYour task is to design a robust Python module that generates computational problems across various STEM disciplines. This module will ingest an HTML file containing a structured query and output a Python snippet that performs the required calculations. The Python code must adhere to the following outline:\nYou do not have access to any external files. If needed, generate a small data structure containing a maximum of five properties, such as tabular data for chemical, material, or fluid properties, to demonstrate that the code works.\n```python\ndef generate():\n    # 1. Dynamic Parameter Selection:\n    # - Thoroughly analyze the HTML or data source to identify relevant categories and units for computation.\n    # - Ensure the inclusion of a diverse set of units and values, covering different global measurement systems (SI and USCS).\n    # - Implement a randomized selection algorithm that fairly alternates between unit systems (SI and USCS), ensuring balanced representation.",
        "detail": "src.llm_module_generator.physics_module_generator.templates",
        "documentation": {}
    },
    {
        "label": "generate_metadata_template",
        "kind": 5,
        "importPath": "src.llm_module_generator.physics_module_generator.templates",
        "description": "src.llm_module_generator.physics_module_generator.templates",
        "peekOfCode": "generate_metadata_template = \"\"\" You are tasked with analyzing the given question and classifying it by generating the appropriate metadata. Use the following structure to ensure accurate classification:\nTitle: Provide a suitable title for the question in CamelCase format.\nStem: Offer additional context or subtopic related to the main topic of the question.\nTopic: Identify the main subject or topic that the question pertains to.\nTags: Provide an array of relevant keywords or tags associated with the question's content.\nPrerequisites: List any necessary prerequisites required to understand or engage with the question.\nIsAdaptive: Determine whether the question involves any numerical computation. Return true if it requires numerical computation, and false otherwise.\nquestion: {question}\"\"\"",
        "detail": "src.llm_module_generator.physics_module_generator.templates",
        "documentation": {}
    },
    {
        "label": "question_html_gen_template",
        "kind": 5,
        "importPath": "src.llm_module_generator.question_html_ui.prompt",
        "description": "src.llm_module_generator.question_html_ui.prompt",
        "peekOfCode": "question_html_gen_template = \"\"\"\n1. Analyze the Question\nBegin by carefully reading the physics question to determine its naturewhether it demands computational solutions or is purely theoretical. \nThis initial analysis is critical as it dictates the necessity of incorporating placeholders for numerical values. \nConsider the context and specifics of the question thoroughly to ensure the correct categorization.\n2. Identify Parameters for Computation\nFor questions requiring computational analysis:\nIdentify all numerical values that could potentially vary or would be essential for calculations. This step is paramount and must be prioritized for computational questions.\nReplace these values with placeholders using the format {{params.variable_name}}. Ensure you choose descriptive and unique names for each variable to prevent any confusion and to clearly indicate their roles in the computations.\n3. Emphasize Placeholder Implementation",
        "detail": "src.llm_module_generator.question_html_ui.prompt",
        "documentation": {}
    },
    {
        "label": "question_element_info",
        "kind": 5,
        "importPath": "src.llm_module_generator.question_html_ui.prompt",
        "description": "src.llm_module_generator.question_html_ui.prompt",
        "peekOfCode": "question_element_info = r\"\"\"\nThe `<pl-question-panel>` custom HTML tag is specifically designed to display content that should only be visible in the question panel of a quiz or assessment interface, as opposed to other panels such as submission or answer panels. This tag is useful in educational contexts where instructors want to provide specific instructions, hints, or direction related to a question that the student should see before they attempt to answer, but which should not be accessible after submission or while reviewing answers. By using this tag, important information can be appropriately scoped to enhance the learning experience without cluttering the user's view in different contexts.\nuse_cases:\n- Creating instructional content that only needs to be shown during the question phase, such as prompts or tips that aid in answering questions.\n- Providing context-specific information or examples right above a numerical input field, ensuring students have the necessary details without overwhelming them in the submission review.\n- Including mathematical problems or special formatting that is crucial for understanding a question, ensuring it is preserved exclusively for the initial question view.\nexample_questions:\n- What is the sum of the two numbers provided: $a = 5$ and $b = 3$?\n- Using the numbers $a = {{params.a}}$ and $b = {{params.b}}$, calculate the product. What is $p = a \\times b$?\n- Given the equation $E = mc^2$, what does each variable represent? Please provide your answer in the format: Variable: Meaning.",
        "detail": "src.llm_module_generator.question_html_ui.prompt",
        "documentation": {}
    },
    {
        "label": "full_prompt",
        "kind": 5,
        "importPath": "src.llm_module_generator.question_html_ui.prompt",
        "description": "src.llm_module_generator.question_html_ui.prompt",
        "peekOfCode": "full_prompt = f\"\"\"{question_html_gen_template} when creating the html you have access to the following custom html tags only use these keep in mind most of these are meant primarly for input  {question_element_info}\"\"\"",
        "detail": "src.llm_module_generator.question_html_ui.prompt",
        "documentation": {}
    },
    {
        "label": "TagResponse",
        "kind": 6,
        "importPath": "src.llm_module_generator.question_html_ui.question_html_builder",
        "description": "src.llm_module_generator.question_html_ui.question_html_builder",
        "peekOfCode": "class TagResponse(BaseModel):\n  element_name:str = Field(...,description=\"The name of the element\")\n  reasoning:str = Field(...,description = \"The reasoning behind why this element is appropriate for the given question\")\nclass Response(BaseModel):\n  analysis: str = Field(...,description=\"An analysis of what is required to make the given question into an online format quiz\")\n  tags: list[TagResponse] = Field(..., description=\"A list of tags appropriate for the given question\")\n# Set base directory and path to the CSS styles file\nbase_dir = os.path.dirname(os.path.abspath(__file__))\nelement_data = os.path.join(base_dir, 'element_data.csv')\n@dataclass",
        "detail": "src.llm_module_generator.question_html_ui.question_html_builder",
        "documentation": {}
    },
    {
        "label": "Response",
        "kind": 6,
        "importPath": "src.llm_module_generator.question_html_ui.question_html_builder",
        "description": "src.llm_module_generator.question_html_ui.question_html_builder",
        "peekOfCode": "class Response(BaseModel):\n  analysis: str = Field(...,description=\"An analysis of what is required to make the given question into an online format quiz\")\n  tags: list[TagResponse] = Field(..., description=\"A list of tags appropriate for the given question\")\n# Set base directory and path to the CSS styles file\nbase_dir = os.path.dirname(os.path.abspath(__file__))\nelement_data = os.path.join(base_dir, 'element_data.csv')\n@dataclass\nclass QuestionHTMLBuilder(ModuleCodeGenerator,LLMUIBuilder):\n    def __post_init__(self):\n        self.example_formatter = ExampleBasedPromptDataFrame(",
        "detail": "src.llm_module_generator.question_html_ui.question_html_builder",
        "documentation": {}
    },
    {
        "label": "QuestionHTMLBuilder",
        "kind": 6,
        "importPath": "src.llm_module_generator.question_html_ui.question_html_builder",
        "description": "src.llm_module_generator.question_html_ui.question_html_builder",
        "peekOfCode": "class QuestionHTMLBuilder(ModuleCodeGenerator,LLMUIBuilder):\n    def __post_init__(self):\n        self.example_formatter = ExampleBasedPromptDataFrame(\n            example_input_column=self.example_input_column,\n            example_output_column=self.example_output_column,\n            api_key=self.llm_config.api_key,\n            is_adaptive=self.is_adaptive\n        )\n        # Assuming element_data is defined elsewhere\n        self.df = pd.read_csv(element_data)",
        "detail": "src.llm_module_generator.question_html_ui.question_html_builder",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.llm_module_generator.question_html_ui.question_html_builder",
        "description": "src.llm_module_generator.question_html_ui.question_html_builder",
        "peekOfCode": "logger = get_logger(__name__)\nclass TagResponse(BaseModel):\n  element_name:str = Field(...,description=\"The name of the element\")\n  reasoning:str = Field(...,description = \"The reasoning behind why this element is appropriate for the given question\")\nclass Response(BaseModel):\n  analysis: str = Field(...,description=\"An analysis of what is required to make the given question into an online format quiz\")\n  tags: list[TagResponse] = Field(..., description=\"A list of tags appropriate for the given question\")\n# Set base directory and path to the CSS styles file\nbase_dir = os.path.dirname(os.path.abspath(__file__))\nelement_data = os.path.join(base_dir, 'element_data.csv')",
        "detail": "src.llm_module_generator.question_html_ui.question_html_builder",
        "documentation": {}
    },
    {
        "label": "base_dir",
        "kind": 5,
        "importPath": "src.llm_module_generator.question_html_ui.question_html_builder",
        "description": "src.llm_module_generator.question_html_ui.question_html_builder",
        "peekOfCode": "base_dir = os.path.dirname(os.path.abspath(__file__))\nelement_data = os.path.join(base_dir, 'element_data.csv')\n@dataclass\nclass QuestionHTMLBuilder(ModuleCodeGenerator,LLMUIBuilder):\n    def __post_init__(self):\n        self.example_formatter = ExampleBasedPromptDataFrame(\n            example_input_column=self.example_input_column,\n            example_output_column=self.example_output_column,\n            api_key=self.llm_config.api_key,\n            is_adaptive=self.is_adaptive",
        "detail": "src.llm_module_generator.question_html_ui.question_html_builder",
        "documentation": {}
    },
    {
        "label": "element_data",
        "kind": 5,
        "importPath": "src.llm_module_generator.question_html_ui.question_html_builder",
        "description": "src.llm_module_generator.question_html_ui.question_html_builder",
        "peekOfCode": "element_data = os.path.join(base_dir, 'element_data.csv')\n@dataclass\nclass QuestionHTMLBuilder(ModuleCodeGenerator,LLMUIBuilder):\n    def __post_init__(self):\n        self.example_formatter = ExampleBasedPromptDataFrame(\n            example_input_column=self.example_input_column,\n            example_output_column=self.example_output_column,\n            api_key=self.llm_config.api_key,\n            is_adaptive=self.is_adaptive\n        )",
        "detail": "src.llm_module_generator.question_html_ui.question_html_builder",
        "documentation": {}
    },
    {
        "label": "llm_config",
        "kind": 5,
        "importPath": "src.llm_module_generator.question_html_ui.question_html_builder",
        "description": "src.llm_module_generator.question_html_ui.question_html_builder",
        "peekOfCode": "llm_config = LLMConfig(api_key=api_key,model = \"gpt-4o-2024-08-06\",temperature=0) # type: ignore\nquestion_html_builder_advance = QuestionHTMLBuilder(\nllm_config=llm_config,\nbase_prompt=question_html_gen_template,\nexample_input_column=\"question\",\nexample_output_column=\"question.html\",css_category=\"\",num_examples=1,threshold=0.4)\nasync def main(question:str):\n   llm_config = LLMConfig(api_key=api_key,model = \"gpt-4o-2024-08-06\",temperature=0) # type: ignore\n   question_html_builder = QuestionHTMLBuilder(\n    llm_config=llm_config,",
        "detail": "src.llm_module_generator.question_html_ui.question_html_builder",
        "documentation": {}
    },
    {
        "label": "question_html_builder_advance",
        "kind": 5,
        "importPath": "src.llm_module_generator.question_html_ui.question_html_builder",
        "description": "src.llm_module_generator.question_html_ui.question_html_builder",
        "peekOfCode": "question_html_builder_advance = QuestionHTMLBuilder(\nllm_config=llm_config,\nbase_prompt=question_html_gen_template,\nexample_input_column=\"question\",\nexample_output_column=\"question.html\",css_category=\"\",num_examples=1,threshold=0.4)\nasync def main(question:str):\n   llm_config = LLMConfig(api_key=api_key,model = \"gpt-4o-2024-08-06\",temperature=0) # type: ignore\n   question_html_builder = QuestionHTMLBuilder(\n    llm_config=llm_config,\n    base_prompt=question_html_gen_template,",
        "detail": "src.llm_module_generator.question_html_ui.question_html_builder",
        "documentation": {}
    },
    {
        "label": "UIType",
        "kind": 6,
        "importPath": "src.llm_module_generator.question_html_ui.question_html_response",
        "description": "src.llm_module_generator.question_html_ui.question_html_response",
        "peekOfCode": "class UIType(str,Enum):\n        div= \"div\"\n        p = \"p\"\n        ul = \"ul\"\n        ol = \"ol\"\n        li = \"li\"\n        span = \"span\"\n        strong = \"strong\"\n        pl_question_panel = 'pl-question-panel'\n        pl_number_input = \"pl-number-input\"",
        "detail": "src.llm_module_generator.question_html_ui.question_html_response",
        "documentation": {}
    },
    {
        "label": "Attribute",
        "kind": 6,
        "importPath": "src.llm_module_generator.question_html_ui.question_html_response",
        "description": "src.llm_module_generator.question_html_ui.question_html_response",
        "peekOfCode": "class Attribute(BaseModel):\n        name: str = Field(..., description=\"Name of html attribute\")\n        value: str = Field(..., description=\"Value of the html attribute \")\nclass UI(BaseModel):\n    type: UIType\n    label: str = Field(\n        ..., \n        description=\"Content to be placed inside HTML tags. If you need to write mathematical symbols or equations, use LaTeX enclosed within `$...$` for inline math or `$$...$$` for display math to ensure compatibility with the HTML file.\"\n    )\n    children: List[\"UI\"]",
        "detail": "src.llm_module_generator.question_html_ui.question_html_response",
        "documentation": {}
    },
    {
        "label": "UI",
        "kind": 6,
        "importPath": "src.llm_module_generator.question_html_ui.question_html_response",
        "description": "src.llm_module_generator.question_html_ui.question_html_response",
        "peekOfCode": "class UI(BaseModel):\n    type: UIType\n    label: str = Field(\n        ..., \n        description=\"Content to be placed inside HTML tags. If you need to write mathematical symbols or equations, use LaTeX enclosed within `$...$` for inline math or `$$...$$` for display math to ensure compatibility with the HTML file.\"\n    )\n    children: List[\"UI\"]\n    attributes: List[Attribute]\n    _valid_css: Dict[UIType, List[str]] = {}\n    @classmethod",
        "detail": "src.llm_module_generator.question_html_ui.question_html_response",
        "documentation": {}
    },
    {
        "label": "get_css_description",
        "kind": 2,
        "importPath": "src.llm_module_generator.question_html_ui.question_html_response",
        "description": "src.llm_module_generator.question_html_ui.question_html_response",
        "peekOfCode": "def get_css_description(UItype: UIType,category_interest):\n    css_descriptions = \"\"\n    selected_css_styles = css_styles.get(category_interest, {})\n    generic_css_styles = css_styles.get(\"general_styles\", {})\n    # Combine selected and generic styles\n    available_styles = {**selected_css_styles, **generic_css_styles}\n    for uitype, css_items in available_styles.items():\n         if uitype in UIType.__members__:\n             for css_item in css_items:\n                css_descriptions += f\"\\nUI Type: {uitype}\\n\"",
        "detail": "src.llm_module_generator.question_html_ui.question_html_response",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.llm_module_generator.question_html_ui.question_html_response",
        "description": "src.llm_module_generator.question_html_ui.question_html_response",
        "peekOfCode": "logger = get_logger(__name__)\n# Set base directory and path to the CSS styles file\nbase_dir = os.path.dirname(os.path.abspath(__file__))\ncss_styles_file = os.path.join(base_dir, 'valid_css_styles_bootstrap.json')\n# Load valid CSS styles from the JSON file\ntry:\n    with open(css_styles_file, \"r\") as file:\n        css_styles = json.load(file)\n    logger.info(\"Successfully loaded CSS styles.\")\nexcept Exception as e:",
        "detail": "src.llm_module_generator.question_html_ui.question_html_response",
        "documentation": {}
    },
    {
        "label": "base_dir",
        "kind": 5,
        "importPath": "src.llm_module_generator.question_html_ui.question_html_response",
        "description": "src.llm_module_generator.question_html_ui.question_html_response",
        "peekOfCode": "base_dir = os.path.dirname(os.path.abspath(__file__))\ncss_styles_file = os.path.join(base_dir, 'valid_css_styles_bootstrap.json')\n# Load valid CSS styles from the JSON file\ntry:\n    with open(css_styles_file, \"r\") as file:\n        css_styles = json.load(file)\n    logger.info(\"Successfully loaded CSS styles.\")\nexcept Exception as e:\n    logger.error(f\"Error loading CSS styles file: {e}\")\n    css_styles = {}",
        "detail": "src.llm_module_generator.question_html_ui.question_html_response",
        "documentation": {}
    },
    {
        "label": "css_styles_file",
        "kind": 5,
        "importPath": "src.llm_module_generator.question_html_ui.question_html_response",
        "description": "src.llm_module_generator.question_html_ui.question_html_response",
        "peekOfCode": "css_styles_file = os.path.join(base_dir, 'valid_css_styles_bootstrap.json')\n# Load valid CSS styles from the JSON file\ntry:\n    with open(css_styles_file, \"r\") as file:\n        css_styles = json.load(file)\n    logger.info(\"Successfully loaded CSS styles.\")\nexcept Exception as e:\n    logger.error(f\"Error loading CSS styles file: {e}\")\n    css_styles = {}\nclass UIType(str,Enum):",
        "detail": "src.llm_module_generator.question_html_ui.question_html_response",
        "documentation": {}
    },
    {
        "label": "LLMUIBuilder",
        "kind": 6,
        "importPath": "src.llm_module_generator.ui_generator.ui_builder",
        "description": "src.llm_module_generator.ui_generator.ui_builder",
        "peekOfCode": "class LLMUIBuilder(LLM_Call):\n    \"\"\"\n    LLMUIBuilder is a subclass of LLM_Call designed to generate a user interface (UI)\n    using a large language model (LLM). The class allows the construction of a UI\n    based on a provided prompt and applies predefined CSS categories to the generated\n    UI elements.\n    Attributes:\n        llm_config (LLMConfig): Configuration for the LLM.\n        css_category (str): The category of CSS styles to apply.\n        css_description (str): A description of the CSS styles applied, initialized in `__post_init__`.",
        "detail": "src.llm_module_generator.ui_generator.ui_builder",
        "documentation": {}
    },
    {
        "label": "unescape_backslashes",
        "kind": 2,
        "importPath": "src.llm_module_generator.ui_generator.ui_builder",
        "description": "src.llm_module_generator.ui_generator.ui_builder",
        "peekOfCode": "def unescape_backslashes(latex_string):\n    return latex_string.replace('\\\\\\\\', '\\\\')\n@dataclass\nclass LLMUIBuilder(LLM_Call):\n    \"\"\"\n    LLMUIBuilder is a subclass of LLM_Call designed to generate a user interface (UI)\n    using a large language model (LLM). The class allows the construction of a UI\n    based on a provided prompt and applies predefined CSS categories to the generated\n    UI elements.\n    Attributes:",
        "detail": "src.llm_module_generator.ui_generator.ui_builder",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.llm_module_generator.ui_generator.ui_builder",
        "description": "src.llm_module_generator.ui_generator.ui_builder",
        "peekOfCode": "logger = get_logger(__name__)\ndef unescape_backslashes(latex_string):\n    return latex_string.replace('\\\\\\\\', '\\\\')\n@dataclass\nclass LLMUIBuilder(LLM_Call):\n    \"\"\"\n    LLMUIBuilder is a subclass of LLM_Call designed to generate a user interface (UI)\n    using a large language model (LLM). The class allows the construction of a UI\n    based on a provided prompt and applies predefined CSS categories to the generated\n    UI elements.",
        "detail": "src.llm_module_generator.ui_generator.ui_builder",
        "documentation": {}
    },
    {
        "label": "MultiUIContentGenerator",
        "kind": 6,
        "importPath": "src.llm_module_generator.ui_generator.ui_generators",
        "description": "src.llm_module_generator.ui_generator.ui_generators",
        "peekOfCode": "class MultiUIContentGenerator(LLMUIBuilder):\n    base_prompt: str\n    extractor: ImageToLLMProcessor    # You can pass your own extractor object\n    parser: callable  # You can pass your own parser function\n    total_tokens: int = field(default=0, init=False)\n    def __post_init__(self):\n        super().__post_init__()\n        if not hasattr(self.extractor, 'send_request') or not callable(self.extractor.send_request):\n            raise ValueError(\"Extractor must have a 'send_request' method\")\n        if not hasattr(self.extractor, 'get_total_tokens') or not callable(self.extractor.get_total_tokens):",
        "detail": "src.llm_module_generator.ui_generator.ui_generators",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.llm_module_generator.ui_generator.ui_generators",
        "description": "src.llm_module_generator.ui_generator.ui_generators",
        "peekOfCode": "logger = get_logger(__name__)\n@dataclass\nclass MultiUIContentGenerator(LLMUIBuilder):\n    base_prompt: str\n    extractor: ImageToLLMProcessor    # You can pass your own extractor object\n    parser: callable  # You can pass your own parser function\n    total_tokens: int = field(default=0, init=False)\n    def __post_init__(self):\n        super().__post_init__()\n        if not hasattr(self.extractor, 'send_request') or not callable(self.extractor.send_request):",
        "detail": "src.llm_module_generator.ui_generator.ui_generators",
        "documentation": {}
    },
    {
        "label": "llm_config",
        "kind": 5,
        "importPath": "src.llm_module_generator.ui_generator.ui_generators",
        "description": "src.llm_module_generator.ui_generator.ui_generators",
        "peekOfCode": "llm_config = LLMConfig(\n    api_key=api_key, \n    model=\"gpt-4o-mini\", \n    temperature=0\n)\n# Define the image paths\nimage_paths = [\n    r\"C:\\Users\\lberm\\OneDrive\\Desktop\\GitHub_Repository\\mechedu1.0\\mechedu1\\test_images\\textbook_section\\Screenshot 2024-08-21 191624.png\"\n]\n# Initialize all the generators",
        "detail": "src.llm_module_generator.ui_generator.ui_generators",
        "documentation": {}
    },
    {
        "label": "image_paths",
        "kind": 5,
        "importPath": "src.llm_module_generator.ui_generator.ui_generators",
        "description": "src.llm_module_generator.ui_generator.ui_generators",
        "peekOfCode": "image_paths = [\n    r\"C:\\Users\\lberm\\OneDrive\\Desktop\\GitHub_Repository\\mechedu1.0\\mechedu1\\test_images\\textbook_section\\Screenshot 2024-08-21 191624.png\"\n]\n# Initialize all the generators\nconceptual_ui_generator = MultiUIContentGenerator(\n    llm_config=llm_config,\n    css_category=\"conceptual-question-section\",\n    base_prompt=conceptual_question_ui_prompt,\n    extractor=extract_conceptual_questions,\n    parser=conceptual_questions_parser",
        "detail": "src.llm_module_generator.ui_generator.ui_generators",
        "documentation": {}
    },
    {
        "label": "conceptual_ui_generator",
        "kind": 5,
        "importPath": "src.llm_module_generator.ui_generator.ui_generators",
        "description": "src.llm_module_generator.ui_generator.ui_generators",
        "peekOfCode": "conceptual_ui_generator = MultiUIContentGenerator(\n    llm_config=llm_config,\n    css_category=\"conceptual-question-section\",\n    base_prompt=conceptual_question_ui_prompt,\n    extractor=extract_conceptual_questions,\n    parser=conceptual_questions_parser\n)\nderivation_ui_generator = MultiUIContentGenerator(\n    llm_config=llm_config,\n    css_category=\"derivation-section\",",
        "detail": "src.llm_module_generator.ui_generator.ui_generators",
        "documentation": {}
    },
    {
        "label": "derivation_ui_generator",
        "kind": 5,
        "importPath": "src.llm_module_generator.ui_generator.ui_generators",
        "description": "src.llm_module_generator.ui_generator.ui_generators",
        "peekOfCode": "derivation_ui_generator = MultiUIContentGenerator(\n    llm_config=llm_config,\n    css_category=\"derivation-section\",\n    base_prompt=derivation_ui_prompt,\n    extractor=extract_derivations,\n    parser=derivations_parser\n)\nsummary_ui_generator = MultiUIContentGenerator(\n    llm_config=llm_config,\n    css_category=\"summary_and_key_concepts\",",
        "detail": "src.llm_module_generator.ui_generator.ui_generators",
        "documentation": {}
    },
    {
        "label": "summary_ui_generator",
        "kind": 5,
        "importPath": "src.llm_module_generator.ui_generator.ui_generators",
        "description": "src.llm_module_generator.ui_generator.ui_generators",
        "peekOfCode": "summary_ui_generator = MultiUIContentGenerator(\n    llm_config=llm_config,\n    css_category=\"summary_and_key_concepts\",\n    base_prompt=summary_ui_prompt,\n    extractor=extract_summary,\n    parser=lecture_summary_parser\n)\nasync def main():\n    # Run all the generators concurrently using asyncio.gather\n    # derivation_html, conceptual_html, lecture_ui = await asyncio.gather(",
        "detail": "src.llm_module_generator.ui_generator.ui_generators",
        "documentation": {}
    },
    {
        "label": "conceptual_question_ui_prompt",
        "kind": 5,
        "importPath": "src.llm_module_generator.ui_generator.ui_prompts",
        "description": "src.llm_module_generator.ui_generator.ui_prompts",
        "peekOfCode": "conceptual_question_ui_prompt = \"\"\"\n    You are a web developer tasked with creating an engaging and informative HTML webpage based on the following extracted lecture notes. The webpage should be well-structured, visually appealing, and easy to navigate. Focus on creating a dedicated section for conceptual multiple-choice questions, ensuring that each question is easy to read and interact with. Use LaTeX to format any mathematical symbols or equations as needed.\n    **Instructions:**\n    1. **Conceptual Questions**:\n       - Each question should have an appropriate, descriptive name that clearly summarizes the topic or concept being tested (e.g., \"Newton's Third Law\").\n       - Present each question in a clear and structured format with four possible answer choices labeled (A), (B), (C), and (D).\n       - Use proper HTML tags to ensure readability, such as `<h1>` for the question title, `<h2>` for the question text, and an unordered list (`<ul>`) for the answer choices.\n       - Clearly indicate the correct answer for each question, either by adding a note or by using a specific class or tag.\n       - If any mathematical notation is required within the question or answer choices, use LaTeX formatting.\n    **Example Format** (for reference only, do not include this in your output):",
        "detail": "src.llm_module_generator.ui_generator.ui_prompts",
        "documentation": {}
    },
    {
        "label": "derivation_ui_prompt",
        "kind": 5,
        "importPath": "src.llm_module_generator.ui_generator.ui_prompts",
        "description": "src.llm_module_generator.ui_generator.ui_prompts",
        "peekOfCode": "derivation_ui_prompt = \"\"\"\n    You are a web developer tasked with creating an engaging, well-structured, and informative HTML webpage based on the following extracted lecture notes. The webpage should prioritize clarity, ease of navigation, and visual appeal, with a focus on presenting mathematical derivations.\n    **Goal:**\n    The purpose of the webpage is to clearly showcase mathematical derivations and logical arguments from the lecture in a way that is easy to read, well-organized, and aesthetically pleasing. Pay particular attention to the presentation of the derivation steps and ensure that all mathematical symbols or equations are properly formatted using LaTeX.\n    **Instructions:**\n    1. **Derivations**:\n       - For each derivation, generate a **descriptive name** that summarizes the key concept or mathematical principle being derived.\n       - Present the derivation or logical argument in full, broken down into clear, understandable steps:\n         - **Use Ordered Lists** to display the step-by-step process, ensuring that each step is easy to follow.\n         - Provide a concise **explanation** for each step using HTML `<p>` tags for descriptions.",
        "detail": "src.llm_module_generator.ui_generator.ui_prompts",
        "documentation": {}
    },
    {
        "label": "summary_ui_prompt",
        "kind": 5,
        "importPath": "src.llm_module_generator.ui_generator.ui_prompts",
        "description": "src.llm_module_generator.ui_generator.ui_prompts",
        "peekOfCode": "summary_ui_prompt = f\"\"\"\n    You are a web developer tasked with creating an engaging and informative HTML webpage based on the following extracted lecture notes. The webpage should be well-structured, visually appealing, and easy to navigate. Focus on the specific sections outlined below, and ensure proper formatting for mathematical symbols or equations using LaTeX.\n    **Summary Section:**\n        - Use a `div` container for the summary content.\n        - Present key points in bullet form using unordered lists (`ul`) where applicable, or in paragraphs if the content is more narrative.\n        - Ensure the summary highlights the most critical information from the lecture, providing readers with a concise overview.\n    **Key Concepts Section:**\n        - Use a `div` container for the Key Concepts content.\n        - Present key concepts in bullet form using unordered lists (`ul`), or in paragraphs for more detailed explanations.\n        - Ensure key concepts are clearly structured and easy to identify.",
        "detail": "src.llm_module_generator.ui_generator.ui_prompts",
        "documentation": {}
    },
    {
        "label": "UIType",
        "kind": 6,
        "importPath": "src.llm_module_generator.ui_generator.ui_response",
        "description": "src.llm_module_generator.ui_generator.ui_response",
        "peekOfCode": "class UIType(str,Enum):\n        div = \"div\"\n        p = \"p\"\n        ul = \"ul\"\n        ol = \"ol\"\n        li = \"li\"\n        h1 = \"h1\"\n        h2 = \"h2\"\n        span = \"span\"\n        strong = \"strong\"",
        "detail": "src.llm_module_generator.ui_generator.ui_response",
        "documentation": {}
    },
    {
        "label": "Attribute",
        "kind": 6,
        "importPath": "src.llm_module_generator.ui_generator.ui_response",
        "description": "src.llm_module_generator.ui_generator.ui_response",
        "peekOfCode": "class Attribute(BaseModel):\n        name: str = Field(..., description=\"Name of html attribute\")\n        value: str = Field(..., description=\"Value of the html attribute \")                \nclass UI(BaseModel):\n    type: UIType\n    label: str = Field(..., description=\"Content to be placed inside HTML tags. If you need to write mathematical symbols or equations, use LaTeX enclosed within `$...$` for inline math or `$$...$$` for display math to ensure compatibility with the HTML file.\")\n    children: List[\"UI\"]\n    attributes: List[Attribute]\n    _valid_css: Dict[UIType, List[str]] = {}\n    @classmethod",
        "detail": "src.llm_module_generator.ui_generator.ui_response",
        "documentation": {}
    },
    {
        "label": "UI",
        "kind": 6,
        "importPath": "src.llm_module_generator.ui_generator.ui_response",
        "description": "src.llm_module_generator.ui_generator.ui_response",
        "peekOfCode": "class UI(BaseModel):\n    type: UIType\n    label: str = Field(..., description=\"Content to be placed inside HTML tags. If you need to write mathematical symbols or equations, use LaTeX enclosed within `$...$` for inline math or `$$...$$` for display math to ensure compatibility with the HTML file.\")\n    children: List[\"UI\"]\n    attributes: List[Attribute]\n    _valid_css: Dict[UIType, List[str]] = {}\n    @classmethod\n    def set_valid_css(cls, category_interest: str = None): # type: ignore\n        cls._valid_css = {}  # Resetting the valid CSS dictionary\n        selected_css_styles = css_styles.get(category_interest, {})",
        "detail": "src.llm_module_generator.ui_generator.ui_response",
        "documentation": {}
    },
    {
        "label": "get_css_description",
        "kind": 2,
        "importPath": "src.llm_module_generator.ui_generator.ui_response",
        "description": "src.llm_module_generator.ui_generator.ui_response",
        "peekOfCode": "def get_css_description(UItype: UIType,category_interest):\n    css_descriptions = \"\"\n    selected_css_styles = css_styles.get(category_interest, {})\n    generic_css_styles = css_styles.get(\"general_styles\", {})\n    # Combine selected and generic styles\n    available_styles = {**selected_css_styles, **generic_css_styles}\n    for uitype, css_items in available_styles.items():\n         if uitype in UIType.__members__:\n             for css_item in css_items:\n                css_descriptions += f\"\\nUI Type: {uitype}\\n\"",
        "detail": "src.llm_module_generator.ui_generator.ui_response",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.llm_module_generator.ui_generator.ui_response",
        "description": "src.llm_module_generator.ui_generator.ui_response",
        "peekOfCode": "logger = get_logger(__name__)\nbase_dir = os.path.dirname(os.path.abspath(__file__))\ncss_styles_file = os.path.join(base_dir, 'valid_css_styles_new.json')\nwith open(css_styles_file,\"r\") as file:\n    css_styles = json.load(file)\nprint(css_styles)\nclass UIType(str,Enum):\n        div = \"div\"\n        p = \"p\"\n        ul = \"ul\"",
        "detail": "src.llm_module_generator.ui_generator.ui_response",
        "documentation": {}
    },
    {
        "label": "base_dir",
        "kind": 5,
        "importPath": "src.llm_module_generator.ui_generator.ui_response",
        "description": "src.llm_module_generator.ui_generator.ui_response",
        "peekOfCode": "base_dir = os.path.dirname(os.path.abspath(__file__))\ncss_styles_file = os.path.join(base_dir, 'valid_css_styles_new.json')\nwith open(css_styles_file,\"r\") as file:\n    css_styles = json.load(file)\nprint(css_styles)\nclass UIType(str,Enum):\n        div = \"div\"\n        p = \"p\"\n        ul = \"ul\"\n        ol = \"ol\"",
        "detail": "src.llm_module_generator.ui_generator.ui_response",
        "documentation": {}
    },
    {
        "label": "css_styles_file",
        "kind": 5,
        "importPath": "src.llm_module_generator.ui_generator.ui_response",
        "description": "src.llm_module_generator.ui_generator.ui_response",
        "peekOfCode": "css_styles_file = os.path.join(base_dir, 'valid_css_styles_new.json')\nwith open(css_styles_file,\"r\") as file:\n    css_styles = json.load(file)\nprint(css_styles)\nclass UIType(str,Enum):\n        div = \"div\"\n        p = \"p\"\n        ul = \"ul\"\n        ol = \"ol\"\n        li = \"li\"",
        "detail": "src.llm_module_generator.ui_generator.ui_response",
        "documentation": {}
    },
    {
        "label": "Response",
        "kind": 6,
        "importPath": "src.llm_module_generator.utils",
        "description": "src.llm_module_generator.utils",
        "peekOfCode": "class Response(BaseModel):\n    question: str = Field(..., description=\"The full question that will be converted into an online assessment.\")\n    additional_instructions: Optional[str] = Field(None, description=\"The cleaned up additional instructions.\")\n    units: Optional[List[str]] = Field(None, description=\"Extracted units from the question (e.g., kW, J, mph, ft).\")\nasync def analyze_input_query(query:str):\n    llm = LLM_Call(LLMConfig(api_key, \"gpt-4o-mini\",0))\n    prompt = f\"\"\"\n    You are tasked with analyzing and refining a given query, which will be used to generate complete, answerable questions for an online educational assessment for students. The goal of this analysis is to convert the input into questions that can be part of an online module, ensuring the questions are relevant, usable, and clearly defined for students. The process of refining and extracting the question and instructions should help define the scope of the module, making sure it aligns with the learning objectives.\n    The query may come in different forms:\n    - A clear, complete question.",
        "detail": "src.llm_module_generator.utils",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "kind": 2,
        "importPath": "src.logging_config.logging_config",
        "description": "src.logging_config.logging_config",
        "peekOfCode": "def get_logger(name):\n    return logging.getLogger(name)",
        "detail": "src.logging_config.logging_config",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-answer-panel.pl-answer-panel",
        "description": "src.prairielearn.elements.pl-answer-panel.pl-answer-panel",
        "peekOfCode": "def prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    pl.check_attribs(element, required_attribs=[], optional_attribs=[])\ndef render(element_html: str, data: pl.QuestionData) -> str:\n    if data[\"panel\"] == \"answer\":\n        element = lxml.html.fragment_fromstring(element_html)\n        return pl.inner_html(element)\n    return \"\"",
        "detail": "src.prairielearn.elements.pl-answer-panel.pl-answer-panel",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-answer-panel.pl-answer-panel",
        "description": "src.prairielearn.elements.pl-answer-panel.pl-answer-panel",
        "peekOfCode": "def render(element_html: str, data: pl.QuestionData) -> str:\n    if data[\"panel\"] == \"answer\":\n        element = lxml.html.fragment_fromstring(element_html)\n        return pl.inner_html(element)\n    return \"\"",
        "detail": "src.prairielearn.elements.pl-answer-panel.pl-answer-panel",
        "documentation": {}
    },
    {
        "label": "src_dir",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-answer-panel.pl-answer-panel",
        "description": "src.prairielearn.elements.pl-answer-panel.pl-answer-panel",
        "peekOfCode": "src_dir = os.path.join(os.getcwd(), 'src')\n# Add 'src' to sys.path if it's not already present\nif src_dir not in sys.path:\n    sys.path.insert(0, src_dir)\n# Try to import the 'prairielearn' module\ntry:\n    from prairielearn.python import prairielearn as pl\nexcept ImportError as e:\n    print(f\"Error importing prairielearn module: {e}\")\ndef prepare(element_html: str, data: pl.QuestionData) -> None:",
        "detail": "src.prairielearn.elements.pl-answer-panel.pl-answer-panel",
        "documentation": {}
    },
    {
        "label": "grade_o_expression",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "description": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "peekOfCode": "def grade_o_expression(\n    a_true: str, a_sub: str, variables: List[str]\n) -> Tuple[float, str]:\n    sym_true, sym_true_source = phs.convert_string_to_sympy_with_source(\n        a_true, variables, allow_complex=False, allow_trig_functions=False\n    )\n    sym_sub, sym_sub_source = phs.convert_string_to_sympy_with_source(\n        a_sub, variables, allow_complex=False, allow_trig_functions=False\n    )\n    if sym_true_source == sym_sub_source:",
        "detail": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "documentation": {}
    },
    {
        "label": "grade_theta_expression",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "description": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "peekOfCode": "def grade_theta_expression(\n    a_true: str, a_sub: str, variables: List[str]\n) -> Tuple[float, str]:\n    sym_true, sym_true_source = phs.convert_string_to_sympy_with_source(\n        a_true, variables, allow_complex=False, allow_trig_functions=False\n    )\n    sym_sub, sym_sub_source = phs.convert_string_to_sympy_with_source(\n        a_sub, variables, allow_complex=False, allow_trig_functions=False\n    )\n    if sym_true_source == sym_sub_source:",
        "detail": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "documentation": {}
    },
    {
        "label": "grade_omega_expression",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "description": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "peekOfCode": "def grade_omega_expression(\n    a_true: str, a_sub: str, variables: List[str]\n) -> Tuple[float, str]:\n    sym_true, sym_true_source = phs.convert_string_to_sympy_with_source(\n        a_true, variables, allow_complex=False, allow_trig_functions=False\n    )\n    sym_sub, sym_sub_source = phs.convert_string_to_sympy_with_source(\n        a_sub, variables, allow_complex=False, allow_trig_functions=False\n    )\n    if sym_true_source == sym_sub_source:",
        "detail": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "documentation": {}
    },
    {
        "label": "BigOGradingFunctionT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "description": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "peekOfCode": "BigOGradingFunctionT = Callable[[str, str, List[str]], Tuple[float, str]]\nTYPE_ERROR_FEEDBACK = (\n    \"Your answer could not be processed by the autograder. Did you divide by 0?\"\n)\nCORRECT_UNCONDITIONAL_FEEDBACK = \"Correct!\"\nCORRECT_COMPLEX_FEEDBACK = (\n    \"Correct! Note that your expression may be unnecessarily complex.\"\n)\nNEGATIVE_FEEDBACK = \"Your expression is negative.\"\nINCORRECT_FEEDBACK = \"Your answer is incorrect.\"",
        "detail": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "documentation": {}
    },
    {
        "label": "TYPE_ERROR_FEEDBACK",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "description": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "peekOfCode": "TYPE_ERROR_FEEDBACK = (\n    \"Your answer could not be processed by the autograder. Did you divide by 0?\"\n)\nCORRECT_UNCONDITIONAL_FEEDBACK = \"Correct!\"\nCORRECT_COMPLEX_FEEDBACK = (\n    \"Correct! Note that your expression may be unnecessarily complex.\"\n)\nNEGATIVE_FEEDBACK = \"Your expression is negative.\"\nINCORRECT_FEEDBACK = \"Your answer is incorrect.\"\nTOO_LOOSE_FEEDBACK = \"Your answer is correct, but too loose.\"",
        "detail": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "documentation": {}
    },
    {
        "label": "CORRECT_UNCONDITIONAL_FEEDBACK",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "description": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "peekOfCode": "CORRECT_UNCONDITIONAL_FEEDBACK = \"Correct!\"\nCORRECT_COMPLEX_FEEDBACK = (\n    \"Correct! Note that your expression may be unnecessarily complex.\"\n)\nNEGATIVE_FEEDBACK = \"Your expression is negative.\"\nINCORRECT_FEEDBACK = \"Your answer is incorrect.\"\nTOO_LOOSE_FEEDBACK = \"Your answer is correct, but too loose.\"\nLOWER_ORDER_TERMS_FEEDBACK = (\n    \"Your answer is correct, but you have unnecessary lower order terms.\"\n)",
        "detail": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "documentation": {}
    },
    {
        "label": "CORRECT_COMPLEX_FEEDBACK",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "description": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "peekOfCode": "CORRECT_COMPLEX_FEEDBACK = (\n    \"Correct! Note that your expression may be unnecessarily complex.\"\n)\nNEGATIVE_FEEDBACK = \"Your expression is negative.\"\nINCORRECT_FEEDBACK = \"Your answer is incorrect.\"\nTOO_LOOSE_FEEDBACK = \"Your answer is correct, but too loose.\"\nLOWER_ORDER_TERMS_FEEDBACK = (\n    \"Your answer is correct, but you have unnecessary lower order terms.\"\n)\nCONSTANT_FACTORS_FEEDBACK = (",
        "detail": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "documentation": {}
    },
    {
        "label": "NEGATIVE_FEEDBACK",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "description": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "peekOfCode": "NEGATIVE_FEEDBACK = \"Your expression is negative.\"\nINCORRECT_FEEDBACK = \"Your answer is incorrect.\"\nTOO_LOOSE_FEEDBACK = \"Your answer is correct, but too loose.\"\nLOWER_ORDER_TERMS_FEEDBACK = (\n    \"Your answer is correct, but you have unnecessary lower order terms.\"\n)\nCONSTANT_FACTORS_FEEDBACK = (\n    \"Your answer is correct but has unncessary constant factors.\"\n)\nTHETA_CONSTANT_FACTORS_FEEDBACK = (",
        "detail": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "documentation": {}
    },
    {
        "label": "INCORRECT_FEEDBACK",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "description": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "peekOfCode": "INCORRECT_FEEDBACK = \"Your answer is incorrect.\"\nTOO_LOOSE_FEEDBACK = \"Your answer is correct, but too loose.\"\nLOWER_ORDER_TERMS_FEEDBACK = (\n    \"Your answer is correct, but you have unnecessary lower order terms.\"\n)\nCONSTANT_FACTORS_FEEDBACK = (\n    \"Your answer is correct but has unncessary constant factors.\"\n)\nTHETA_CONSTANT_FACTORS_FEEDBACK = (\n    \"Incorrect, your answer has unnecessary constant factors.\"",
        "detail": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "documentation": {}
    },
    {
        "label": "TOO_LOOSE_FEEDBACK",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "description": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "peekOfCode": "TOO_LOOSE_FEEDBACK = \"Your answer is correct, but too loose.\"\nLOWER_ORDER_TERMS_FEEDBACK = (\n    \"Your answer is correct, but you have unnecessary lower order terms.\"\n)\nCONSTANT_FACTORS_FEEDBACK = (\n    \"Your answer is correct but has unncessary constant factors.\"\n)\nTHETA_CONSTANT_FACTORS_FEEDBACK = (\n    \"Incorrect, your answer has unnecessary constant factors.\"\n)",
        "detail": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "documentation": {}
    },
    {
        "label": "LOWER_ORDER_TERMS_FEEDBACK",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "description": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "peekOfCode": "LOWER_ORDER_TERMS_FEEDBACK = (\n    \"Your answer is correct, but you have unnecessary lower order terms.\"\n)\nCONSTANT_FACTORS_FEEDBACK = (\n    \"Your answer is correct but has unncessary constant factors.\"\n)\nTHETA_CONSTANT_FACTORS_FEEDBACK = (\n    \"Incorrect, your answer has unnecessary constant factors.\"\n)\nTHETA_LOWER_ORDER_TERMS_FEEDBACK = (",
        "detail": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "documentation": {}
    },
    {
        "label": "CONSTANT_FACTORS_FEEDBACK",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "description": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "peekOfCode": "CONSTANT_FACTORS_FEEDBACK = (\n    \"Your answer is correct but has unncessary constant factors.\"\n)\nTHETA_CONSTANT_FACTORS_FEEDBACK = (\n    \"Incorrect, your answer has unnecessary constant factors.\"\n)\nTHETA_LOWER_ORDER_TERMS_FEEDBACK = (\n    \"Incorrect, your answer has unnecessary lower order terms.\"\n)\ndef grade_o_expression(",
        "detail": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "documentation": {}
    },
    {
        "label": "THETA_CONSTANT_FACTORS_FEEDBACK",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "description": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "peekOfCode": "THETA_CONSTANT_FACTORS_FEEDBACK = (\n    \"Incorrect, your answer has unnecessary constant factors.\"\n)\nTHETA_LOWER_ORDER_TERMS_FEEDBACK = (\n    \"Incorrect, your answer has unnecessary lower order terms.\"\n)\ndef grade_o_expression(\n    a_true: str, a_sub: str, variables: List[str]\n) -> Tuple[float, str]:\n    sym_true, sym_true_source = phs.convert_string_to_sympy_with_source(",
        "detail": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "documentation": {}
    },
    {
        "label": "THETA_LOWER_ORDER_TERMS_FEEDBACK",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "description": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "peekOfCode": "THETA_LOWER_ORDER_TERMS_FEEDBACK = (\n    \"Incorrect, your answer has unnecessary lower order terms.\"\n)\ndef grade_o_expression(\n    a_true: str, a_sub: str, variables: List[str]\n) -> Tuple[float, str]:\n    sym_true, sym_true_source = phs.convert_string_to_sympy_with_source(\n        a_true, variables, allow_complex=False, allow_trig_functions=False\n    )\n    sym_sub, sym_sub_source = phs.convert_string_to_sympy_with_source(",
        "detail": "src.prairielearn.elements.pl-big-o-input.big_o_utils",
        "documentation": {}
    },
    {
        "label": "TestBigOInput",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-big-o-input.big_o_utils_test",
        "description": "src.prairielearn.elements.pl-big-o-input.big_o_utils_test",
        "peekOfCode": "class TestBigOInput:\n    @pytest.mark.parametrize(\n        \"a_true, a_sub\",\n        [\n            (\"n**2\", \"n**2\"),\n            (\"n**2\", \"n ** 2\"),\n            (\"n**2\", \"n^2\"),\n            (\"n^2\", \"n**2\"),\n            (\"factorial(n)\", \"n!\"),\n            (\"log(n)\", \"log n\"),",
        "detail": "src.prairielearn.elements.pl-big-o-input.big_o_utils_test",
        "documentation": {}
    },
    {
        "label": "TestExceptions",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-big-o-input.big_o_utils_test",
        "description": "src.prairielearn.elements.pl-big-o-input.big_o_utils_test",
        "peekOfCode": "class TestExceptions:\n    @pytest.mark.parametrize(\"a_sub\", [\"tan(n)\", \"sin(n)\", \"cos(n)\", \"arccos(n)\"])\n    @pytest.mark.parametrize(\"grading_fn\", ALL_GRADING_FUNCTIONS)\n    def test_invalid_trig_function(\n        self, a_sub: str, grading_fn: bou.BigOGradingFunctionT\n    ) -> None:\n        a_true = \"n**2\"\n        # Test for invalid functions in student submission and solution\n        with pytest.raises((phs.HasInvalidSymbolError, phs.HasInvalidFunctionError)):\n            grading_fn(a_true, a_sub, VARIABLES)",
        "detail": "src.prairielearn.elements.pl-big-o-input.big_o_utils_test",
        "documentation": {}
    },
    {
        "label": "VARIABLES",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-big-o-input.big_o_utils_test",
        "description": "src.prairielearn.elements.pl-big-o-input.big_o_utils_test",
        "peekOfCode": "VARIABLES = [\"n\"]\nALL_GRADING_FUNCTIONS = [\n    bou.grade_o_expression,\n    bou.grade_theta_expression,\n    bou.grade_omega_expression,\n]\nclass TestBigOInput:\n    @pytest.mark.parametrize(\n        \"a_true, a_sub\",\n        [",
        "detail": "src.prairielearn.elements.pl-big-o-input.big_o_utils_test",
        "documentation": {}
    },
    {
        "label": "ALL_GRADING_FUNCTIONS",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-big-o-input.big_o_utils_test",
        "description": "src.prairielearn.elements.pl-big-o-input.big_o_utils_test",
        "peekOfCode": "ALL_GRADING_FUNCTIONS = [\n    bou.grade_o_expression,\n    bou.grade_theta_expression,\n    bou.grade_omega_expression,\n]\nclass TestBigOInput:\n    @pytest.mark.parametrize(\n        \"a_true, a_sub\",\n        [\n            (\"n**2\", \"n**2\"),",
        "detail": "src.prairielearn.elements.pl-big-o-input.big_o_utils_test",
        "documentation": {}
    },
    {
        "label": "BigOType",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "description": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "peekOfCode": "class BigOType(Enum):\n    BIG_O = r\"O\"\n    THETA = r\"\\Theta\"\n    OMEGA = r\"\\Omega\"\n    LITTLE_O = r\"o\"\n    LITTLE_OMEGA = r\"\\omega\"\nclass DisplayType(Enum):\n    INLINE = \"inline\"\n    BLOCK = \"block\"\nGRADE_FUNCTION_DICT: dict[BigOType, bou.BigOGradingFunctionT] = {",
        "detail": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "documentation": {}
    },
    {
        "label": "DisplayType",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "description": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "peekOfCode": "class DisplayType(Enum):\n    INLINE = \"inline\"\n    BLOCK = \"block\"\nGRADE_FUNCTION_DICT: dict[BigOType, bou.BigOGradingFunctionT] = {\n    BigOType.BIG_O: bou.grade_o_expression,\n    BigOType.THETA: bou.grade_theta_expression,\n    BigOType.OMEGA: bou.grade_omega_expression,\n    BigOType.LITTLE_O: bou.grade_o_expression,\n    BigOType.LITTLE_OMEGA: bou.grade_omega_expression,\n}",
        "detail": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "description": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "peekOfCode": "def prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",\n        \"correct-answer\",\n        \"variable\",\n        \"size\",\n        \"display\",\n        \"show-help-text\",",
        "detail": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "description": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "peekOfCode": "def render(element_html: str, data: pl.QuestionData) -> str:\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    variables = phs.get_items_list(\n        pl.get_string_attrib(element, \"variable\", VARIABLES_DEFAULT)\n    )\n    display = pl.get_enum_attrib(element, \"display\", DisplayType, DISPLAY_DEFAULT)\n    size = pl.get_integer_attrib(element, \"size\", SIZE_DEFAULT)\n    bigo_type = pl.get_enum_attrib(element, \"type\", BigOType, BIG_O_TYPE_DEFAULT).value\n    placeholder = pl.get_string_attrib(element, \"placeholder\", PLACEHOLDER_DEFAULT)",
        "detail": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "description": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "peekOfCode": "def parse(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    variables = phs.get_items_list(\n        pl.get_string_attrib(element, \"variable\", VARIABLES_DEFAULT)\n    )\n    allow_blank = pl.get_boolean_attrib(element, \"allow-blank\", ALLOW_BLANK_DEFAULT)\n    blank_value = pl.get_string_attrib(element, \"blank-value\", BLANK_VALUE_DEFAULT)\n    # Get submitted answer or return parse_error if it does not exist\n    a_sub = data[\"submitted_answers\"].get(name)",
        "detail": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "documentation": {}
    },
    {
        "label": "grade",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "description": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "peekOfCode": "def grade(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    variables = phs.get_items_list(\n        pl.get_string_attrib(element, \"variable\", VARIABLES_DEFAULT)\n    )\n    weight = pl.get_integer_attrib(element, \"weight\", WEIGHT_DEFAULT)\n    a_tru: str | None = data[\"correct_answers\"].get(name)\n    # No need to grade if no correct answer given\n    if a_tru is None:",
        "detail": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "description": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "peekOfCode": "def test(element_html: str, data: pl.ElementTestData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    weight = pl.get_integer_attrib(element, \"weight\", WEIGHT_DEFAULT)\n    # Get raw correct answer\n    a_tru = data[\"correct_answers\"][name]\n    result = data[\"test_type\"]\n    if result == \"correct\":\n        data[\"raw_submitted_answers\"][name] = a_tru\n        data[\"partial_scores\"][name] = {",
        "detail": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "documentation": {}
    },
    {
        "label": "VARIABLES_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "description": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "peekOfCode": "VARIABLES_DEFAULT = \"\"\nSIZE_DEFAULT = 35\nSHOW_HELP_TEXT_DEFAULT = True\nWEIGHT_DEFAULT = 1\nDISPLAY_DEFAULT = DisplayType.INLINE\nBIG_O_TYPE_DEFAULT = BigOType.BIG_O\nPLACEHOLDER_DEFAULT = \"asymptotic expression\"\nSHOW_SCORE_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = \"1\"",
        "detail": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "documentation": {}
    },
    {
        "label": "SIZE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "description": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "peekOfCode": "SIZE_DEFAULT = 35\nSHOW_HELP_TEXT_DEFAULT = True\nWEIGHT_DEFAULT = 1\nDISPLAY_DEFAULT = DisplayType.INLINE\nBIG_O_TYPE_DEFAULT = BigOType.BIG_O\nPLACEHOLDER_DEFAULT = \"asymptotic expression\"\nSHOW_SCORE_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = \"1\"\nBIG_O_INPUT_MUSTACHE_TEMPLATE_NAME = \"pl-big-o-input.mustache\"",
        "detail": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "documentation": {}
    },
    {
        "label": "SHOW_HELP_TEXT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "description": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "peekOfCode": "SHOW_HELP_TEXT_DEFAULT = True\nWEIGHT_DEFAULT = 1\nDISPLAY_DEFAULT = DisplayType.INLINE\nBIG_O_TYPE_DEFAULT = BigOType.BIG_O\nPLACEHOLDER_DEFAULT = \"asymptotic expression\"\nSHOW_SCORE_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = \"1\"\nBIG_O_INPUT_MUSTACHE_TEMPLATE_NAME = \"pl-big-o-input.mustache\"\ndef prepare(element_html: str, data: pl.QuestionData) -> None:",
        "detail": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "documentation": {}
    },
    {
        "label": "WEIGHT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "description": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "peekOfCode": "WEIGHT_DEFAULT = 1\nDISPLAY_DEFAULT = DisplayType.INLINE\nBIG_O_TYPE_DEFAULT = BigOType.BIG_O\nPLACEHOLDER_DEFAULT = \"asymptotic expression\"\nSHOW_SCORE_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = \"1\"\nBIG_O_INPUT_MUSTACHE_TEMPLATE_NAME = \"pl-big-o-input.mustache\"\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)",
        "detail": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "documentation": {}
    },
    {
        "label": "DISPLAY_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "description": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "peekOfCode": "DISPLAY_DEFAULT = DisplayType.INLINE\nBIG_O_TYPE_DEFAULT = BigOType.BIG_O\nPLACEHOLDER_DEFAULT = \"asymptotic expression\"\nSHOW_SCORE_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = \"1\"\nBIG_O_INPUT_MUSTACHE_TEMPLATE_NAME = \"pl-big-o-input.mustache\"\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]",
        "detail": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "documentation": {}
    },
    {
        "label": "BIG_O_TYPE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "description": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "peekOfCode": "BIG_O_TYPE_DEFAULT = BigOType.BIG_O\nPLACEHOLDER_DEFAULT = \"asymptotic expression\"\nSHOW_SCORE_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = \"1\"\nBIG_O_INPUT_MUSTACHE_TEMPLATE_NAME = \"pl-big-o-input.mustache\"\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [",
        "detail": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "documentation": {}
    },
    {
        "label": "PLACEHOLDER_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "description": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "peekOfCode": "PLACEHOLDER_DEFAULT = \"asymptotic expression\"\nSHOW_SCORE_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = \"1\"\nBIG_O_INPUT_MUSTACHE_TEMPLATE_NAME = \"pl-big-o-input.mustache\"\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",",
        "detail": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "documentation": {}
    },
    {
        "label": "SHOW_SCORE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "description": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "peekOfCode": "SHOW_SCORE_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = \"1\"\nBIG_O_INPUT_MUSTACHE_TEMPLATE_NAME = \"pl-big-o-input.mustache\"\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",\n        \"correct-answer\",",
        "detail": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "documentation": {}
    },
    {
        "label": "ALLOW_BLANK_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "description": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "peekOfCode": "ALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = \"1\"\nBIG_O_INPUT_MUSTACHE_TEMPLATE_NAME = \"pl-big-o-input.mustache\"\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",\n        \"correct-answer\",\n        \"variable\",",
        "detail": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "documentation": {}
    },
    {
        "label": "BLANK_VALUE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "description": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "peekOfCode": "BLANK_VALUE_DEFAULT = \"1\"\nBIG_O_INPUT_MUSTACHE_TEMPLATE_NAME = \"pl-big-o-input.mustache\"\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",\n        \"correct-answer\",\n        \"variable\",\n        \"size\",",
        "detail": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "documentation": {}
    },
    {
        "label": "BIG_O_INPUT_MUSTACHE_TEMPLATE_NAME",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "description": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "peekOfCode": "BIG_O_INPUT_MUSTACHE_TEMPLATE_NAME = \"pl-big-o-input.mustache\"\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",\n        \"correct-answer\",\n        \"variable\",\n        \"size\",\n        \"display\",",
        "detail": "src.prairielearn.elements.pl-big-o-input.pl-big-o-input",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-card.pl-card",
        "description": "src.prairielearn.elements.pl-card.pl-card",
        "peekOfCode": "def prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = []\n    optional_attribs = [\n        \"header\",\n        \"title\",\n        \"subtitle\",\n        \"footer\",\n        \"img-top-src\",\n        \"img-top-alt\",",
        "detail": "src.prairielearn.elements.pl-card.pl-card",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-card.pl-card",
        "description": "src.prairielearn.elements.pl-card.pl-card",
        "peekOfCode": "def render(element_html: str, data: pl.QuestionData) -> str:\n    element = lxml.html.fragment_fromstring(element_html)\n    header = pl.get_string_attrib(element, \"header\", HEADER_DEFAULT)\n    title = pl.get_string_attrib(element, \"title\", TITLE_DEFAULT)\n    subtitle = pl.get_string_attrib(element, \"subtitle\", SUBTITLE_DEFAULT)\n    footer = pl.get_string_attrib(element, \"footer\", FOOTER_DEFAULT)\n    img_top_src = pl.get_string_attrib(element, \"img-top-src\", IMG_TOP_SRC_DEFAULT)\n    img_top_alt = pl.get_string_attrib(element, \"img-top-alt\", IMG_TOP_ALT_DEFAULT)\n    img_bottom_src = pl.get_string_attrib(\n        element, \"img-bottom-src\", IMG_BOTTOM_SRC_DEFAULT",
        "detail": "src.prairielearn.elements.pl-card.pl-card",
        "documentation": {}
    },
    {
        "label": "HEADER_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-card.pl-card",
        "description": "src.prairielearn.elements.pl-card.pl-card",
        "peekOfCode": "HEADER_DEFAULT = \"\"\nTITLE_DEFAULT = \"\"\nSUBTITLE_DEFAULT = \"\"\nFOOTER_DEFAULT = \"\"\nIMG_TOP_SRC_DEFAULT = \"\"\nIMG_TOP_ALT_DEFAULT = \"\"\nIMG_BOTTOM_SRC_DEFAULT = \"\"\nIMG_BOTTOM_ALT_DEFAULT = \"\"\nWIDTH_DEFAULT = \"auto\"\ncurrent_module_path = os.path.abspath(__file__)",
        "detail": "src.prairielearn.elements.pl-card.pl-card",
        "documentation": {}
    },
    {
        "label": "TITLE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-card.pl-card",
        "description": "src.prairielearn.elements.pl-card.pl-card",
        "peekOfCode": "TITLE_DEFAULT = \"\"\nSUBTITLE_DEFAULT = \"\"\nFOOTER_DEFAULT = \"\"\nIMG_TOP_SRC_DEFAULT = \"\"\nIMG_TOP_ALT_DEFAULT = \"\"\nIMG_BOTTOM_SRC_DEFAULT = \"\"\nIMG_BOTTOM_ALT_DEFAULT = \"\"\nWIDTH_DEFAULT = \"auto\"\ncurrent_module_path = os.path.abspath(__file__)\nprint(current_module_path)",
        "detail": "src.prairielearn.elements.pl-card.pl-card",
        "documentation": {}
    },
    {
        "label": "SUBTITLE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-card.pl-card",
        "description": "src.prairielearn.elements.pl-card.pl-card",
        "peekOfCode": "SUBTITLE_DEFAULT = \"\"\nFOOTER_DEFAULT = \"\"\nIMG_TOP_SRC_DEFAULT = \"\"\nIMG_TOP_ALT_DEFAULT = \"\"\nIMG_BOTTOM_SRC_DEFAULT = \"\"\nIMG_BOTTOM_ALT_DEFAULT = \"\"\nWIDTH_DEFAULT = \"auto\"\ncurrent_module_path = os.path.abspath(__file__)\nprint(current_module_path)\nPL_CARD_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_path,\"..\",\"pl-card.mustache\" )",
        "detail": "src.prairielearn.elements.pl-card.pl-card",
        "documentation": {}
    },
    {
        "label": "FOOTER_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-card.pl-card",
        "description": "src.prairielearn.elements.pl-card.pl-card",
        "peekOfCode": "FOOTER_DEFAULT = \"\"\nIMG_TOP_SRC_DEFAULT = \"\"\nIMG_TOP_ALT_DEFAULT = \"\"\nIMG_BOTTOM_SRC_DEFAULT = \"\"\nIMG_BOTTOM_ALT_DEFAULT = \"\"\nWIDTH_DEFAULT = \"auto\"\ncurrent_module_path = os.path.abspath(__file__)\nprint(current_module_path)\nPL_CARD_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_path,\"..\",\"pl-card.mustache\" )\ndef prepare(element_html: str, data: pl.QuestionData) -> None:",
        "detail": "src.prairielearn.elements.pl-card.pl-card",
        "documentation": {}
    },
    {
        "label": "IMG_TOP_SRC_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-card.pl-card",
        "description": "src.prairielearn.elements.pl-card.pl-card",
        "peekOfCode": "IMG_TOP_SRC_DEFAULT = \"\"\nIMG_TOP_ALT_DEFAULT = \"\"\nIMG_BOTTOM_SRC_DEFAULT = \"\"\nIMG_BOTTOM_ALT_DEFAULT = \"\"\nWIDTH_DEFAULT = \"auto\"\ncurrent_module_path = os.path.abspath(__file__)\nprint(current_module_path)\nPL_CARD_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_path,\"..\",\"pl-card.mustache\" )\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)",
        "detail": "src.prairielearn.elements.pl-card.pl-card",
        "documentation": {}
    },
    {
        "label": "IMG_TOP_ALT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-card.pl-card",
        "description": "src.prairielearn.elements.pl-card.pl-card",
        "peekOfCode": "IMG_TOP_ALT_DEFAULT = \"\"\nIMG_BOTTOM_SRC_DEFAULT = \"\"\nIMG_BOTTOM_ALT_DEFAULT = \"\"\nWIDTH_DEFAULT = \"auto\"\ncurrent_module_path = os.path.abspath(__file__)\nprint(current_module_path)\nPL_CARD_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_path,\"..\",\"pl-card.mustache\" )\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = []",
        "detail": "src.prairielearn.elements.pl-card.pl-card",
        "documentation": {}
    },
    {
        "label": "IMG_BOTTOM_SRC_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-card.pl-card",
        "description": "src.prairielearn.elements.pl-card.pl-card",
        "peekOfCode": "IMG_BOTTOM_SRC_DEFAULT = \"\"\nIMG_BOTTOM_ALT_DEFAULT = \"\"\nWIDTH_DEFAULT = \"auto\"\ncurrent_module_path = os.path.abspath(__file__)\nprint(current_module_path)\nPL_CARD_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_path,\"..\",\"pl-card.mustache\" )\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = []\n    optional_attribs = [",
        "detail": "src.prairielearn.elements.pl-card.pl-card",
        "documentation": {}
    },
    {
        "label": "IMG_BOTTOM_ALT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-card.pl-card",
        "description": "src.prairielearn.elements.pl-card.pl-card",
        "peekOfCode": "IMG_BOTTOM_ALT_DEFAULT = \"\"\nWIDTH_DEFAULT = \"auto\"\ncurrent_module_path = os.path.abspath(__file__)\nprint(current_module_path)\nPL_CARD_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_path,\"..\",\"pl-card.mustache\" )\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = []\n    optional_attribs = [\n        \"header\",",
        "detail": "src.prairielearn.elements.pl-card.pl-card",
        "documentation": {}
    },
    {
        "label": "WIDTH_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-card.pl-card",
        "description": "src.prairielearn.elements.pl-card.pl-card",
        "peekOfCode": "WIDTH_DEFAULT = \"auto\"\ncurrent_module_path = os.path.abspath(__file__)\nprint(current_module_path)\nPL_CARD_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_path,\"..\",\"pl-card.mustache\" )\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = []\n    optional_attribs = [\n        \"header\",\n        \"title\",",
        "detail": "src.prairielearn.elements.pl-card.pl-card",
        "documentation": {}
    },
    {
        "label": "current_module_path",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-card.pl-card",
        "description": "src.prairielearn.elements.pl-card.pl-card",
        "peekOfCode": "current_module_path = os.path.abspath(__file__)\nprint(current_module_path)\nPL_CARD_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_path,\"..\",\"pl-card.mustache\" )\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = []\n    optional_attribs = [\n        \"header\",\n        \"title\",\n        \"subtitle\",",
        "detail": "src.prairielearn.elements.pl-card.pl-card",
        "documentation": {}
    },
    {
        "label": "PL_CARD_MUSTACHE_TEMPLATE_NAME",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-card.pl-card",
        "description": "src.prairielearn.elements.pl-card.pl-card",
        "peekOfCode": "PL_CARD_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_path,\"..\",\"pl-card.mustache\" )\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = []\n    optional_attribs = [\n        \"header\",\n        \"title\",\n        \"subtitle\",\n        \"footer\",\n        \"img-top-src\",",
        "detail": "src.prairielearn.elements.pl-card.pl-card",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "description": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "peekOfCode": "def prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    print(element)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",\n        \"number-answers\",\n        \"min-correct\",\n        \"max-correct\",\n        \"fixed-order\",",
        "detail": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "description": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "peekOfCode": "def render(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    partial_credit = pl.get_boolean_attrib(\n        element, \"partial-credit\", PARTIAL_CREDIT_DEFAULT\n    )\n    partial_credit_method = pl.get_string_attrib(\n        element, \"partial-credit-method\", PARTIAL_CREDIT_METHOD_DEFAULT\n    )\n    hide_score_badge = pl.get_boolean_attrib(",
        "detail": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "description": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "peekOfCode": "def parse(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    submitted_key = data[\"submitted_answers\"].get(name, None)\n    all_keys = [a[\"key\"] for a in data[\"params\"][name]]\n    # Check that at least one option was selected\n    if submitted_key is None:\n        data[\"format_errors\"][name] = \"You must select at least one option.\"\n        return\n    # Check that the selected options are a subset of the valid options",
        "detail": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "documentation": {}
    },
    {
        "label": "grade",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "description": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "peekOfCode": "def grade(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    weight = pl.get_integer_attrib(element, \"weight\", WEIGHT_DEFAULT)\n    partial_credit = pl.get_boolean_attrib(\n        element, \"partial-credit\", PARTIAL_CREDIT_DEFAULT\n    )\n    number_answers = len(data[\"params\"][name])\n    partial_credit_method = pl.get_string_attrib(\n        element, \"partial-credit-method\", PARTIAL_CREDIT_METHOD_DEFAULT",
        "detail": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "description": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "peekOfCode": "def test(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    weight = pl.get_integer_attrib(element, \"weight\", WEIGHT_DEFAULT)\n    partial_credit = pl.get_boolean_attrib(\n        element, \"partial-credit\", PARTIAL_CREDIT_DEFAULT\n    )\n    partial_credit_method = pl.get_string_attrib(\n        element, \"partial-credit-method\", PARTIAL_CREDIT_METHOD_DEFAULT\n    )",
        "detail": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "documentation": {}
    },
    {
        "label": "WEIGHT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "description": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "peekOfCode": "WEIGHT_DEFAULT = 1\nFIXED_ORDER_DEFAULT = False\nINLINE_DEFAULT = False\nPARTIAL_CREDIT_DEFAULT = False\nPARTIAL_CREDIT_METHOD_DEFAULT = \"PC\"\nHIDE_ANSWER_PANEL_DEFAULT = False\nHIDE_HELP_TEXT_DEFAULT = False\nDETAILED_HELP_TEXT_DEFAULT = False\nHIDE_LETTER_KEYS_DEFAULT = False\nHIDE_SCORE_BADGE_DEFAULT = False",
        "detail": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "documentation": {}
    },
    {
        "label": "FIXED_ORDER_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "description": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "peekOfCode": "FIXED_ORDER_DEFAULT = False\nINLINE_DEFAULT = False\nPARTIAL_CREDIT_DEFAULT = False\nPARTIAL_CREDIT_METHOD_DEFAULT = \"PC\"\nHIDE_ANSWER_PANEL_DEFAULT = False\nHIDE_HELP_TEXT_DEFAULT = False\nDETAILED_HELP_TEXT_DEFAULT = False\nHIDE_LETTER_KEYS_DEFAULT = False\nHIDE_SCORE_BADGE_DEFAULT = False\nSHOW_NUMBER_CORRECT_DEFAULT = False",
        "detail": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "documentation": {}
    },
    {
        "label": "INLINE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "description": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "peekOfCode": "INLINE_DEFAULT = False\nPARTIAL_CREDIT_DEFAULT = False\nPARTIAL_CREDIT_METHOD_DEFAULT = \"PC\"\nHIDE_ANSWER_PANEL_DEFAULT = False\nHIDE_HELP_TEXT_DEFAULT = False\nDETAILED_HELP_TEXT_DEFAULT = False\nHIDE_LETTER_KEYS_DEFAULT = False\nHIDE_SCORE_BADGE_DEFAULT = False\nSHOW_NUMBER_CORRECT_DEFAULT = False\nMIN_CORRECT_DEFAULT = 1",
        "detail": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "documentation": {}
    },
    {
        "label": "PARTIAL_CREDIT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "description": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "peekOfCode": "PARTIAL_CREDIT_DEFAULT = False\nPARTIAL_CREDIT_METHOD_DEFAULT = \"PC\"\nHIDE_ANSWER_PANEL_DEFAULT = False\nHIDE_HELP_TEXT_DEFAULT = False\nDETAILED_HELP_TEXT_DEFAULT = False\nHIDE_LETTER_KEYS_DEFAULT = False\nHIDE_SCORE_BADGE_DEFAULT = False\nSHOW_NUMBER_CORRECT_DEFAULT = False\nMIN_CORRECT_DEFAULT = 1\nMIN_SELECT_DEFAULT = 1",
        "detail": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "documentation": {}
    },
    {
        "label": "PARTIAL_CREDIT_METHOD_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "description": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "peekOfCode": "PARTIAL_CREDIT_METHOD_DEFAULT = \"PC\"\nHIDE_ANSWER_PANEL_DEFAULT = False\nHIDE_HELP_TEXT_DEFAULT = False\nDETAILED_HELP_TEXT_DEFAULT = False\nHIDE_LETTER_KEYS_DEFAULT = False\nHIDE_SCORE_BADGE_DEFAULT = False\nSHOW_NUMBER_CORRECT_DEFAULT = False\nMIN_CORRECT_DEFAULT = 1\nMIN_SELECT_DEFAULT = 1\nFEEDBACK_DEFAULT = None",
        "detail": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "documentation": {}
    },
    {
        "label": "HIDE_ANSWER_PANEL_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "description": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "peekOfCode": "HIDE_ANSWER_PANEL_DEFAULT = False\nHIDE_HELP_TEXT_DEFAULT = False\nDETAILED_HELP_TEXT_DEFAULT = False\nHIDE_LETTER_KEYS_DEFAULT = False\nHIDE_SCORE_BADGE_DEFAULT = False\nSHOW_NUMBER_CORRECT_DEFAULT = False\nMIN_CORRECT_DEFAULT = 1\nMIN_SELECT_DEFAULT = 1\nFEEDBACK_DEFAULT = None\n# Get the absolute path of the current module",
        "detail": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "documentation": {}
    },
    {
        "label": "HIDE_HELP_TEXT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "description": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "peekOfCode": "HIDE_HELP_TEXT_DEFAULT = False\nDETAILED_HELP_TEXT_DEFAULT = False\nHIDE_LETTER_KEYS_DEFAULT = False\nHIDE_SCORE_BADGE_DEFAULT = False\nSHOW_NUMBER_CORRECT_DEFAULT = False\nMIN_CORRECT_DEFAULT = 1\nMIN_SELECT_DEFAULT = 1\nFEEDBACK_DEFAULT = None\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)",
        "detail": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "documentation": {}
    },
    {
        "label": "DETAILED_HELP_TEXT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "description": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "peekOfCode": "DETAILED_HELP_TEXT_DEFAULT = False\nHIDE_LETTER_KEYS_DEFAULT = False\nHIDE_SCORE_BADGE_DEFAULT = False\nSHOW_NUMBER_CORRECT_DEFAULT = False\nMIN_CORRECT_DEFAULT = 1\nMIN_SELECT_DEFAULT = 1\nFEEDBACK_DEFAULT = None\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module",
        "detail": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "documentation": {}
    },
    {
        "label": "HIDE_LETTER_KEYS_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "description": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "peekOfCode": "HIDE_LETTER_KEYS_DEFAULT = False\nHIDE_SCORE_BADGE_DEFAULT = False\nSHOW_NUMBER_CORRECT_DEFAULT = False\nMIN_CORRECT_DEFAULT = 1\nMIN_SELECT_DEFAULT = 1\nFEEDBACK_DEFAULT = None\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)",
        "detail": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "documentation": {}
    },
    {
        "label": "HIDE_SCORE_BADGE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "description": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "peekOfCode": "HIDE_SCORE_BADGE_DEFAULT = False\nSHOW_NUMBER_CORRECT_DEFAULT = False\nMIN_CORRECT_DEFAULT = 1\nMIN_SELECT_DEFAULT = 1\nFEEDBACK_DEFAULT = None\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)\nCHECKBOX_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir,\"pl-checkbox.mustache\" )",
        "detail": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "documentation": {}
    },
    {
        "label": "SHOW_NUMBER_CORRECT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "description": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "peekOfCode": "SHOW_NUMBER_CORRECT_DEFAULT = False\nMIN_CORRECT_DEFAULT = 1\nMIN_SELECT_DEFAULT = 1\nFEEDBACK_DEFAULT = None\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)\nCHECKBOX_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir,\"pl-checkbox.mustache\" )\ndef prepare(element_html, data):",
        "detail": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "documentation": {}
    },
    {
        "label": "MIN_CORRECT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "description": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "peekOfCode": "MIN_CORRECT_DEFAULT = 1\nMIN_SELECT_DEFAULT = 1\nFEEDBACK_DEFAULT = None\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)\nCHECKBOX_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir,\"pl-checkbox.mustache\" )\ndef prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)",
        "detail": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "documentation": {}
    },
    {
        "label": "MIN_SELECT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "description": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "peekOfCode": "MIN_SELECT_DEFAULT = 1\nFEEDBACK_DEFAULT = None\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)\nCHECKBOX_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir,\"pl-checkbox.mustache\" )\ndef prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    print(element)",
        "detail": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "documentation": {}
    },
    {
        "label": "FEEDBACK_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "description": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "peekOfCode": "FEEDBACK_DEFAULT = None\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)\nCHECKBOX_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir,\"pl-checkbox.mustache\" )\ndef prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    print(element)\n    required_attribs = [\"answers-name\"]",
        "detail": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "documentation": {}
    },
    {
        "label": "current_module_path",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "description": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "peekOfCode": "current_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)\nCHECKBOX_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir,\"pl-checkbox.mustache\" )\ndef prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    print(element)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",",
        "detail": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "documentation": {}
    },
    {
        "label": "current_module_dir",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "description": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "peekOfCode": "current_module_dir = os.path.dirname(current_module_path)\nCHECKBOX_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir,\"pl-checkbox.mustache\" )\ndef prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    print(element)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",\n        \"number-answers\",\n        \"min-correct\",",
        "detail": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "documentation": {}
    },
    {
        "label": "CHECKBOX_MUSTACHE_TEMPLATE_NAME",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "description": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "peekOfCode": "CHECKBOX_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir,\"pl-checkbox.mustache\" )\ndef prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    print(element)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",\n        \"number-answers\",\n        \"min-correct\",\n        \"max-correct\",",
        "detail": "src.prairielearn.elements.pl-checkbox.pl-checkbox",
        "documentation": {}
    },
    {
        "label": "parse_highlight_lines",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-code.code_utils",
        "description": "src.prairielearn.elements.pl-code.code_utils",
        "peekOfCode": "def parse_highlight_lines(highlight_lines: str) -> Optional[list[int]]:\n    \"\"\"\n    Parses a string like \"1\", \"1-4\", \"1-3,5,7-8\" into a list of lines like\n    [1], [1,2,3,4], and [1,2,3,5,7,8]\n    \"\"\"\n    lines = []\n    components = highlight_lines.split(\",\")\n    for component in components:\n        component = component.replace(\" \", \"\").split(\"-\")\n        try:",
        "detail": "src.prairielearn.elements.pl-code.code_utils",
        "documentation": {}
    },
    {
        "label": "test_parse_highlight_lines",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-code.code_utils_test",
        "description": "src.prairielearn.elements.pl-code.code_utils_test",
        "peekOfCode": "def test_parse_highlight_lines(\n    input_str: str, expected_output: Optional[list[int]]\n) -> None:\n    assert parse_highlight_lines(input_str) == expected_output",
        "detail": "src.prairielearn.elements.pl-code.code_utils_test",
        "documentation": {}
    },
    {
        "label": "NoHighlightingLexer",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-code.pl-code",
        "description": "src.prairielearn.elements.pl-code.pl-code",
        "peekOfCode": "class NoHighlightingLexer(pygments.lexer.Lexer):\n    \"\"\"\n    Dummy lexer for when syntax highlighting is not wanted, but we still\n    want to run it through the highlighter for styling and code escaping.\n    \"\"\"\n    def __init__(self, **options: Any) -> None:\n        pygments.lexer.Lexer.__init__(self, **options)\n        self.compress = options.get(\"compress\", \"\")\n    def get_tokens_unprocessed(\n        self, text: str",
        "detail": "src.prairielearn.elements.pl-code.pl-code",
        "documentation": {}
    },
    {
        "label": "HighlightingHtmlFormatter",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-code.pl-code",
        "description": "src.prairielearn.elements.pl-code.pl-code",
        "peekOfCode": "class HighlightingHtmlFormatter(pygments.formatters.HtmlFormatter):\n    \"\"\"\n    Subclass of the default HTML formatter to provide more flexibility\n    with highlighted lines.\n    \"\"\"\n    def _highlight_lines(\n        self, tokensource: Iterable[tuple[int, str]]\n    ) -> Generator[tuple[int, str], None, None]:\n        \"\"\"\n        Highlighted the lines specified in the `hl_lines` option by post-processing the token stream.",
        "detail": "src.prairielearn.elements.pl-code.pl-code",
        "documentation": {}
    },
    {
        "label": "get_lexer_by_name",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-code.pl-code",
        "description": "src.prairielearn.elements.pl-code.pl-code",
        "peekOfCode": "def get_lexer_by_name(name: str) -> Optional[pygments.lexer.Lexer]:\n    \"\"\"\n    Tries to find a lexer by both its proper name and any aliases it has.\n    \"\"\"\n    # Search by proper class/language names\n    # This returns None if not found, and a class if found.\n    lexer_class = pygments.lexers.find_lexer_class(name)\n    if lexer_class is not None:\n        # Instantiate the class if we found it\n        return lexer_class()",
        "detail": "src.prairielearn.elements.pl-code.pl-code",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-code.pl-code",
        "description": "src.prairielearn.elements.pl-code.pl-code",
        "peekOfCode": "def prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = []\n    optional_attribs = [\n        \"language\",\n        \"no-highlight\",  # Deprecated, accepted for backwards compatibility\n        \"source-file-name\",\n        \"directory\",\n        \"prevent-select\",\n        \"highlight-lines\",",
        "detail": "src.prairielearn.elements.pl-code.pl-code",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-code.pl-code",
        "description": "src.prairielearn.elements.pl-code.pl-code",
        "peekOfCode": "def render(element_html: str, data: pl.QuestionData) -> str:\n    element = lxml.html.fragment_fromstring(element_html)\n    language = pl.get_string_attrib(element, \"language\", LANGUAGE_DEFAULT)\n    style = pl.get_string_attrib(element, \"style\", STYLE_DEFAULT)\n    source_file_name = pl.get_string_attrib(\n        element, \"source-file-name\", SOURCE_FILE_NAME_DEFAULT\n    )\n    directory = pl.get_string_attrib(element, \"directory\", DIRECTORY_DEFAULT)\n    prevent_select = pl.get_boolean_attrib(\n        element, \"prevent-select\", PREVENT_SELECT_DEFAULT",
        "detail": "src.prairielearn.elements.pl-code.pl-code",
        "documentation": {}
    },
    {
        "label": "LANGUAGE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-code.pl-code",
        "description": "src.prairielearn.elements.pl-code.pl-code",
        "peekOfCode": "LANGUAGE_DEFAULT = None\nSTYLE_DEFAULT = \"friendly\"\nNO_HIGHLIGHT_DEFAULT = False\nSOURCE_FILE_NAME_DEFAULT = None\nPREVENT_SELECT_DEFAULT = False\nHIGHLIGHT_LINES_DEFAULT = None\nHIGHLIGHT_LINES_COLOR_DEFAULT = None\nDIRECTORY_DEFAULT = \".\"\nCOPY_CODE_BUTTON_DEFAULT = False\nSHOW_LINE_NUMBERS_DEFAULT = False",
        "detail": "src.prairielearn.elements.pl-code.pl-code",
        "documentation": {}
    },
    {
        "label": "STYLE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-code.pl-code",
        "description": "src.prairielearn.elements.pl-code.pl-code",
        "peekOfCode": "STYLE_DEFAULT = \"friendly\"\nNO_HIGHLIGHT_DEFAULT = False\nSOURCE_FILE_NAME_DEFAULT = None\nPREVENT_SELECT_DEFAULT = False\nHIGHLIGHT_LINES_DEFAULT = None\nHIGHLIGHT_LINES_COLOR_DEFAULT = None\nDIRECTORY_DEFAULT = \".\"\nCOPY_CODE_BUTTON_DEFAULT = False\nSHOW_LINE_NUMBERS_DEFAULT = False\n# These are the same colors used in pl-external-grader-result",
        "detail": "src.prairielearn.elements.pl-code.pl-code",
        "documentation": {}
    },
    {
        "label": "NO_HIGHLIGHT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-code.pl-code",
        "description": "src.prairielearn.elements.pl-code.pl-code",
        "peekOfCode": "NO_HIGHLIGHT_DEFAULT = False\nSOURCE_FILE_NAME_DEFAULT = None\nPREVENT_SELECT_DEFAULT = False\nHIGHLIGHT_LINES_DEFAULT = None\nHIGHLIGHT_LINES_COLOR_DEFAULT = None\nDIRECTORY_DEFAULT = \".\"\nCOPY_CODE_BUTTON_DEFAULT = False\nSHOW_LINE_NUMBERS_DEFAULT = False\n# These are the same colors used in pl-external-grader-result\nANSI_COLORS = {",
        "detail": "src.prairielearn.elements.pl-code.pl-code",
        "documentation": {}
    },
    {
        "label": "SOURCE_FILE_NAME_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-code.pl-code",
        "description": "src.prairielearn.elements.pl-code.pl-code",
        "peekOfCode": "SOURCE_FILE_NAME_DEFAULT = None\nPREVENT_SELECT_DEFAULT = False\nHIGHLIGHT_LINES_DEFAULT = None\nHIGHLIGHT_LINES_COLOR_DEFAULT = None\nDIRECTORY_DEFAULT = \".\"\nCOPY_CODE_BUTTON_DEFAULT = False\nSHOW_LINE_NUMBERS_DEFAULT = False\n# These are the same colors used in pl-external-grader-result\nANSI_COLORS = {\n    \"Black\": \"#000000\",",
        "detail": "src.prairielearn.elements.pl-code.pl-code",
        "documentation": {}
    },
    {
        "label": "PREVENT_SELECT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-code.pl-code",
        "description": "src.prairielearn.elements.pl-code.pl-code",
        "peekOfCode": "PREVENT_SELECT_DEFAULT = False\nHIGHLIGHT_LINES_DEFAULT = None\nHIGHLIGHT_LINES_COLOR_DEFAULT = None\nDIRECTORY_DEFAULT = \".\"\nCOPY_CODE_BUTTON_DEFAULT = False\nSHOW_LINE_NUMBERS_DEFAULT = False\n# These are the same colors used in pl-external-grader-result\nANSI_COLORS = {\n    \"Black\": \"#000000\",\n    \"Red\": \"#c91b00\",",
        "detail": "src.prairielearn.elements.pl-code.pl-code",
        "documentation": {}
    },
    {
        "label": "HIGHLIGHT_LINES_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-code.pl-code",
        "description": "src.prairielearn.elements.pl-code.pl-code",
        "peekOfCode": "HIGHLIGHT_LINES_DEFAULT = None\nHIGHLIGHT_LINES_COLOR_DEFAULT = None\nDIRECTORY_DEFAULT = \".\"\nCOPY_CODE_BUTTON_DEFAULT = False\nSHOW_LINE_NUMBERS_DEFAULT = False\n# These are the same colors used in pl-external-grader-result\nANSI_COLORS = {\n    \"Black\": \"#000000\",\n    \"Red\": \"#c91b00\",\n    \"Green\": \"#00c200\",",
        "detail": "src.prairielearn.elements.pl-code.pl-code",
        "documentation": {}
    },
    {
        "label": "HIGHLIGHT_LINES_COLOR_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-code.pl-code",
        "description": "src.prairielearn.elements.pl-code.pl-code",
        "peekOfCode": "HIGHLIGHT_LINES_COLOR_DEFAULT = None\nDIRECTORY_DEFAULT = \".\"\nCOPY_CODE_BUTTON_DEFAULT = False\nSHOW_LINE_NUMBERS_DEFAULT = False\n# These are the same colors used in pl-external-grader-result\nANSI_COLORS = {\n    \"Black\": \"#000000\",\n    \"Red\": \"#c91b00\",\n    \"Green\": \"#00c200\",\n    \"Yellow\": \"#c7c400\",",
        "detail": "src.prairielearn.elements.pl-code.pl-code",
        "documentation": {}
    },
    {
        "label": "DIRECTORY_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-code.pl-code",
        "description": "src.prairielearn.elements.pl-code.pl-code",
        "peekOfCode": "DIRECTORY_DEFAULT = \".\"\nCOPY_CODE_BUTTON_DEFAULT = False\nSHOW_LINE_NUMBERS_DEFAULT = False\n# These are the same colors used in pl-external-grader-result\nANSI_COLORS = {\n    \"Black\": \"#000000\",\n    \"Red\": \"#c91b00\",\n    \"Green\": \"#00c200\",\n    \"Yellow\": \"#c7c400\",\n    \"Blue\": \"#0037da\",",
        "detail": "src.prairielearn.elements.pl-code.pl-code",
        "documentation": {}
    },
    {
        "label": "COPY_CODE_BUTTON_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-code.pl-code",
        "description": "src.prairielearn.elements.pl-code.pl-code",
        "peekOfCode": "COPY_CODE_BUTTON_DEFAULT = False\nSHOW_LINE_NUMBERS_DEFAULT = False\n# These are the same colors used in pl-external-grader-result\nANSI_COLORS = {\n    \"Black\": \"#000000\",\n    \"Red\": \"#c91b00\",\n    \"Green\": \"#00c200\",\n    \"Yellow\": \"#c7c400\",\n    \"Blue\": \"#0037da\",\n    \"Magenta\": \"#c930c7\",",
        "detail": "src.prairielearn.elements.pl-code.pl-code",
        "documentation": {}
    },
    {
        "label": "SHOW_LINE_NUMBERS_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-code.pl-code",
        "description": "src.prairielearn.elements.pl-code.pl-code",
        "peekOfCode": "SHOW_LINE_NUMBERS_DEFAULT = False\n# These are the same colors used in pl-external-grader-result\nANSI_COLORS = {\n    \"Black\": \"#000000\",\n    \"Red\": \"#c91b00\",\n    \"Green\": \"#00c200\",\n    \"Yellow\": \"#c7c400\",\n    \"Blue\": \"#0037da\",\n    \"Magenta\": \"#c930c7\",\n    \"Cyan\": \"#00c5c7\",",
        "detail": "src.prairielearn.elements.pl-code.pl-code",
        "documentation": {}
    },
    {
        "label": "ANSI_COLORS",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-code.pl-code",
        "description": "src.prairielearn.elements.pl-code.pl-code",
        "peekOfCode": "ANSI_COLORS = {\n    \"Black\": \"#000000\",\n    \"Red\": \"#c91b00\",\n    \"Green\": \"#00c200\",\n    \"Yellow\": \"#c7c400\",\n    \"Blue\": \"#0037da\",\n    \"Magenta\": \"#c930c7\",\n    \"Cyan\": \"#00c5c7\",\n    \"White\": \"#c7c7c7\",\n    \"BrightBlack\": \"#676767\",",
        "detail": "src.prairielearn.elements.pl-code.pl-code",
        "documentation": {}
    },
    {
        "label": "DisplayLanguage",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "description": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "peekOfCode": "class DisplayLanguage(Enum):\n    PYTHON = 1\n    R = 2\nSHOW_HEADER_DEFAULT = True\nSHOW_INDEX_DEFAULT = True\nSHOW_DIMENSIONS_DEFAULT = True\nDISPLAY_LANGUAGE_DEFAULT = DisplayLanguage.PYTHON\nDISPLAY_VARIABLE_NAME_DEFAULT = \"df\"\nSHOW_DTYPE_DEFAULT = False\nNUM_DIGITS_DEFAULT = None",
        "detail": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "documentation": {}
    },
    {
        "label": "convert_pandas_dtype_to_r",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "description": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "peekOfCode": "def convert_pandas_dtype_to_r(s: pd.Series) -> str:\n    # Force series to avoid odd element-wise output\n    s.dtype\n    if pd.api.types.is_float_dtype(s):\n        return \"numeric\"\n    elif pd.api.types.is_integer_dtype(s):\n        return \"integer\"\n    elif pd.api.types.is_object_dtype(s) or pd.api.types.is_string_dtype(s):\n        return \"character\"\n    elif isinstance(s, pd.CategoricalDtype):",
        "detail": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "documentation": {}
    },
    {
        "label": "get_pandas_dtype",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "description": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "peekOfCode": "def get_pandas_dtype(s: pd.Series) -> str:\n    return str(s.dtype)\ndef using_default_index(df: pd.DataFrame) -> bool:\n    return pd.api.types.is_integer_dtype(df.index) and pd.Index(range(len(df))).equals(\n        df.index\n    )\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    pl.check_attribs(\n        element,",
        "detail": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "documentation": {}
    },
    {
        "label": "using_default_index",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "description": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "peekOfCode": "def using_default_index(df: pd.DataFrame) -> bool:\n    return pd.api.types.is_integer_dtype(df.index) and pd.Index(range(len(df))).equals(\n        df.index\n    )\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    pl.check_attribs(\n        element,\n        required_attribs=[\"params-name\"],\n        optional_attribs=[",
        "detail": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "description": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "peekOfCode": "def prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    pl.check_attribs(\n        element,\n        required_attribs=[\"params-name\"],\n        optional_attribs=[\n            \"show-index\",\n            \"show-header\",\n            \"show-dimensions\",\n            \"show-dtype\",",
        "detail": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "description": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "peekOfCode": "def render(element_html: str, data: pl.QuestionData) -> str:\n    element = lxml.html.fragment_fromstring(element_html)\n    varname = pl.get_string_attrib(element, \"params-name\")\n    show_index = pl.get_boolean_attrib(element, \"show-index\", SHOW_INDEX_DEFAULT)\n    show_header = pl.get_boolean_attrib(element, \"show-header\", SHOW_HEADER_DEFAULT)\n    show_python = pl.get_boolean_attrib(element, \"show-python\", SHOW_PYTHON_DEFAULT)\n    show_dimensions = pl.get_boolean_attrib(\n        element, \"show-dimensions\", SHOW_DIMENSIONS_DEFAULT\n    )\n    show_dtype = pl.get_boolean_attrib(element, \"show-dtype\", SHOW_DTYPE_DEFAULT)",
        "detail": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "documentation": {}
    },
    {
        "label": "SHOW_HEADER_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "description": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "peekOfCode": "SHOW_HEADER_DEFAULT = True\nSHOW_INDEX_DEFAULT = True\nSHOW_DIMENSIONS_DEFAULT = True\nDISPLAY_LANGUAGE_DEFAULT = DisplayLanguage.PYTHON\nDISPLAY_VARIABLE_NAME_DEFAULT = \"df\"\nSHOW_DTYPE_DEFAULT = False\nNUM_DIGITS_DEFAULT = None\nSHOW_PYTHON_DEFAULT = True\nWIDTH_DEFAULT = 500\ndef convert_pandas_dtype_to_r(s: pd.Series) -> str:",
        "detail": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "documentation": {}
    },
    {
        "label": "SHOW_INDEX_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "description": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "peekOfCode": "SHOW_INDEX_DEFAULT = True\nSHOW_DIMENSIONS_DEFAULT = True\nDISPLAY_LANGUAGE_DEFAULT = DisplayLanguage.PYTHON\nDISPLAY_VARIABLE_NAME_DEFAULT = \"df\"\nSHOW_DTYPE_DEFAULT = False\nNUM_DIGITS_DEFAULT = None\nSHOW_PYTHON_DEFAULT = True\nWIDTH_DEFAULT = 500\ndef convert_pandas_dtype_to_r(s: pd.Series) -> str:\n    # Force series to avoid odd element-wise output",
        "detail": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "documentation": {}
    },
    {
        "label": "SHOW_DIMENSIONS_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "description": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "peekOfCode": "SHOW_DIMENSIONS_DEFAULT = True\nDISPLAY_LANGUAGE_DEFAULT = DisplayLanguage.PYTHON\nDISPLAY_VARIABLE_NAME_DEFAULT = \"df\"\nSHOW_DTYPE_DEFAULT = False\nNUM_DIGITS_DEFAULT = None\nSHOW_PYTHON_DEFAULT = True\nWIDTH_DEFAULT = 500\ndef convert_pandas_dtype_to_r(s: pd.Series) -> str:\n    # Force series to avoid odd element-wise output\n    s.dtype",
        "detail": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "documentation": {}
    },
    {
        "label": "DISPLAY_LANGUAGE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "description": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "peekOfCode": "DISPLAY_LANGUAGE_DEFAULT = DisplayLanguage.PYTHON\nDISPLAY_VARIABLE_NAME_DEFAULT = \"df\"\nSHOW_DTYPE_DEFAULT = False\nNUM_DIGITS_DEFAULT = None\nSHOW_PYTHON_DEFAULT = True\nWIDTH_DEFAULT = 500\ndef convert_pandas_dtype_to_r(s: pd.Series) -> str:\n    # Force series to avoid odd element-wise output\n    s.dtype\n    if pd.api.types.is_float_dtype(s):",
        "detail": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "documentation": {}
    },
    {
        "label": "DISPLAY_VARIABLE_NAME_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "description": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "peekOfCode": "DISPLAY_VARIABLE_NAME_DEFAULT = \"df\"\nSHOW_DTYPE_DEFAULT = False\nNUM_DIGITS_DEFAULT = None\nSHOW_PYTHON_DEFAULT = True\nWIDTH_DEFAULT = 500\ndef convert_pandas_dtype_to_r(s: pd.Series) -> str:\n    # Force series to avoid odd element-wise output\n    s.dtype\n    if pd.api.types.is_float_dtype(s):\n        return \"numeric\"",
        "detail": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "documentation": {}
    },
    {
        "label": "SHOW_DTYPE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "description": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "peekOfCode": "SHOW_DTYPE_DEFAULT = False\nNUM_DIGITS_DEFAULT = None\nSHOW_PYTHON_DEFAULT = True\nWIDTH_DEFAULT = 500\ndef convert_pandas_dtype_to_r(s: pd.Series) -> str:\n    # Force series to avoid odd element-wise output\n    s.dtype\n    if pd.api.types.is_float_dtype(s):\n        return \"numeric\"\n    elif pd.api.types.is_integer_dtype(s):",
        "detail": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "documentation": {}
    },
    {
        "label": "NUM_DIGITS_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "description": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "peekOfCode": "NUM_DIGITS_DEFAULT = None\nSHOW_PYTHON_DEFAULT = True\nWIDTH_DEFAULT = 500\ndef convert_pandas_dtype_to_r(s: pd.Series) -> str:\n    # Force series to avoid odd element-wise output\n    s.dtype\n    if pd.api.types.is_float_dtype(s):\n        return \"numeric\"\n    elif pd.api.types.is_integer_dtype(s):\n        return \"integer\"",
        "detail": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "documentation": {}
    },
    {
        "label": "SHOW_PYTHON_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "description": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "peekOfCode": "SHOW_PYTHON_DEFAULT = True\nWIDTH_DEFAULT = 500\ndef convert_pandas_dtype_to_r(s: pd.Series) -> str:\n    # Force series to avoid odd element-wise output\n    s.dtype\n    if pd.api.types.is_float_dtype(s):\n        return \"numeric\"\n    elif pd.api.types.is_integer_dtype(s):\n        return \"integer\"\n    elif pd.api.types.is_object_dtype(s) or pd.api.types.is_string_dtype(s):",
        "detail": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "documentation": {}
    },
    {
        "label": "WIDTH_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "description": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "peekOfCode": "WIDTH_DEFAULT = 500\ndef convert_pandas_dtype_to_r(s: pd.Series) -> str:\n    # Force series to avoid odd element-wise output\n    s.dtype\n    if pd.api.types.is_float_dtype(s):\n        return \"numeric\"\n    elif pd.api.types.is_integer_dtype(s):\n        return \"integer\"\n    elif pd.api.types.is_object_dtype(s) or pd.api.types.is_string_dtype(s):\n        return \"character\"",
        "detail": "src.prairielearn.elements.pl-dataframe.pl-dataframe",
        "documentation": {}
    },
    {
        "label": "element_defaults",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.defaults",
        "description": "src.prairielearn.elements.pl-drawing.defaults",
        "peekOfCode": "element_defaults = {\n    \"gradable\": False,\n    \"answers-name\": \"\",\n    \"draw-error-box\": False,\n    \"grid-size\": 20,\n    \"angle-tol\": 10,\n    \"snap-to-grid\": False,\n    \"width\": 580,\n    \"height\": 320,\n    \"show-tolerance-hint\": True,",
        "detail": "src.prairielearn.elements.pl-drawing.defaults",
        "documentation": {}
    },
    {
        "label": "drawing_defaults",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.defaults",
        "description": "src.prairielearn.elements.pl-drawing.defaults",
        "peekOfCode": "drawing_defaults = {\n    \"x1\": 40,\n    \"y1\": 40,\n    \"x2\": 80,\n    \"y2\": 20,\n    \"offsetx\": 2,\n    \"offsety\": 2,\n    \"width\": 30,\n    \"width-rod\": 20,\n    \"height\": 40,",
        "detail": "src.prairielearn.elements.pl-drawing.defaults",
        "documentation": {}
    },
    {
        "label": "no_submission_error",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.defaults",
        "description": "src.prairielearn.elements.pl-drawing.defaults",
        "peekOfCode": "no_submission_error = \"There was no submitted answer.  Please place some objects on the canvas and try again.\"",
        "detail": "src.prairielearn.elements.pl-drawing.defaults",
        "documentation": {}
    },
    {
        "label": "BaseElement",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class BaseElement:\n    def generate(element, data):\n        return {}\n    def is_gradable():\n        return False\n    def grade(ref, student, tol, angtol):\n        return True\n    def grading_name(element):\n        return None\n    def validate_attributes():",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "ControlledLine",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class ControlledLine(BaseElement):\n    def generate(el, data):\n        if \"draw-error-box\" in el.attrib:\n            obj_draw = el.attrib[\"draw-error-box\"] == \"true\"\n        else:\n            obj_draw = None\n        offset_x = pl.get_float_attrib(el, \"offset-tol-x\", 0)\n        offset_y = pl.get_float_attrib(el, \"offset-tol-y\", 0)\n        grid_size = pl.get_integer_attrib(el, \"grid-size\", 20)\n        tol = pl.get_float_attrib(el, \"tol\", grid_size / 2)",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "ControlledCurvedLine",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class ControlledCurvedLine(BaseElement):\n    def generate(el, data):\n        if \"draw-error-box\" in el.attrib:\n            obj_draw = el.attrib[\"draw-error-box\"] == \"true\"\n        else:\n            obj_draw = None\n        offset_x = pl.get_float_attrib(el, \"offset-tol-x\", 0)\n        offset_y = pl.get_float_attrib(el, \"offset-tol-y\", 0)\n        offset_control_x = pl.get_float_attrib(el, \"offset-control-tol-x\", 0)\n        offset_control_y = pl.get_float_attrib(el, \"offset-control-tol-y\", 0)",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "Roller",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class Roller(BaseElement):\n    def generate(el, data):\n        color = pl.get_color_attrib(el, \"color\", \"brown1\")\n        stroke_color = pl.get_color_attrib(el, \"stroke-color\", \"black\")\n        return {\n            \"x1\": pl.get_float_attrib(el, \"x1\", drawing_defaults[\"x1\"]),\n            \"y1\": pl.get_float_attrib(el, \"y1\", drawing_defaults[\"y1\"]),\n            \"height\": pl.get_float_attrib(el, \"height\", drawing_defaults[\"height\"]),\n            \"width\": pl.get_float_attrib(el, \"width\", drawing_defaults[\"width\"]),\n            \"angle\": pl.get_float_attrib(el, \"angle\", drawing_defaults[\"angle\"]),",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "Clamped",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class Clamped(BaseElement):\n    def generate(el, data):\n        color = pl.get_color_attrib(el, \"color\", \"black\")\n        return {\n            \"x1\": pl.get_float_attrib(el, \"x1\", drawing_defaults[\"x1\"]),\n            \"y1\": pl.get_float_attrib(el, \"y1\", drawing_defaults[\"y1\"]),\n            \"height\": pl.get_float_attrib(el, \"height\", drawing_defaults[\"height\"]),\n            \"width\": pl.get_float_attrib(el, \"width\", drawing_defaults[\"width\"]),\n            \"angle\": pl.get_float_attrib(el, \"angle\", drawing_defaults[\"angle\"]),\n            \"label\": pl.get_string_attrib(el, \"label\", drawing_defaults[\"label\"]),",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "FixedPin",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class FixedPin(BaseElement):\n    def generate(el, data):\n        color = pl.get_color_attrib(el, \"color\", \"brown1\")\n        stroke_color = pl.get_color_attrib(el, \"stroke-color\", \"black\")\n        obj = {\n            \"x1\": pl.get_float_attrib(el, \"x1\", drawing_defaults[\"x1\"]),\n            \"y1\": pl.get_float_attrib(el, \"y1\", drawing_defaults[\"y1\"]),\n            \"height\": pl.get_float_attrib(el, \"height\", drawing_defaults[\"height\"]),\n            \"width\": pl.get_float_attrib(el, \"width\", drawing_defaults[\"width\"]),\n            \"angle\": pl.get_float_attrib(el, \"angle\", drawing_defaults[\"angle\"]),",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "Rod",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class Rod(BaseElement):\n    def generate(el, data):\n        color = pl.get_color_attrib(el, \"color\", \"white\")\n        stroke_color = pl.get_color_attrib(el, \"stroke-color\", \"black\")\n        return {\n            \"height\": pl.get_float_attrib(el, \"width\", drawing_defaults[\"width-rod\"]),\n            \"x1\": pl.get_float_attrib(el, \"x1\", drawing_defaults[\"x1\"]),\n            \"y1\": pl.get_float_attrib(el, \"y1\", drawing_defaults[\"y1\"]),\n            \"label1\": pl.get_string_attrib(el, \"label1\", drawing_defaults[\"label\"]),\n            \"offsetx1\": pl.get_float_attrib(",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "CollarRod",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class CollarRod(BaseElement):\n    def generate(el, data):\n        w = pl.get_float_attrib(el, \"width\", 20)\n        color = pl.get_color_attrib(el, \"color\", \"white\")\n        stroke_color = pl.get_color_attrib(el, \"stroke-color\", \"black\")\n        return {\n            \"height\": w,\n            \"x1\": pl.get_float_attrib(el, \"x1\", 40),\n            \"y1\": pl.get_float_attrib(el, \"y1\", 40),\n            \"collar1\": pl.get_boolean_attrib(el, \"draw-collar-end1\", True),",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "ThreePointRod",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class ThreePointRod(BaseElement):\n    def generate(el, data):\n        color = pl.get_color_attrib(el, \"color\", \"white\")\n        stroke_color = pl.get_color_attrib(el, \"stroke-color\", \"black\")\n        x1 = pl.get_float_attrib(el, \"x1\", 40)\n        y1 = pl.get_float_attrib(el, \"y1\", 100)\n        x2 = pl.get_float_attrib(el, \"x2\", 100)\n        y2 = pl.get_float_attrib(el, \"y2\", 100)\n        x3 = pl.get_float_attrib(el, \"x3\", 100)\n        y3 = pl.get_float_attrib(el, \"y3\", 140)",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "FourPointRod",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class FourPointRod(BaseElement):\n    def generate(el, data):\n        color = pl.get_color_attrib(el, \"color\", \"white\")\n        stroke_color = pl.get_color_attrib(el, \"stroke-color\", \"black\")\n        x1 = pl.get_float_attrib(el, \"x1\", 40)\n        y1 = pl.get_float_attrib(el, \"y1\", 100)\n        x2 = pl.get_float_attrib(el, \"x2\", 100)\n        y2 = pl.get_float_attrib(el, \"y2\", 100)\n        x3 = pl.get_float_attrib(el, \"x3\", 100)\n        y3 = pl.get_float_attrib(el, \"y3\", 160)",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "Pulley",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class Pulley(BaseElement):\n    def generate(el, data):\n        color = pl.get_color_attrib(el, \"color\", \"gray\")\n        stroke_color = pl.get_color_attrib(el, \"stroke-color\", \"black\")\n        r = pl.get_float_attrib(el, \"radius\", 20)\n        x1 = pl.get_float_attrib(el, \"x1\", 100)\n        y1 = pl.get_float_attrib(el, \"y1\", 100)\n        x2 = pl.get_float_attrib(el, \"x2\", 140)\n        y2 = pl.get_float_attrib(el, \"y2\", 140)\n        x3 = pl.get_float_attrib(el, \"x3\", 40)",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "Vector",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class Vector(BaseElement):\n    def generate(el, data):\n        color = pl.get_color_attrib(el, \"color\", \"red3\")\n        anchor_is_tail = pl.get_boolean_attrib(el, \"anchor-is-tail\", True)\n        # This is the anchor point for Grading\n        x1 = pl.get_float_attrib(el, \"x1\", 30)\n        y1 = pl.get_float_attrib(el, \"y1\", 10)\n        # This is the end point used for plotting\n        left = x1\n        top = y1",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "PairedVector",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class PairedVector(BaseElement):\n    def generate(el, data):\n        grid_size = pl.get_integer_attrib(el, \"grid-size\", 20)\n        color = pl.get_color_attrib(el, \"color\", \"red3\")\n        anchor_is_tail = pl.get_boolean_attrib(el, \"anchor-is-tail\", True)\n        # This is the anchor point for Grading\n        x1 = pl.get_float_attrib(el, \"x1\", 2 * grid_size)\n        y1 = pl.get_float_attrib(el, \"y1\", grid_size)\n        x2 = pl.get_float_attrib(el, \"x2\", 3 * grid_size)\n        y2 = pl.get_float_attrib(el, \"y2\", 2 * grid_size)",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "DoubleHeadedVector",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class DoubleHeadedVector(BaseElement):\n    def generate(el, data):\n        obj = Vector.generate(el, data)\n        obj[\"type\"] = \"pl-double-headed-vector\"\n        return obj\n    def get_attributes():\n        return [\n            \"x1\",\n            \"y1\",\n            \"anchor-is-tail\",",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "ArcVector",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class ArcVector(BaseElement):\n    def generate(el, data):\n        disregard_sense = pl.get_boolean_attrib(el, \"disregard-sense\", False)\n        color = pl.get_color_attrib(el, \"color\", \"purple\")\n        clockwise_direction = pl.get_boolean_attrib(el, \"clockwise-direction\", True)\n        if clockwise_direction:\n            drawStartArrow = False\n            drawEndArrow = True\n        else:\n            drawStartArrow = True",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "DistributedLoad",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class DistributedLoad(BaseElement):\n    def generate(el, data):\n        color = pl.get_color_attrib(el, \"color\", \"red3\")\n        anchor_is_tail = pl.get_boolean_attrib(el, \"anchor-is-tail\", True)\n        # This is the anchor point for Grading\n        x1 = pl.get_float_attrib(el, \"x1\", 30)\n        y1 = pl.get_float_attrib(el, \"y1\", 10)\n        # This is the end point used for plotting\n        left = x1\n        top = y1",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "Point",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class Point(BaseElement):\n    def generate(el, data):\n        color = pl.get_color_attrib(el, \"color\", \"black\")\n        # Error box for grading\n        x1 = pl.get_float_attrib(el, \"x1\", 40)\n        y1 = pl.get_float_attrib(el, \"y1\", 40)\n        if \"draw-error-box\" in el.attrib:\n            obj_draw = el.attrib[\"draw-error-box\"] == \"true\"\n        else:\n            obj_draw = None",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "Coordinates",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class Coordinates(BaseElement):\n    def generate(el, data):\n        color = pl.get_color_attrib(el, \"color\", \"black\")\n        return {\n            \"left\": pl.get_float_attrib(el, \"x1\", drawing_defaults[\"x1\"]),\n            \"top\": pl.get_float_attrib(el, \"y1\", drawing_defaults[\"y1\"]),\n            \"width\": pl.get_float_attrib(el, \"width\", drawing_defaults[\"width\"]),\n            \"label\": pl.get_string_attrib(el, \"label\", \"\"),\n            \"offsetx\": pl.get_float_attrib(el, \"offsetx\", -16),\n            \"offsety\": pl.get_float_attrib(el, \"offsety\", -10),",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "Dimensions",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class Dimensions(BaseElement):\n    def generate(el, data):\n        color = pl.get_color_attrib(el, \"stroke-color\", \"black\")\n        offset = pl.get_float_attrib(el, \"dim-offset\", 0)\n        x1 = pl.get_float_attrib(el, \"x1\", drawing_defaults[\"x1\"])\n        y1 = pl.get_float_attrib(el, \"y1\", drawing_defaults[\"y1\"])\n        if \"x2\" not in el.attrib:\n            w = pl.get_float_attrib(el, \"width\", drawing_defaults[\"force-width\"] / 2)\n            ang = pl.get_float_attrib(el, \"angle\", drawing_defaults[\"angle\"])\n            ang_rad = ang * math.pi / 180",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "ArcDimensions",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class ArcDimensions(BaseElement):\n    def generate(el, data):\n        color = pl.get_color_attrib(el, \"stroke-color\", \"black\")\n        return {\n            \"left\": pl.get_float_attrib(el, \"x1\", drawing_defaults[\"x1\"]),\n            \"top\": pl.get_float_attrib(el, \"y1\", drawing_defaults[\"y1\"]),\n            \"angle\": pl.get_float_attrib(el, \"angle\", drawing_defaults[\"angle\"]),\n            \"radius\": pl.get_float_attrib(el, \"radius\", drawing_defaults[\"radius\"]),\n            \"startAngle\": pl.get_float_attrib(\n                el, \"start-angle\", drawing_defaults[\"angle\"]",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "Rectangle",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class Rectangle(BaseElement):\n    def generate(el, data):\n        color = pl.get_color_attrib(el, \"color\", \"green1\")\n        stroke_color = pl.get_color_attrib(el, \"stroke-color\", \"black\")\n        return {\n            \"left\": pl.get_float_attrib(el, \"x1\", drawing_defaults[\"x1\"]),\n            \"top\": pl.get_float_attrib(el, \"y1\", drawing_defaults[\"y1\"]),\n            \"width\": pl.get_float_attrib(el, \"width\", drawing_defaults[\"width\"]),\n            \"height\": pl.get_float_attrib(el, \"height\", drawing_defaults[\"height\"]),\n            \"angle\": pl.get_float_attrib(el, \"angle\", drawing_defaults[\"angle\"]),",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "Triangle",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class Triangle(BaseElement):\n    def generate(el, data):\n        color = pl.get_color_attrib(el, \"color\", \"red1\")\n        stroke_color = pl.get_color_attrib(el, \"stroke-color\", \"black\")\n        return {\n            \"p1\": {\n                \"x\": pl.get_float_attrib(el, \"x1\", 40),\n                \"y\": pl.get_float_attrib(el, \"y1\", 40),\n            },\n            \"p2\": {",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "Circle",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class Circle(BaseElement):\n    def generate(el, data):\n        color = pl.get_color_attrib(el, \"color\", \"grey\")\n        stroke_color = pl.get_color_attrib(el, \"stroke-color\", \"black\")\n        return {\n            \"left\": pl.get_float_attrib(el, \"x1\", drawing_defaults[\"x1\"]),\n            \"top\": pl.get_float_attrib(el, \"y1\", drawing_defaults[\"y1\"]),\n            \"radius\": pl.get_float_attrib(el, \"radius\", drawing_defaults[\"radius\"]),\n            \"label\": pl.get_string_attrib(el, \"label\", drawing_defaults[\"label\"]),\n            \"offsetx\": pl.get_float_attrib(el, \"offsetx\", 5),",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "Polygon",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class Polygon(BaseElement):\n    def generate(el, data):\n        pointlist = json.loads(\n            pl.get_string_attrib(\n                el,\n                \"plist\",\n                '[{\"x\": 66.21260699999999, \"y\": 82.746078}, {\"x\": 25.880586, \"y\": 78.50701}, {\"x\": 17.448900000000002, \"y\": 38.839035}, {\"x\": 52.569852, \"y\": 18.561946}, {\"x\": 82.707481, \"y\": 45.697991}]',\n            )\n        )\n        color = pl.get_color_attrib(el, \"color\", \"white\")",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "Spring",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class Spring(BaseElement):\n    def generate(el, data):\n        stroke_color = pl.get_color_attrib(el, \"stroke-color\", \"black\")\n        x1 = pl.get_float_attrib(el, \"x1\", drawing_defaults[\"x1\"])\n        y1 = pl.get_float_attrib(el, \"y1\", drawing_defaults[\"y1\"])\n        if \"x2\" in el.attrib and \"y2\" in el.attrib:\n            x2 = pl.get_float_attrib(el, \"x2\")\n            y2 = pl.get_float_attrib(el, \"y2\")\n        else:\n            w = pl.get_float_attrib(el, \"width\", drawing_defaults[\"force-width\"])",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "Coil",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class Coil(BaseElement):\n    def generate(el, data):\n        stroke_color = pl.get_color_attrib(el, \"stroke-color\", \"black\")\n        x1 = pl.get_float_attrib(el, \"x1\", drawing_defaults[\"x1\"])\n        y1 = pl.get_float_attrib(el, \"y1\", drawing_defaults[\"y1\"])\n        if \"x2\" in el.attrib and \"y2\" in el.attrib:\n            x2 = pl.get_float_attrib(el, \"x2\")\n            y2 = pl.get_float_attrib(el, \"y2\")\n        else:\n            w = pl.get_float_attrib(el, \"width\", 80)",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "Line",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class Line(BaseElement):\n    def generate(el, data):\n        stroke_color = pl.get_color_attrib(el, \"stroke-color\", \"black\")\n        x1 = pl.get_float_attrib(el, \"x1\", drawing_defaults[\"x1\"])\n        y1 = pl.get_float_attrib(el, \"y1\", drawing_defaults[\"y1\"])\n        if \"x2\" in el.attrib and \"y2\" in el.attrib:\n            x2 = pl.get_float_attrib(el, \"x2\")\n            y2 = pl.get_float_attrib(el, \"y2\")\n        else:\n            w = pl.get_float_attrib(el, \"width\", drawing_defaults[\"force-width\"])",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "Arc",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class Arc(BaseElement):\n    def generate(el, data):\n        stroke_color = pl.get_color_attrib(el, \"stroke-color\", \"black\")\n        theta1 = (\n            pl.get_float_attrib(el, \"start-angle\", drawing_defaults[\"angle\"])\n            * math.pi\n            / 180\n        )\n        theta2 = (\n            pl.get_float_attrib(el, \"end-angle\", drawing_defaults[\"end-angle\"])",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "Text",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class Text(BaseElement):\n    def generate(el, data):\n        return {\n            \"left\": pl.get_float_attrib(el, \"x1\", drawing_defaults[\"x1\"]),\n            \"top\": pl.get_float_attrib(el, \"y1\", drawing_defaults[\"y1\"]),\n            \"label\": pl.get_string_attrib(el, \"label\", \" Text \"),\n            \"offsetx\": pl.get_float_attrib(el, \"offsetx\", 0),\n            \"offsety\": pl.get_float_attrib(el, \"offsety\", 0),\n            \"fontSize\": pl.get_float_attrib(\n                el, \"font-size\", drawing_defaults[\"font-size\"]",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "Axes",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class Axes(BaseElement):\n    def generate(el, data):\n        if \"origin\" in el.attrib:\n            origin = json.loads(pl.get_string_attrib(el, \"origin\"))\n            origin_x = origin[\"x\"]\n            origin_y = origin[\"y\"]\n        else:\n            origin_x = origin_y = 60\n        color = pl.get_color_attrib(el, \"color\", \"black\")\n        return {",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "GraphLine",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class GraphLine(BaseElement):\n    def generate(el, data):\n        curved_line = False\n        if \"origin\" in el.attrib:\n            origin = json.loads(pl.get_string_attrib(el, \"origin\"))\n            x0 = origin[\"x\"]\n            y0 = origin[\"y\"]\n        else:\n            x0 = y0 = 0\n        if \"end-points\" in el.attrib:",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "Capacitor",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class Capacitor(BaseElement):\n    def generate(el, data):\n        x1 = pl.get_float_attrib(el, \"x1\", drawing_defaults[\"x1\"])\n        y1 = pl.get_float_attrib(el, \"y1\", drawing_defaults[\"y1\"])\n        if \"x2\" in el.attrib and \"y2\" in el.attrib:\n            x2 = pl.get_float_attrib(el, \"x2\")\n            y2 = pl.get_float_attrib(el, \"y2\")\n        else:\n            w = pl.get_float_attrib(el, \"width\", drawing_defaults[\"force-width\"])\n            angle = pl.get_float_attrib(el, \"angle\", 0)",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "Battery",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class Battery(BaseElement):\n    def generate(el, data):\n        x1 = pl.get_float_attrib(el, \"x1\", drawing_defaults[\"x1\"])\n        y1 = pl.get_float_attrib(el, \"y1\", drawing_defaults[\"y1\"])\n        if \"x2\" in el.attrib and \"y2\" in el.attrib:\n            x2 = pl.get_float_attrib(el, \"x2\")\n            y2 = pl.get_float_attrib(el, \"y2\")\n        else:\n            w = pl.get_float_attrib(el, \"width\", drawing_defaults[\"force-width\"])\n            angle = pl.get_float_attrib(el, \"angle\", 0)",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "Resistor",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class Resistor(BaseElement):\n    def generate(el, data):\n        x1 = pl.get_float_attrib(el, \"x1\", drawing_defaults[\"x1\"])\n        y1 = pl.get_float_attrib(el, \"y1\", drawing_defaults[\"y1\"])\n        if \"x2\" in el.attrib and \"y2\" in el.attrib:\n            x2 = pl.get_float_attrib(el, \"x2\")\n            y2 = pl.get_float_attrib(el, \"y2\")\n        else:\n            w = pl.get_float_attrib(el, \"width\", drawing_defaults[\"force-width\"])\n            angle = pl.get_float_attrib(el, \"angle\", 0)",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "Inductor",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class Inductor(BaseElement):\n    def generate(el, data):\n        x1 = pl.get_float_attrib(el, \"x1\", drawing_defaults[\"x1\"])\n        y1 = pl.get_float_attrib(el, \"y1\", drawing_defaults[\"y1\"])\n        if \"x2\" in el.attrib and \"y2\" in el.attrib:\n            x2 = pl.get_float_attrib(el, \"x2\")\n            y2 = pl.get_float_attrib(el, \"y2\")\n        else:\n            w = pl.get_float_attrib(el, \"width\", drawing_defaults[\"force-width\"])\n            angle = pl.get_float_attrib(el, \"angle\", 0)",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "Switch",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class Switch(BaseElement):\n    def generate(el, data):\n        x1 = pl.get_float_attrib(el, \"x1\", drawing_defaults[\"x1\"])\n        y1 = pl.get_float_attrib(el, \"y1\", drawing_defaults[\"y1\"])\n        if \"x2\" in el.attrib and \"y2\" in el.attrib:\n            x2 = pl.get_float_attrib(el, \"x2\")\n            y2 = pl.get_float_attrib(el, \"y2\")\n        else:\n            w = pl.get_float_attrib(el, \"width\", drawing_defaults[\"force-width\"])\n            angle = pl.get_float_attrib(el, \"angle\", 0)",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "UnplaceableBaseElement",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class UnplaceableBaseElement(BaseElement):\n    # Used only to get attributes\n    def generate(element):\n        raise Exception(\"Cannot create element!\")\n    def is_gradable():\n        return False\n    def grade(ref, st, tol, angtol):\n        raise Exception(\n            \"This element should not be graded!  If you see this message, something has gone terribly wrong!\"\n        )",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "DrawingElement",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class DrawingElement(UnplaceableBaseElement):\n    def get_attributes():\n        return [\n            \"gradable\",\n            \"answers-name\",\n            \"width\",\n            \"height\",\n            \"grid-size\",\n            \"snap-to-grid\",\n            \"correct-answer\",",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "DrawingInitial",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class DrawingInitial(UnplaceableBaseElement):\n    def get_attributes():\n        return [\"draw-error-box\"]\nclass DrawingAnswer(UnplaceableBaseElement):\n    def get_attributes():\n        return [\"draw-error-box\"]\nclass DrawingGroup(UnplaceableBaseElement):\n    def get_attributes():\n        return [\"visible\"]\nclass DrawingControls(UnplaceableBaseElement):",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "DrawingAnswer",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class DrawingAnswer(UnplaceableBaseElement):\n    def get_attributes():\n        return [\"draw-error-box\"]\nclass DrawingGroup(UnplaceableBaseElement):\n    def get_attributes():\n        return [\"visible\"]\nclass DrawingControls(UnplaceableBaseElement):\n    def get_attributes():\n        return []\nclass DrawingControlsGroup(UnplaceableBaseElement):",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "DrawingGroup",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class DrawingGroup(UnplaceableBaseElement):\n    def get_attributes():\n        return [\"visible\"]\nclass DrawingControls(UnplaceableBaseElement):\n    def get_attributes():\n        return []\nclass DrawingControlsGroup(UnplaceableBaseElement):\n    def get_attributes():\n        return [\"label\"]\nclass DrawingControlsButton(UnplaceableBaseElement):",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "DrawingControls",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class DrawingControls(UnplaceableBaseElement):\n    def get_attributes():\n        return []\nclass DrawingControlsGroup(UnplaceableBaseElement):\n    def get_attributes():\n        return [\"label\"]\nclass DrawingControlsButton(UnplaceableBaseElement):\n    def validate_attributes():\n        return False\n    def get_attributes():",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "DrawingControlsGroup",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class DrawingControlsGroup(UnplaceableBaseElement):\n    def get_attributes():\n        return [\"label\"]\nclass DrawingControlsButton(UnplaceableBaseElement):\n    def validate_attributes():\n        return False\n    def get_attributes():\n        return [\"type\"]\nelements[\"pl-drawing\"] = DrawingElement\nelements[\"pl-drawing-initial\"] = DrawingInitial",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "DrawingControlsButton",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "class DrawingControlsButton(UnplaceableBaseElement):\n    def validate_attributes():\n        return False\n    def get_attributes():\n        return [\"type\"]\nelements[\"pl-drawing\"] = DrawingElement\nelements[\"pl-drawing-initial\"] = DrawingInitial\nelements[\"pl-drawing-answer\"] = DrawingAnswer\nelements[\"pl-drawing-group\"] = DrawingGroup\nelements[\"pl-controls\"] = DrawingControls",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "get_error_box",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "def get_error_box(x1, y1, theta, tol, offset_forward, offset_backward):\n    # Get the position of the anchor point of the vector\n    rpos = np.array([x1, y1])\n    # Defining the direction of the vector\n    dir = np.array([math.cos(theta), math.sin(theta)])\n    # Defining the error box limit in the direction of the vector\n    max_forward = offset_forward + tol\n    max_backward = offset_backward + tol\n    wbox = max_backward + max_forward\n    # Defining the error box limit in the direction perpendicular to the vector",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "abserr",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "def abserr(x, xapp):\n    return np.abs(x - xapp)\ndef abserr_ang(ref, x):\n    return np.abs(((np.abs(ref - x) + 180) % 360) - 180)\n# Drawing Elements\nelements = {}\nclass BaseElement:\n    def generate(element, data):\n        return {}\n    def is_gradable():",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "abserr_ang",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "def abserr_ang(ref, x):\n    return np.abs(((np.abs(ref - x) + 180) % 360) - 180)\n# Drawing Elements\nelements = {}\nclass BaseElement:\n    def generate(element, data):\n        return {}\n    def is_gradable():\n        return False\n    def grade(ref, student, tol, angtol):",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "should_validate_attributes",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "def should_validate_attributes(name):\n    if name in elements:\n        return elements[name].validate_attributes()\n    else:\n        return False\ndef get_attributes(name):\n    if name in elements:\n        return elements[name].get_attributes()\n    else:\n        return []",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "get_attributes",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "def get_attributes(name):\n    if name in elements:\n        return elements[name].get_attributes()\n    else:\n        return []\ndef generate(element, name, defaults={}):\n    if name in elements:\n        obj = defaults.copy()\n        cls = elements[name]\n        data = registered_elements.get(name, [])",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "generate",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "def generate(element, name, defaults={}):\n    if name in elements:\n        obj = defaults.copy()\n        cls = elements[name]\n        data = registered_elements.get(name, [])\n        obj.update(cls.generate(element, data))\n        # By default, set the grading name to the element name\n        gradingName = cls.grading_name(element)\n        if gradingName is None:\n            gradingName = name",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "is_gradable",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "def is_gradable(name):\n    if name in elements:\n        return elements[name].is_gradable()\n    return False\ndef grade(reference, element, name, tol, angtol):\n    if name in elements:\n        cls = elements[name]\n        if cls.is_gradable():\n            return elements[name].grade(reference, element, tol, angtol)\n    return False",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "grade",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "def grade(reference, element, name, tol, angtol):\n    if name in elements:\n        cls = elements[name]\n        if cls.is_gradable():\n            return elements[name].grade(reference, element, tol, angtol)\n    return False\ndef register_extension(name, module, data):\n    data_obj = {\n        \"clientFilesUrl\": data[\"options\"]\n        .get(\"client_files_extensions_url\", {})",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "register_extension",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "def register_extension(name, module, data):\n    data_obj = {\n        \"clientFilesUrl\": data[\"options\"]\n        .get(\"client_files_extensions_url\", {})\n        .get(name, None)\n    }\n    for elem_name, elem in module.elements.items():\n        registered_elements[elem_name] = data_obj\n        elements[elem_name] = elem\ndef main():",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "def main():\n    import xml.etree.ElementTree as ET\n    html_string = r\"\"\"<pl-coordinates x1=80 y1=320 width=\"60\" ></pl-coordinates>\"\"\"\n    import numpy as np\n    import random\n    data = pl.QuestionData = {\n        \"params\": {},\n        \"correct_answers\": {},\n        \"submitted_answers\": {},  # Empty initially\n        \"format_errors\": {},",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements = {}\nclass BaseElement:\n    def generate(element, data):\n        return {}\n    def is_gradable():\n        return False\n    def grade(ref, student, tol, angtol):\n        return True\n    def grading_name(element):\n        return None",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-4pointrod\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-4pointrod\"] = FourPointRod\nelements[\"pl-3pointrod\"] = ThreePointRod\nelements[\"pl-arc\"] = Arc\nelements[\"pl-arc-dimensions\"] = ArcDimensions\nelements[\"pl-arc-vector\"] = ArcVector\nelements[\"pl-axes\"] = Axes\nelements[\"pl-circle\"] = Circle\nelements[\"pl-clamped\"] = Clamped\nelements[\"pl-collar-rod\"] = CollarRod\nelements[\"pl-controlled-curved-line\"] = ControlledCurvedLine",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-3pointrod\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-3pointrod\"] = ThreePointRod\nelements[\"pl-arc\"] = Arc\nelements[\"pl-arc-dimensions\"] = ArcDimensions\nelements[\"pl-arc-vector\"] = ArcVector\nelements[\"pl-axes\"] = Axes\nelements[\"pl-circle\"] = Circle\nelements[\"pl-clamped\"] = Clamped\nelements[\"pl-collar-rod\"] = CollarRod\nelements[\"pl-controlled-curved-line\"] = ControlledCurvedLine\nelements[\"pl-controlled-line\"] = ControlledLine",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-arc\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-arc\"] = Arc\nelements[\"pl-arc-dimensions\"] = ArcDimensions\nelements[\"pl-arc-vector\"] = ArcVector\nelements[\"pl-axes\"] = Axes\nelements[\"pl-circle\"] = Circle\nelements[\"pl-clamped\"] = Clamped\nelements[\"pl-collar-rod\"] = CollarRod\nelements[\"pl-controlled-curved-line\"] = ControlledCurvedLine\nelements[\"pl-controlled-line\"] = ControlledLine\nelements[\"pl-coordinates\"] = Coordinates",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-arc-dimensions\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-arc-dimensions\"] = ArcDimensions\nelements[\"pl-arc-vector\"] = ArcVector\nelements[\"pl-axes\"] = Axes\nelements[\"pl-circle\"] = Circle\nelements[\"pl-clamped\"] = Clamped\nelements[\"pl-collar-rod\"] = CollarRod\nelements[\"pl-controlled-curved-line\"] = ControlledCurvedLine\nelements[\"pl-controlled-line\"] = ControlledLine\nelements[\"pl-coordinates\"] = Coordinates\nelements[\"pl-dimensions\"] = Dimensions",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-arc-vector\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-arc-vector\"] = ArcVector\nelements[\"pl-axes\"] = Axes\nelements[\"pl-circle\"] = Circle\nelements[\"pl-clamped\"] = Clamped\nelements[\"pl-collar-rod\"] = CollarRod\nelements[\"pl-controlled-curved-line\"] = ControlledCurvedLine\nelements[\"pl-controlled-line\"] = ControlledLine\nelements[\"pl-coordinates\"] = Coordinates\nelements[\"pl-dimensions\"] = Dimensions\nelements[\"pl-distributed-load\"] = DistributedLoad",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-axes\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-axes\"] = Axes\nelements[\"pl-circle\"] = Circle\nelements[\"pl-clamped\"] = Clamped\nelements[\"pl-collar-rod\"] = CollarRod\nelements[\"pl-controlled-curved-line\"] = ControlledCurvedLine\nelements[\"pl-controlled-line\"] = ControlledLine\nelements[\"pl-coordinates\"] = Coordinates\nelements[\"pl-dimensions\"] = Dimensions\nelements[\"pl-distributed-load\"] = DistributedLoad\nelements[\"pl-double-headed-vector\"] = DoubleHeadedVector",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-circle\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-circle\"] = Circle\nelements[\"pl-clamped\"] = Clamped\nelements[\"pl-collar-rod\"] = CollarRod\nelements[\"pl-controlled-curved-line\"] = ControlledCurvedLine\nelements[\"pl-controlled-line\"] = ControlledLine\nelements[\"pl-coordinates\"] = Coordinates\nelements[\"pl-dimensions\"] = Dimensions\nelements[\"pl-distributed-load\"] = DistributedLoad\nelements[\"pl-double-headed-vector\"] = DoubleHeadedVector\nelements[\"pl-fixed-pin\"] = FixedPin",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-clamped\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-clamped\"] = Clamped\nelements[\"pl-collar-rod\"] = CollarRod\nelements[\"pl-controlled-curved-line\"] = ControlledCurvedLine\nelements[\"pl-controlled-line\"] = ControlledLine\nelements[\"pl-coordinates\"] = Coordinates\nelements[\"pl-dimensions\"] = Dimensions\nelements[\"pl-distributed-load\"] = DistributedLoad\nelements[\"pl-double-headed-vector\"] = DoubleHeadedVector\nelements[\"pl-fixed-pin\"] = FixedPin\nelements[\"pl-graph-line\"] = GraphLine",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-collar-rod\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-collar-rod\"] = CollarRod\nelements[\"pl-controlled-curved-line\"] = ControlledCurvedLine\nelements[\"pl-controlled-line\"] = ControlledLine\nelements[\"pl-coordinates\"] = Coordinates\nelements[\"pl-dimensions\"] = Dimensions\nelements[\"pl-distributed-load\"] = DistributedLoad\nelements[\"pl-double-headed-vector\"] = DoubleHeadedVector\nelements[\"pl-fixed-pin\"] = FixedPin\nelements[\"pl-graph-line\"] = GraphLine\nelements[\"pl-line\"] = Line",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-controlled-curved-line\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-controlled-curved-line\"] = ControlledCurvedLine\nelements[\"pl-controlled-line\"] = ControlledLine\nelements[\"pl-coordinates\"] = Coordinates\nelements[\"pl-dimensions\"] = Dimensions\nelements[\"pl-distributed-load\"] = DistributedLoad\nelements[\"pl-double-headed-vector\"] = DoubleHeadedVector\nelements[\"pl-fixed-pin\"] = FixedPin\nelements[\"pl-graph-line\"] = GraphLine\nelements[\"pl-line\"] = Line\nelements[\"pl-point\"] = Point",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-controlled-line\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-controlled-line\"] = ControlledLine\nelements[\"pl-coordinates\"] = Coordinates\nelements[\"pl-dimensions\"] = Dimensions\nelements[\"pl-distributed-load\"] = DistributedLoad\nelements[\"pl-double-headed-vector\"] = DoubleHeadedVector\nelements[\"pl-fixed-pin\"] = FixedPin\nelements[\"pl-graph-line\"] = GraphLine\nelements[\"pl-line\"] = Line\nelements[\"pl-point\"] = Point\nelements[\"pl-polygon\"] = Polygon",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-coordinates\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-coordinates\"] = Coordinates\nelements[\"pl-dimensions\"] = Dimensions\nelements[\"pl-distributed-load\"] = DistributedLoad\nelements[\"pl-double-headed-vector\"] = DoubleHeadedVector\nelements[\"pl-fixed-pin\"] = FixedPin\nelements[\"pl-graph-line\"] = GraphLine\nelements[\"pl-line\"] = Line\nelements[\"pl-point\"] = Point\nelements[\"pl-polygon\"] = Polygon\nelements[\"pl-pulley\"] = Pulley",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-dimensions\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-dimensions\"] = Dimensions\nelements[\"pl-distributed-load\"] = DistributedLoad\nelements[\"pl-double-headed-vector\"] = DoubleHeadedVector\nelements[\"pl-fixed-pin\"] = FixedPin\nelements[\"pl-graph-line\"] = GraphLine\nelements[\"pl-line\"] = Line\nelements[\"pl-point\"] = Point\nelements[\"pl-polygon\"] = Polygon\nelements[\"pl-pulley\"] = Pulley\nelements[\"pl-rectangle\"] = Rectangle",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-distributed-load\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-distributed-load\"] = DistributedLoad\nelements[\"pl-double-headed-vector\"] = DoubleHeadedVector\nelements[\"pl-fixed-pin\"] = FixedPin\nelements[\"pl-graph-line\"] = GraphLine\nelements[\"pl-line\"] = Line\nelements[\"pl-point\"] = Point\nelements[\"pl-polygon\"] = Polygon\nelements[\"pl-pulley\"] = Pulley\nelements[\"pl-rectangle\"] = Rectangle\nelements[\"pl-rod\"] = Rod",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-double-headed-vector\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-double-headed-vector\"] = DoubleHeadedVector\nelements[\"pl-fixed-pin\"] = FixedPin\nelements[\"pl-graph-line\"] = GraphLine\nelements[\"pl-line\"] = Line\nelements[\"pl-point\"] = Point\nelements[\"pl-polygon\"] = Polygon\nelements[\"pl-pulley\"] = Pulley\nelements[\"pl-rectangle\"] = Rectangle\nelements[\"pl-rod\"] = Rod\nelements[\"pl-roller\"] = Roller",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-fixed-pin\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-fixed-pin\"] = FixedPin\nelements[\"pl-graph-line\"] = GraphLine\nelements[\"pl-line\"] = Line\nelements[\"pl-point\"] = Point\nelements[\"pl-polygon\"] = Polygon\nelements[\"pl-pulley\"] = Pulley\nelements[\"pl-rectangle\"] = Rectangle\nelements[\"pl-rod\"] = Rod\nelements[\"pl-roller\"] = Roller\nelements[\"pl-spring\"] = Spring",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-graph-line\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-graph-line\"] = GraphLine\nelements[\"pl-line\"] = Line\nelements[\"pl-point\"] = Point\nelements[\"pl-polygon\"] = Polygon\nelements[\"pl-pulley\"] = Pulley\nelements[\"pl-rectangle\"] = Rectangle\nelements[\"pl-rod\"] = Rod\nelements[\"pl-roller\"] = Roller\nelements[\"pl-spring\"] = Spring\nelements[\"pl-coil\"] = Coil",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-line\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-line\"] = Line\nelements[\"pl-point\"] = Point\nelements[\"pl-polygon\"] = Polygon\nelements[\"pl-pulley\"] = Pulley\nelements[\"pl-rectangle\"] = Rectangle\nelements[\"pl-rod\"] = Rod\nelements[\"pl-roller\"] = Roller\nelements[\"pl-spring\"] = Spring\nelements[\"pl-coil\"] = Coil\nelements[\"pl-text\"] = Text",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-point\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-point\"] = Point\nelements[\"pl-polygon\"] = Polygon\nelements[\"pl-pulley\"] = Pulley\nelements[\"pl-rectangle\"] = Rectangle\nelements[\"pl-rod\"] = Rod\nelements[\"pl-roller\"] = Roller\nelements[\"pl-spring\"] = Spring\nelements[\"pl-coil\"] = Coil\nelements[\"pl-text\"] = Text\nelements[\"pl-triangle\"] = Triangle",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-polygon\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-polygon\"] = Polygon\nelements[\"pl-pulley\"] = Pulley\nelements[\"pl-rectangle\"] = Rectangle\nelements[\"pl-rod\"] = Rod\nelements[\"pl-roller\"] = Roller\nelements[\"pl-spring\"] = Spring\nelements[\"pl-coil\"] = Coil\nelements[\"pl-text\"] = Text\nelements[\"pl-triangle\"] = Triangle\nelements[\"pl-vector\"] = Vector",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-pulley\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-pulley\"] = Pulley\nelements[\"pl-rectangle\"] = Rectangle\nelements[\"pl-rod\"] = Rod\nelements[\"pl-roller\"] = Roller\nelements[\"pl-spring\"] = Spring\nelements[\"pl-coil\"] = Coil\nelements[\"pl-text\"] = Text\nelements[\"pl-triangle\"] = Triangle\nelements[\"pl-vector\"] = Vector\nelements[\"pl-paired-vector\"] = PairedVector",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-rectangle\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-rectangle\"] = Rectangle\nelements[\"pl-rod\"] = Rod\nelements[\"pl-roller\"] = Roller\nelements[\"pl-spring\"] = Spring\nelements[\"pl-coil\"] = Coil\nelements[\"pl-text\"] = Text\nelements[\"pl-triangle\"] = Triangle\nelements[\"pl-vector\"] = Vector\nelements[\"pl-paired-vector\"] = PairedVector\nelements[\"pl-capacitor\"] = Capacitor",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-rod\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-rod\"] = Rod\nelements[\"pl-roller\"] = Roller\nelements[\"pl-spring\"] = Spring\nelements[\"pl-coil\"] = Coil\nelements[\"pl-text\"] = Text\nelements[\"pl-triangle\"] = Triangle\nelements[\"pl-vector\"] = Vector\nelements[\"pl-paired-vector\"] = PairedVector\nelements[\"pl-capacitor\"] = Capacitor\nelements[\"pl-battery\"] = Battery",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-roller\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-roller\"] = Roller\nelements[\"pl-spring\"] = Spring\nelements[\"pl-coil\"] = Coil\nelements[\"pl-text\"] = Text\nelements[\"pl-triangle\"] = Triangle\nelements[\"pl-vector\"] = Vector\nelements[\"pl-paired-vector\"] = PairedVector\nelements[\"pl-capacitor\"] = Capacitor\nelements[\"pl-battery\"] = Battery\nelements[\"pl-resistor\"] = Resistor",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-spring\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-spring\"] = Spring\nelements[\"pl-coil\"] = Coil\nelements[\"pl-text\"] = Text\nelements[\"pl-triangle\"] = Triangle\nelements[\"pl-vector\"] = Vector\nelements[\"pl-paired-vector\"] = PairedVector\nelements[\"pl-capacitor\"] = Capacitor\nelements[\"pl-battery\"] = Battery\nelements[\"pl-resistor\"] = Resistor\nelements[\"pl-inductor\"] = Inductor",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-coil\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-coil\"] = Coil\nelements[\"pl-text\"] = Text\nelements[\"pl-triangle\"] = Triangle\nelements[\"pl-vector\"] = Vector\nelements[\"pl-paired-vector\"] = PairedVector\nelements[\"pl-capacitor\"] = Capacitor\nelements[\"pl-battery\"] = Battery\nelements[\"pl-resistor\"] = Resistor\nelements[\"pl-inductor\"] = Inductor\nelements[\"pl-switch\"] = Switch",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-text\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-text\"] = Text\nelements[\"pl-triangle\"] = Triangle\nelements[\"pl-vector\"] = Vector\nelements[\"pl-paired-vector\"] = PairedVector\nelements[\"pl-capacitor\"] = Capacitor\nelements[\"pl-battery\"] = Battery\nelements[\"pl-resistor\"] = Resistor\nelements[\"pl-inductor\"] = Inductor\nelements[\"pl-switch\"] = Switch\n# Base Elements",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-triangle\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-triangle\"] = Triangle\nelements[\"pl-vector\"] = Vector\nelements[\"pl-paired-vector\"] = PairedVector\nelements[\"pl-capacitor\"] = Capacitor\nelements[\"pl-battery\"] = Battery\nelements[\"pl-resistor\"] = Resistor\nelements[\"pl-inductor\"] = Inductor\nelements[\"pl-switch\"] = Switch\n# Base Elements\nclass UnplaceableBaseElement(BaseElement):",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-vector\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-vector\"] = Vector\nelements[\"pl-paired-vector\"] = PairedVector\nelements[\"pl-capacitor\"] = Capacitor\nelements[\"pl-battery\"] = Battery\nelements[\"pl-resistor\"] = Resistor\nelements[\"pl-inductor\"] = Inductor\nelements[\"pl-switch\"] = Switch\n# Base Elements\nclass UnplaceableBaseElement(BaseElement):\n    # Used only to get attributes",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-paired-vector\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-paired-vector\"] = PairedVector\nelements[\"pl-capacitor\"] = Capacitor\nelements[\"pl-battery\"] = Battery\nelements[\"pl-resistor\"] = Resistor\nelements[\"pl-inductor\"] = Inductor\nelements[\"pl-switch\"] = Switch\n# Base Elements\nclass UnplaceableBaseElement(BaseElement):\n    # Used only to get attributes\n    def generate(element):",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-capacitor\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-capacitor\"] = Capacitor\nelements[\"pl-battery\"] = Battery\nelements[\"pl-resistor\"] = Resistor\nelements[\"pl-inductor\"] = Inductor\nelements[\"pl-switch\"] = Switch\n# Base Elements\nclass UnplaceableBaseElement(BaseElement):\n    # Used only to get attributes\n    def generate(element):\n        raise Exception(\"Cannot create element!\")",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-battery\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-battery\"] = Battery\nelements[\"pl-resistor\"] = Resistor\nelements[\"pl-inductor\"] = Inductor\nelements[\"pl-switch\"] = Switch\n# Base Elements\nclass UnplaceableBaseElement(BaseElement):\n    # Used only to get attributes\n    def generate(element):\n        raise Exception(\"Cannot create element!\")\n    def is_gradable():",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-resistor\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-resistor\"] = Resistor\nelements[\"pl-inductor\"] = Inductor\nelements[\"pl-switch\"] = Switch\n# Base Elements\nclass UnplaceableBaseElement(BaseElement):\n    # Used only to get attributes\n    def generate(element):\n        raise Exception(\"Cannot create element!\")\n    def is_gradable():\n        return False",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-inductor\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-inductor\"] = Inductor\nelements[\"pl-switch\"] = Switch\n# Base Elements\nclass UnplaceableBaseElement(BaseElement):\n    # Used only to get attributes\n    def generate(element):\n        raise Exception(\"Cannot create element!\")\n    def is_gradable():\n        return False\n    def grade(ref, st, tol, angtol):",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-switch\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-switch\"] = Switch\n# Base Elements\nclass UnplaceableBaseElement(BaseElement):\n    # Used only to get attributes\n    def generate(element):\n        raise Exception(\"Cannot create element!\")\n    def is_gradable():\n        return False\n    def grade(ref, st, tol, angtol):\n        raise Exception(",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-drawing\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-drawing\"] = DrawingElement\nelements[\"pl-drawing-initial\"] = DrawingInitial\nelements[\"pl-drawing-answer\"] = DrawingAnswer\nelements[\"pl-drawing-group\"] = DrawingGroup\nelements[\"pl-controls\"] = DrawingControls\nelements[\"pl-controls-group\"] = DrawingControlsGroup\nelements[\"pl-drawing-button\"] = DrawingControlsButton\n# Store elements that have been registered via extensions\nregistered_elements = {}\n# Helper Functions",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-drawing-initial\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-drawing-initial\"] = DrawingInitial\nelements[\"pl-drawing-answer\"] = DrawingAnswer\nelements[\"pl-drawing-group\"] = DrawingGroup\nelements[\"pl-controls\"] = DrawingControls\nelements[\"pl-controls-group\"] = DrawingControlsGroup\nelements[\"pl-drawing-button\"] = DrawingControlsButton\n# Store elements that have been registered via extensions\nregistered_elements = {}\n# Helper Functions\ndef should_validate_attributes(name):",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-drawing-answer\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-drawing-answer\"] = DrawingAnswer\nelements[\"pl-drawing-group\"] = DrawingGroup\nelements[\"pl-controls\"] = DrawingControls\nelements[\"pl-controls-group\"] = DrawingControlsGroup\nelements[\"pl-drawing-button\"] = DrawingControlsButton\n# Store elements that have been registered via extensions\nregistered_elements = {}\n# Helper Functions\ndef should_validate_attributes(name):\n    if name in elements:",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-drawing-group\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-drawing-group\"] = DrawingGroup\nelements[\"pl-controls\"] = DrawingControls\nelements[\"pl-controls-group\"] = DrawingControlsGroup\nelements[\"pl-drawing-button\"] = DrawingControlsButton\n# Store elements that have been registered via extensions\nregistered_elements = {}\n# Helper Functions\ndef should_validate_attributes(name):\n    if name in elements:\n        return elements[name].validate_attributes()",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-controls\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-controls\"] = DrawingControls\nelements[\"pl-controls-group\"] = DrawingControlsGroup\nelements[\"pl-drawing-button\"] = DrawingControlsButton\n# Store elements that have been registered via extensions\nregistered_elements = {}\n# Helper Functions\ndef should_validate_attributes(name):\n    if name in elements:\n        return elements[name].validate_attributes()\n    else:",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-controls-group\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-controls-group\"] = DrawingControlsGroup\nelements[\"pl-drawing-button\"] = DrawingControlsButton\n# Store elements that have been registered via extensions\nregistered_elements = {}\n# Helper Functions\ndef should_validate_attributes(name):\n    if name in elements:\n        return elements[name].validate_attributes()\n    else:\n        return False",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "elements[\"pl-drawing-button\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "elements[\"pl-drawing-button\"] = DrawingControlsButton\n# Store elements that have been registered via extensions\nregistered_elements = {}\n# Helper Functions\ndef should_validate_attributes(name):\n    if name in elements:\n        return elements[name].validate_attributes()\n    else:\n        return False\ndef get_attributes(name):",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "registered_elements",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-drawing.elements",
        "description": "src.prairielearn.elements.pl-drawing.elements",
        "peekOfCode": "registered_elements = {}\n# Helper Functions\ndef should_validate_attributes(name):\n    if name in elements:\n        return elements[name].validate_attributes()\n    else:\n        return False\ndef get_attributes(name):\n    if name in elements:\n        return elements[name].get_attributes()",
        "detail": "src.prairielearn.elements.pl-drawing.elements",
        "documentation": {}
    },
    {
        "label": "union_drawing_items",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-drawing.pl-drawing",
        "description": "src.prairielearn.elements.pl-drawing.pl-drawing",
        "peekOfCode": "def union_drawing_items(e1, e2):\n    # Union two sets of drawing items, prioritizing e2 in cases of duplicates.\n    if e1 is not None:\n        obj1 = e1\n    else:\n        obj1 = []\n    if e2 is not None:\n        obj2 = e2\n    else:\n        obj2 = []",
        "detail": "src.prairielearn.elements.pl-drawing.pl-drawing",
        "documentation": {}
    },
    {
        "label": "load_extensions",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-drawing.pl-drawing",
        "description": "src.prairielearn.elements.pl-drawing.pl-drawing",
        "peekOfCode": "def load_extensions(data):\n    extensions = pl.load_all_extensions(data)\n    for name, ext in extensions.items():\n        elements.register_extension(name, ext, data)\ndef check_attributes_rec(element):\n    # Recursively check attributes for a tree of elements\n    name = element.tag\n    attributes = elements.get_attributes(name)\n    if elements.should_validate_attributes(name):\n        try:",
        "detail": "src.prairielearn.elements.pl-drawing.pl-drawing",
        "documentation": {}
    },
    {
        "label": "check_attributes_rec",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-drawing.pl-drawing",
        "description": "src.prairielearn.elements.pl-drawing.pl-drawing",
        "peekOfCode": "def check_attributes_rec(element):\n    # Recursively check attributes for a tree of elements\n    name = element.tag\n    attributes = elements.get_attributes(name)\n    if elements.should_validate_attributes(name):\n        try:\n            pl.check_attribs(element, required_attribs=[], optional_attribs=attributes)\n        except Exception as e:\n            print(f\"Error in {name}: {e}\")\n            raise e",
        "detail": "src.prairielearn.elements.pl-drawing.pl-drawing",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-drawing.pl-drawing",
        "description": "src.prairielearn.elements.pl-drawing.pl-drawing",
        "peekOfCode": "def prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    check_attributes_rec(element)\n    w_button = None\n    prev = not pl.get_boolean_attrib(\n        element, \"gradable\", defaults.element_defaults[\"gradable\"]\n    )\n    load_extensions(data)\n    # Some preparation for elements with grading componenet\n    if not prev:",
        "detail": "src.prairielearn.elements.pl-drawing.pl-drawing",
        "documentation": {}
    },
    {
        "label": "render_controls",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-drawing.pl-drawing",
        "description": "src.prairielearn.elements.pl-drawing.pl-drawing",
        "peekOfCode": "def render_controls(template, elem):\n    if elem.tag == \"pl-controls\":\n        markup = \"\"\n        for el in elem:\n            if el.tag is lxml.etree.Comment:\n                continue\n            markup += render_controls(template, el) + \"<br>\\n\"\n        return markup\n    elif elem.tag == \"pl-drawing-button\":\n        type_name = elem.attrib.get(\"type\", None)",
        "detail": "src.prairielearn.elements.pl-drawing.pl-drawing",
        "documentation": {}
    },
    {
        "label": "render_drawing_items",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-drawing.pl-drawing",
        "description": "src.prairielearn.elements.pl-drawing.pl-drawing",
        "peekOfCode": "def render_drawing_items(elem, curid=0, defaults={}):\n    # Convert a set of drawing items defined as html elements into an array of\n    # objects that can be sent to mechanicsObjects.js\n    # Some helpers to get attributes from elements.  If there is no default argument passed in,\n    # it is assumed that the attribute must be present or else an error will be raised.  If a\n    # default is passed, the attribute is optional.\n    objects = []\n    for el in elem:\n        if el.tag is lxml.etree.Comment:\n            continue",
        "detail": "src.prairielearn.elements.pl-drawing.pl-drawing",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-drawing.pl-drawing",
        "description": "src.prairielearn.elements.pl-drawing.pl-drawing",
        "peekOfCode": "def render(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\", \"\")\n    preview_mode = not pl.get_boolean_attrib(\n        element, \"gradable\", defaults.element_defaults[\"gradable\"]\n    )\n    with open(\"pl-drawing.mustache\") as f:\n        template = f.read()\n    btn_markup = \"\"\n    init = []",
        "detail": "src.prairielearn.elements.pl-drawing.pl-drawing",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-drawing.pl-drawing",
        "description": "src.prairielearn.elements.pl-drawing.pl-drawing",
        "peekOfCode": "def parse(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(\n        element, \"answers-name\", defaults.element_defaults[\"answers-name\"]\n    )\n    preview_mode = not pl.get_boolean_attrib(\n        element, \"gradable\", defaults.element_defaults[\"gradable\"]\n    )\n    if preview_mode:\n        return",
        "detail": "src.prairielearn.elements.pl-drawing.pl-drawing",
        "documentation": {}
    },
    {
        "label": "grade",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-drawing.pl-drawing",
        "description": "src.prairielearn.elements.pl-drawing.pl-drawing",
        "peekOfCode": "def grade(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    prev = not pl.get_boolean_attrib(\n        element, \"gradable\", defaults.element_defaults[\"gradable\"]\n    )\n    if prev:\n        return\n    grid_size = pl.get_integer_attrib(\n        element, \"grid-size\", defaults.element_defaults[\"grid-size\"]\n    )",
        "detail": "src.prairielearn.elements.pl-drawing.pl-drawing",
        "documentation": {}
    },
    {
        "label": "SortTypes",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "description": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "peekOfCode": "class SortTypes(Enum):\n    RANDOM = \"random\"\n    ASCEND = \"ascend\"\n    DESCEND = \"descend\"\n    FIXED = \"fixed\"\ndef get_options(element, data):\n    answers_name = pl.get_string_attrib(element, \"answers-name\")\n    submitted_answer = data.get(\"submitted_answers\", {}).get(answers_name, None)\n    options = []\n    for child in element:",
        "detail": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "documentation": {}
    },
    {
        "label": "get_options",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "description": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "peekOfCode": "def get_options(element, data):\n    answers_name = pl.get_string_attrib(element, \"answers-name\")\n    submitted_answer = data.get(\"submitted_answers\", {}).get(answers_name, None)\n    options = []\n    for child in element:\n        if child.tag in [\"pl-answer\"]:\n            pl.check_attribs(child, required_attribs=[], optional_attribs=[\"correct\"])\n            child_html = pl.inner_html(child).strip()\n            options.append(\n                {\"value\": child_html, \"selected\": (child_html == submitted_answer)}",
        "detail": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "documentation": {}
    },
    {
        "label": "get_solution",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "description": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "peekOfCode": "def get_solution(element, data):\n    solution = []\n    for child in element:\n        if child.tag in [\"pl-answer\"]:\n            pl.check_attribs(child, required_attribs=[], optional_attribs=[\"correct\"])\n            is_correct = pl.get_boolean_attrib(child, \"correct\", False)\n            child_html = pl.inner_html(child).strip()\n            if is_correct:\n                solution.append(child_html)\n    if len(solution) > 1:",
        "detail": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "description": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "peekOfCode": "def prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    pl.check_attribs(\n        element,\n        required_attribs=[\"answers-name\"],\n        optional_attribs=[\"blank\", \"allow-blank\", \"weight\", \"sort\"],\n    )\n    if pl.get_boolean_attrib(\n        element, \"allow-blank\", ALLOW_BLANK_DEFAULT\n    ) and not pl.get_boolean_attrib(element, \"blank\", BLANK_DEFAULT):",
        "detail": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "description": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "peekOfCode": "def render(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    answers_name = pl.get_string_attrib(element, \"answers-name\")\n    dropdown_options = get_options(element, data)\n    submitted_answer = data[\"submitted_answers\"].get(answers_name, None)\n    sort_type = pl.get_string_attrib(element, \"sort\", SORT_DEFAULT).upper().strip()\n    blank_start = pl.get_boolean_attrib(element, \"blank\", BLANK_DEFAULT)\n    correct = None\n    partial_score = data[\"partial_scores\"].get(answers_name, {\"score\": None})\n    score = partial_score.get(\"score\", None)",
        "detail": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "description": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "peekOfCode": "def parse(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    allow_blank = pl.get_boolean_attrib(element, \"allow-blank\", ALLOW_BLANK_DEFAULT)\n    answers_name = pl.get_string_attrib(element, \"answers-name\")\n    answer = data[\"submitted_answers\"].get(answers_name, None)\n    # Blank option should be available, but cause format error when submitted and blank is not allowed.\n    valid_options = [BLANK_ANSWER]\n    for child in element:\n        if child.tag in [\"pl-answer\"]:\n            pl.check_attribs(child, required_attribs=[], optional_attribs=[\"correct\"])",
        "detail": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "documentation": {}
    },
    {
        "label": "grade",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "description": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "peekOfCode": "def grade(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    answers_name = pl.get_string_attrib(element, \"answers-name\")\n    weight = pl.get_integer_attrib(element, \"weight\", WEIGHT_DEFAULT)\n    submitted_answer = data[\"submitted_answers\"].get(answers_name, None)\n    if data[\"correct_answers\"][answers_name] == submitted_answer:\n        data[\"partial_scores\"][answers_name] = {\"score\": 1, \"weight\": weight}\n    else:\n        data[\"partial_scores\"][answers_name] = {\"score\": 0, \"weight\": weight}\ndef test(element_html, data):",
        "detail": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "description": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "peekOfCode": "def test(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    answers_name = pl.get_string_attrib(element, \"answers-name\")\n    weight = pl.get_integer_attrib(element, \"weight\", WEIGHT_DEFAULT)\n    # solution is what the answer should be\n    solution = get_solution(element, data)\n    # incorrect and correct answer test cases\n    if data[\"test_type\"] == \"correct\":\n        data[\"raw_submitted_answers\"][answers_name] = solution\n        data[\"partial_scores\"][answers_name] = {\"score\": 1, \"weight\": weight}",
        "detail": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "documentation": {}
    },
    {
        "label": "WEIGHT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "description": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "peekOfCode": "WEIGHT_DEFAULT = 1\nBLANK_ANSWER = \" \"\nBLANK_DEFAULT = True\nSORT_DEFAULT = \"random\"\nALLOW_BLANK_DEFAULT = False\nclass SortTypes(Enum):\n    RANDOM = \"random\"\n    ASCEND = \"ascend\"\n    DESCEND = \"descend\"\n    FIXED = \"fixed\"",
        "detail": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "documentation": {}
    },
    {
        "label": "BLANK_ANSWER",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "description": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "peekOfCode": "BLANK_ANSWER = \" \"\nBLANK_DEFAULT = True\nSORT_DEFAULT = \"random\"\nALLOW_BLANK_DEFAULT = False\nclass SortTypes(Enum):\n    RANDOM = \"random\"\n    ASCEND = \"ascend\"\n    DESCEND = \"descend\"\n    FIXED = \"fixed\"\ndef get_options(element, data):",
        "detail": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "documentation": {}
    },
    {
        "label": "BLANK_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "description": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "peekOfCode": "BLANK_DEFAULT = True\nSORT_DEFAULT = \"random\"\nALLOW_BLANK_DEFAULT = False\nclass SortTypes(Enum):\n    RANDOM = \"random\"\n    ASCEND = \"ascend\"\n    DESCEND = \"descend\"\n    FIXED = \"fixed\"\ndef get_options(element, data):\n    answers_name = pl.get_string_attrib(element, \"answers-name\")",
        "detail": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "documentation": {}
    },
    {
        "label": "SORT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "description": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "peekOfCode": "SORT_DEFAULT = \"random\"\nALLOW_BLANK_DEFAULT = False\nclass SortTypes(Enum):\n    RANDOM = \"random\"\n    ASCEND = \"ascend\"\n    DESCEND = \"descend\"\n    FIXED = \"fixed\"\ndef get_options(element, data):\n    answers_name = pl.get_string_attrib(element, \"answers-name\")\n    submitted_answer = data.get(\"submitted_answers\", {}).get(answers_name, None)",
        "detail": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "documentation": {}
    },
    {
        "label": "ALLOW_BLANK_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "description": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "peekOfCode": "ALLOW_BLANK_DEFAULT = False\nclass SortTypes(Enum):\n    RANDOM = \"random\"\n    ASCEND = \"ascend\"\n    DESCEND = \"descend\"\n    FIXED = \"fixed\"\ndef get_options(element, data):\n    answers_name = pl.get_string_attrib(element, \"answers-name\")\n    submitted_answer = data.get(\"submitted_answers\", {}).get(answers_name, None)\n    options = []",
        "detail": "src.prairielearn.elements.pl-dropdown.pl-dropdown",
        "documentation": {}
    },
    {
        "label": "is_answer_name_required",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "description": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "peekOfCode": "def is_answer_name_required(gradable: bool) -> bool:\n    \"\"\"All cases marked (ANS)\"\"\"\n    return gradable\ndef is_widget_editable(panel: str, gradable: bool, editable: bool) -> bool:\n    \"\"\"All cases where `(RW)` is marked. data[\"editable\"] must also be True\"\"\"\n    return panel == \"question\" and gradable and editable\ndef is_source_file_name_required(panel: str, gradable: bool, fresh: bool) -> bool:\n    \"\"\"All cases where `NoSource: Raise an error`\"\"\"\n    return not gradable and (\n        (panel == \"question\" and fresh) or panel in (\"answer\", \"submission\")",
        "detail": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "documentation": {}
    },
    {
        "label": "is_widget_editable",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "description": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "peekOfCode": "def is_widget_editable(panel: str, gradable: bool, editable: bool) -> bool:\n    \"\"\"All cases where `(RW)` is marked. data[\"editable\"] must also be True\"\"\"\n    return panel == \"question\" and gradable and editable\ndef is_source_file_name_required(panel: str, gradable: bool, fresh: bool) -> bool:\n    \"\"\"All cases where `NoSource: Raise an error`\"\"\"\n    return not gradable and (\n        (panel == \"question\" and fresh) or panel in (\"answer\", \"submission\")\n    )\n# -----------------------------------------------------------------------------\ndef prepare(element_html: str, data: pl.QuestionData) -> None:",
        "detail": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "documentation": {}
    },
    {
        "label": "is_source_file_name_required",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "description": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "peekOfCode": "def is_source_file_name_required(panel: str, gradable: bool, fresh: bool) -> bool:\n    \"\"\"All cases where `NoSource: Raise an error`\"\"\"\n    return not gradable and (\n        (panel == \"question\" and fresh) or panel in (\"answer\", \"submission\")\n    )\n# -----------------------------------------------------------------------------\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attrs = []\n    optional_attrs = [",
        "detail": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "description": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "peekOfCode": "def prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attrs = []\n    optional_attrs = [\n        ATTR_GRADABLE,\n        ATTR_ANSWER_NAME,\n        ATTR_WIDTH,\n        ATTR_HEIGHT,\n        ATTR_SOURCE_FILE_NAME,\n        ATTR_SOURCE_DIRECTORY,",
        "detail": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "documentation": {}
    },
    {
        "label": "load_file_content",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "description": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "peekOfCode": "def load_file_content(element: HtmlElement, data: pl.QuestionData) -> str:\n    file_dir = SOURCE_DIRECTORY_MAP[\n        pl.get_string_attrib(element, ATTR_SOURCE_DIRECTORY, \".\")\n    ]\n    file = Path(data[\"options\"][file_dir]) / pl.get_string_attrib(\n        element, ATTR_SOURCE_FILE_NAME\n    )\n    if not file.exists():\n        raise RuntimeError(f\"Unknown file path: {file}\")\n    return file.read_text(encoding=\"utf-8\")",
        "detail": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "description": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "peekOfCode": "def render(element_html: str, data: pl.QuestionData) -> str:\n    empty_diagram = \"\"  # pick a default representation\n    element = lxml.html.fragment_fromstring(element_html)\n    drawing_name = pl.get_string_attrib(element, ATTR_ANSWER_NAME, None)\n    gradable = pl.get_boolean_attrib(element, ATTR_GRADABLE, True)\n    fresh = drawing_name not in data[\"submitted_answers\"]\n    panel = data[\"panel\"]\n    source_available = pl.has_attrib(element, ATTR_SOURCE_FILE_NAME)\n    # the state space (for debugging)\n    matrix = f\"{gradable=} {fresh=} {panel=} {source_available=}\"",
        "detail": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "description": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "peekOfCode": "def parse(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    drawing_name = pl.get_string_attrib(element, ATTR_ANSWER_NAME, None)\n    if drawing_name:\n        try:\n            # Check the submissions if available\n            if drawing_name in data[\"submitted_answers\"]:\n                json.loads(data[\"submitted_answers\"][drawing_name])\n        except Exception as e:\n            if drawing_name not in data[\"format_errors\"]:",
        "detail": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "documentation": {}
    },
    {
        "label": "ATTR_ANSWER_NAME",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "description": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "peekOfCode": "ATTR_ANSWER_NAME = \"answers-name\"\nATTR_WIDTH = \"width\"\nATTR_HEIGHT = \"height\"\nATTR_SOURCE_FILE_NAME = \"source-file-name\"\nATTR_SOURCE_DIRECTORY = \"directory\"\nATTR_GRADABLE = \"gradable\"\nSOURCE_DIRECTORY_MAP = {\n    \"serverFilesCourse\": \"server_files_course_path\",\n    \"clientFilesCourse\": \"client_files_course_path\",\n    \"clientFilesQuestion\": \"client_files_question_path\",",
        "detail": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "documentation": {}
    },
    {
        "label": "ATTR_WIDTH",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "description": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "peekOfCode": "ATTR_WIDTH = \"width\"\nATTR_HEIGHT = \"height\"\nATTR_SOURCE_FILE_NAME = \"source-file-name\"\nATTR_SOURCE_DIRECTORY = \"directory\"\nATTR_GRADABLE = \"gradable\"\nSOURCE_DIRECTORY_MAP = {\n    \"serverFilesCourse\": \"server_files_course_path\",\n    \"clientFilesCourse\": \"client_files_course_path\",\n    \"clientFilesQuestion\": \"client_files_question_path\",\n    \".\": \"question_path\",",
        "detail": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "documentation": {}
    },
    {
        "label": "ATTR_HEIGHT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "description": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "peekOfCode": "ATTR_HEIGHT = \"height\"\nATTR_SOURCE_FILE_NAME = \"source-file-name\"\nATTR_SOURCE_DIRECTORY = \"directory\"\nATTR_GRADABLE = \"gradable\"\nSOURCE_DIRECTORY_MAP = {\n    \"serverFilesCourse\": \"server_files_course_path\",\n    \"clientFilesCourse\": \"client_files_course_path\",\n    \"clientFilesQuestion\": \"client_files_question_path\",\n    \".\": \"question_path\",\n}",
        "detail": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "documentation": {}
    },
    {
        "label": "ATTR_SOURCE_FILE_NAME",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "description": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "peekOfCode": "ATTR_SOURCE_FILE_NAME = \"source-file-name\"\nATTR_SOURCE_DIRECTORY = \"directory\"\nATTR_GRADABLE = \"gradable\"\nSOURCE_DIRECTORY_MAP = {\n    \"serverFilesCourse\": \"server_files_course_path\",\n    \"clientFilesCourse\": \"client_files_course_path\",\n    \"clientFilesQuestion\": \"client_files_question_path\",\n    \".\": \"question_path\",\n}\n# -----------------------------------------------------------------------------",
        "detail": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "documentation": {}
    },
    {
        "label": "ATTR_SOURCE_DIRECTORY",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "description": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "peekOfCode": "ATTR_SOURCE_DIRECTORY = \"directory\"\nATTR_GRADABLE = \"gradable\"\nSOURCE_DIRECTORY_MAP = {\n    \"serverFilesCourse\": \"server_files_course_path\",\n    \"clientFilesCourse\": \"client_files_course_path\",\n    \"clientFilesQuestion\": \"client_files_question_path\",\n    \".\": \"question_path\",\n}\n# -----------------------------------------------------------------------------\n# The logic below is derived from the combinations at",
        "detail": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "documentation": {}
    },
    {
        "label": "ATTR_GRADABLE",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "description": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "peekOfCode": "ATTR_GRADABLE = \"gradable\"\nSOURCE_DIRECTORY_MAP = {\n    \"serverFilesCourse\": \"server_files_course_path\",\n    \"clientFilesCourse\": \"client_files_course_path\",\n    \"clientFilesQuestion\": \"client_files_question_path\",\n    \".\": \"question_path\",\n}\n# -----------------------------------------------------------------------------\n# The logic below is derived from the combinations at\n# https://github.com/PrairieLearn/PrairieLearn/pull/9900#discussion_r1685163461",
        "detail": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "documentation": {}
    },
    {
        "label": "SOURCE_DIRECTORY_MAP",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "description": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "peekOfCode": "SOURCE_DIRECTORY_MAP = {\n    \"serverFilesCourse\": \"server_files_course_path\",\n    \"clientFilesCourse\": \"client_files_course_path\",\n    \"clientFilesQuestion\": \"client_files_question_path\",\n    \".\": \"question_path\",\n}\n# -----------------------------------------------------------------------------\n# The logic below is derived from the combinations at\n# https://github.com/PrairieLearn/PrairieLearn/pull/9900#discussion_r1685163461\ndef is_answer_name_required(gradable: bool) -> bool:",
        "detail": "src.prairielearn.elements.pl-excalidraw.pl-excalidraw",
        "documentation": {}
    },
    {
        "label": "ansi_to_html",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-external-grader-results.pl-external-grader-results",
        "description": "src.prairielearn.elements.pl-external-grader-results.pl-external-grader-results",
        "peekOfCode": "def ansi_to_html(output: str | None) -> str | None:\n    if output is None:\n        return None\n    try:\n        return conv.convert(output, full=False)\n    except Exception as e:\n        return f\"[Error converting ANSI to HTML: {e}]\\n\\n{output}\"\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs: list[str] = []",
        "detail": "src.prairielearn.elements.pl-external-grader-results.pl-external-grader-results",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-external-grader-results.pl-external-grader-results",
        "description": "src.prairielearn.elements.pl-external-grader-results.pl-external-grader-results",
        "peekOfCode": "def prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs: list[str] = []\n    optional_attribs: list[str] = []\n    pl.check_attribs(element, required_attribs, optional_attribs)\ndef round_value(value: float, digits: int = 2) -> str:\n    \"\"\"\n    Round the given value to the specified precision; default is 2 digits.\n    Remove trailing 0s and '.'s, e.g., convert \"1.00\" to \"1\".\n    \"\"\"",
        "detail": "src.prairielearn.elements.pl-external-grader-results.pl-external-grader-results",
        "documentation": {}
    },
    {
        "label": "round_value",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-external-grader-results.pl-external-grader-results",
        "description": "src.prairielearn.elements.pl-external-grader-results.pl-external-grader-results",
        "peekOfCode": "def round_value(value: float, digits: int = 2) -> str:\n    \"\"\"\n    Round the given value to the specified precision; default is 2 digits.\n    Remove trailing 0s and '.'s, e.g., convert \"1.00\" to \"1\".\n    \"\"\"\n    return f\"{value:.{digits}f}\".rstrip(\"0\").rstrip(\".\")\ndef render(element_html: str, data: pl.QuestionData) -> str:\n    # Early-exit if not the submission panel\n    if data[\"panel\"] != \"submission\":\n        return \"\"",
        "detail": "src.prairielearn.elements.pl-external-grader-results.pl-external-grader-results",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-external-grader-results.pl-external-grader-results",
        "description": "src.prairielearn.elements.pl-external-grader-results.pl-external-grader-results",
        "peekOfCode": "def render(element_html: str, data: pl.QuestionData) -> str:\n    # Early-exit if not the submission panel\n    if data[\"panel\"] != \"submission\":\n        return \"\"\n    feedback = data[\"feedback\"]\n    results = feedback.get(\"results\", None)\n    grading_succeeded = bool(feedback.get(\"succeeded\", False))\n    format_errors = data.get(\"format_errors\", {})\n    grader_format_errors = format_errors.get(\"_external_grader\", [])\n    html_params = {",
        "detail": "src.prairielearn.elements.pl-external-grader-results.pl-external-grader-results",
        "documentation": {}
    },
    {
        "label": "ansi2html_style.SCHEME[\"iterm\"]",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-external-grader-results.pl-external-grader-results",
        "description": "src.prairielearn.elements.pl-external-grader-results.pl-external-grader-results",
        "peekOfCode": "ansi2html_style.SCHEME[\"iterm\"] = (\n    \"#000000\",\n    \"#c91b00\",\n    \"#00c200\",\n    \"#c7c400\",\n    \"#0037da\",\n    \"#c930c7\",\n    \"#00c5c7\",\n    \"#c7c7c7\",\n    \"#676767\",",
        "detail": "src.prairielearn.elements.pl-external-grader-results.pl-external-grader-results",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-external-grader-variables.pl-external-grader-variables",
        "description": "src.prairielearn.elements.pl-external-grader-variables.pl-external-grader-variables",
        "peekOfCode": "def prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    pl.check_attribs(element, [\"params-name\"], [\"empty\"])\n    params_name = pl.get_string_attrib(element, \"params-name\")\n    # Get any variables defined in HTML\n    html_variables = []\n    for child in element:\n        if child.tag == \"pl-variable\":\n            pl.check_attribs(child, [\"name\", \"type\"], [])\n            var_dict = {",
        "detail": "src.prairielearn.elements.pl-external-grader-variables.pl-external-grader-variables",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-external-grader-variables.pl-external-grader-variables",
        "description": "src.prairielearn.elements.pl-external-grader-variables.pl-external-grader-variables",
        "peekOfCode": "def render(element_html: str, data: pl.QuestionData) -> str:\n    element = lxml.html.fragment_fromstring(element_html)\n    params_name = pl.get_string_attrib(element, \"params-name\")\n    # Get final variables list\n    names_user_description = data[\"params\"][params_name]\n    has_names_user_description = len(names_user_description) > 0\n    # Show descriptions if any variable has them set (non-empty and not None)\n    has_descriptions = any(d.get(\"description\", None) for d in names_user_description)\n    html_params = {\n        \"has_descriptions\": has_descriptions,",
        "detail": "src.prairielearn.elements.pl-external-grader-variables.pl-external-grader-variables",
        "documentation": {}
    },
    {
        "label": "EMPTY_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-external-grader-variables.pl-external-grader-variables",
        "description": "src.prairielearn.elements.pl-external-grader-variables.pl-external-grader-variables",
        "peekOfCode": "EMPTY_DEFAULT = False\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    pl.check_attribs(element, [\"params-name\"], [\"empty\"])\n    params_name = pl.get_string_attrib(element, \"params-name\")\n    # Get any variables defined in HTML\n    html_variables = []\n    for child in element:\n        if child.tag == \"pl-variable\":\n            pl.check_attribs(child, [\"name\", \"type\"], [])",
        "detail": "src.prairielearn.elements.pl-external-grader-variables.pl-external-grader-variables",
        "documentation": {}
    },
    {
        "label": "FileType",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-figure.pl-figure",
        "description": "src.prairielearn.elements.pl-figure.pl-figure",
        "peekOfCode": "class FileType(Enum):\n    STATIC = 1\n    DYNAMIC = 2\nWIDTH_DEFAULT = None\nFILE_TYPE_DEFAULT = FileType.STATIC\nDIRECTORY_DEFAULT = \"clientFilesQuestion\"\nINLINE_DEFAULT = False\nALT_TEXT_DEFAULT = \"\"\nDIRECTORY_URL_DICT = {\n    \"clientFilesQuestion\": \"client_files_question_url\",",
        "detail": "src.prairielearn.elements.pl-figure.pl-figure",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-figure.pl-figure",
        "description": "src.prairielearn.elements.pl-figure.pl-figure",
        "peekOfCode": "def prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    pl.check_attribs(\n        element,\n        required_attribs=[\"file-name\"],\n        optional_attribs=[\"width\", \"type\", \"directory\", \"inline\", \"alt\"],\n    )\n    file_type = pl.get_enum_attrib(element, \"type\", FileType, FILE_TYPE_DEFAULT)\n    # If the file is static, validate that it exists on disk\n    if file_type is FileType.STATIC:",
        "detail": "src.prairielearn.elements.pl-figure.pl-figure",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-figure.pl-figure",
        "description": "src.prairielearn.elements.pl-figure.pl-figure",
        "peekOfCode": "def render(element_html: str, data: pl.QuestionData) -> str:\n    element = lxml.html.fragment_fromstring(element_html)\n    # Get file name or raise exception if one does not exist\n    file_name = pl.get_string_attrib(element, \"file-name\")\n    # Get type (default is static)\n    file_type = pl.get_enum_attrib(element, \"type\", FileType, FILE_TYPE_DEFAULT)\n    # Get inline (default is false)\n    inline = pl.get_boolean_attrib(element, \"inline\", INLINE_DEFAULT)\n    # Get alternate-text text (default is PrairieLearn Image)\n    alt_text = pl.get_string_attrib(element, \"alt\", ALT_TEXT_DEFAULT)",
        "detail": "src.prairielearn.elements.pl-figure.pl-figure",
        "documentation": {}
    },
    {
        "label": "WIDTH_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-figure.pl-figure",
        "description": "src.prairielearn.elements.pl-figure.pl-figure",
        "peekOfCode": "WIDTH_DEFAULT = None\nFILE_TYPE_DEFAULT = FileType.STATIC\nDIRECTORY_DEFAULT = \"clientFilesQuestion\"\nINLINE_DEFAULT = False\nALT_TEXT_DEFAULT = \"\"\nDIRECTORY_URL_DICT = {\n    \"clientFilesQuestion\": \"client_files_question_url\",\n    \"clientFilesCourse\": \"client_files_course_url\",\n}\nDIRECTORY_PATH_DICT = {",
        "detail": "src.prairielearn.elements.pl-figure.pl-figure",
        "documentation": {}
    },
    {
        "label": "FILE_TYPE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-figure.pl-figure",
        "description": "src.prairielearn.elements.pl-figure.pl-figure",
        "peekOfCode": "FILE_TYPE_DEFAULT = FileType.STATIC\nDIRECTORY_DEFAULT = \"clientFilesQuestion\"\nINLINE_DEFAULT = False\nALT_TEXT_DEFAULT = \"\"\nDIRECTORY_URL_DICT = {\n    \"clientFilesQuestion\": \"client_files_question_url\",\n    \"clientFilesCourse\": \"client_files_course_url\",\n}\nDIRECTORY_PATH_DICT = {\n    \"clientFilesQuestion\": \"client_files_question_path\",",
        "detail": "src.prairielearn.elements.pl-figure.pl-figure",
        "documentation": {}
    },
    {
        "label": "DIRECTORY_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-figure.pl-figure",
        "description": "src.prairielearn.elements.pl-figure.pl-figure",
        "peekOfCode": "DIRECTORY_DEFAULT = \"clientFilesQuestion\"\nINLINE_DEFAULT = False\nALT_TEXT_DEFAULT = \"\"\nDIRECTORY_URL_DICT = {\n    \"clientFilesQuestion\": \"client_files_question_url\",\n    \"clientFilesCourse\": \"client_files_course_url\",\n}\nDIRECTORY_PATH_DICT = {\n    \"clientFilesQuestion\": \"client_files_question_path\",\n    \"clientFilesCourse\": \"client_files_course_path\",",
        "detail": "src.prairielearn.elements.pl-figure.pl-figure",
        "documentation": {}
    },
    {
        "label": "INLINE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-figure.pl-figure",
        "description": "src.prairielearn.elements.pl-figure.pl-figure",
        "peekOfCode": "INLINE_DEFAULT = False\nALT_TEXT_DEFAULT = \"\"\nDIRECTORY_URL_DICT = {\n    \"clientFilesQuestion\": \"client_files_question_url\",\n    \"clientFilesCourse\": \"client_files_course_url\",\n}\nDIRECTORY_PATH_DICT = {\n    \"clientFilesQuestion\": \"client_files_question_path\",\n    \"clientFilesCourse\": \"client_files_course_path\",\n}",
        "detail": "src.prairielearn.elements.pl-figure.pl-figure",
        "documentation": {}
    },
    {
        "label": "ALT_TEXT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-figure.pl-figure",
        "description": "src.prairielearn.elements.pl-figure.pl-figure",
        "peekOfCode": "ALT_TEXT_DEFAULT = \"\"\nDIRECTORY_URL_DICT = {\n    \"clientFilesQuestion\": \"client_files_question_url\",\n    \"clientFilesCourse\": \"client_files_course_url\",\n}\nDIRECTORY_PATH_DICT = {\n    \"clientFilesQuestion\": \"client_files_question_path\",\n    \"clientFilesCourse\": \"client_files_course_path\",\n}\ndef prepare(element_html: str, data: pl.QuestionData) -> None:",
        "detail": "src.prairielearn.elements.pl-figure.pl-figure",
        "documentation": {}
    },
    {
        "label": "DIRECTORY_URL_DICT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-figure.pl-figure",
        "description": "src.prairielearn.elements.pl-figure.pl-figure",
        "peekOfCode": "DIRECTORY_URL_DICT = {\n    \"clientFilesQuestion\": \"client_files_question_url\",\n    \"clientFilesCourse\": \"client_files_course_url\",\n}\nDIRECTORY_PATH_DICT = {\n    \"clientFilesQuestion\": \"client_files_question_path\",\n    \"clientFilesCourse\": \"client_files_course_path\",\n}\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)",
        "detail": "src.prairielearn.elements.pl-figure.pl-figure",
        "documentation": {}
    },
    {
        "label": "DIRECTORY_PATH_DICT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-figure.pl-figure",
        "description": "src.prairielearn.elements.pl-figure.pl-figure",
        "peekOfCode": "DIRECTORY_PATH_DICT = {\n    \"clientFilesQuestion\": \"client_files_question_path\",\n    \"clientFilesCourse\": \"client_files_course_path\",\n}\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    pl.check_attribs(\n        element,\n        required_attribs=[\"file-name\"],\n        optional_attribs=[\"width\", \"type\", \"directory\", \"inline\", \"alt\"],",
        "detail": "src.prairielearn.elements.pl-figure.pl-figure",
        "documentation": {}
    },
    {
        "label": "FileType",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-file-download.pl-file-download",
        "description": "src.prairielearn.elements.pl-file-download.pl-file-download",
        "peekOfCode": "class FileType(Enum):\n    STATIC = 1\n    DYNAMIC = 2\nFILE_TYPE_DEFAULT = FileType.STATIC\nDIRECTORY_DEFAULT = \"clientFilesQuestion\"\nFORCE_DOWNLOAD_DEFAULT = True\nDIRECTORY_URL_DICT = {\n    \"clientFilesQuestion\": \"client_files_question_url\",\n    \"clientFilesCourse\": \"client_files_course_url\",\n}",
        "detail": "src.prairielearn.elements.pl-file-download.pl-file-download",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-file-download.pl-file-download",
        "description": "src.prairielearn.elements.pl-file-download.pl-file-download",
        "peekOfCode": "def prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    pl.check_attribs(\n        element,\n        required_attribs=[\"file-name\"],\n        optional_attribs=[\"type\", \"directory\", \"label\", \"force-download\"],\n    )\n    file_type = pl.get_enum_attrib(element, \"type\", FileType, FILE_TYPE_DEFAULT)\n    # If the file is static, validate that it exists on disk\n    if file_type is FileType.STATIC:",
        "detail": "src.prairielearn.elements.pl-file-download.pl-file-download",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-file-download.pl-file-download",
        "description": "src.prairielearn.elements.pl-file-download.pl-file-download",
        "peekOfCode": "def render(element_html: str, data: pl.QuestionData) -> str:\n    element = lxml.html.fragment_fromstring(element_html)\n    # Get file name or raise exception if one does not exist\n    file_name = pl.get_string_attrib(element, \"file-name\")\n    # Get type (default is static)\n    file_type = pl.get_enum_attrib(element, \"type\", FileType, FILE_TYPE_DEFAULT)\n    # Get directory (default is clientFilesQuestion)\n    file_directory = pl.get_string_attrib(element, \"directory\", DIRECTORY_DEFAULT)\n    # Get label (default is file_name)\n    file_label = pl.get_string_attrib(element, \"label\", file_name)",
        "detail": "src.prairielearn.elements.pl-file-download.pl-file-download",
        "documentation": {}
    },
    {
        "label": "FILE_TYPE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-file-download.pl-file-download",
        "description": "src.prairielearn.elements.pl-file-download.pl-file-download",
        "peekOfCode": "FILE_TYPE_DEFAULT = FileType.STATIC\nDIRECTORY_DEFAULT = \"clientFilesQuestion\"\nFORCE_DOWNLOAD_DEFAULT = True\nDIRECTORY_URL_DICT = {\n    \"clientFilesQuestion\": \"client_files_question_url\",\n    \"clientFilesCourse\": \"client_files_course_url\",\n}\nDIRECTORY_PATH_DICT = {\n    \"clientFilesQuestion\": \"client_files_question_path\",\n    \"clientFilesCourse\": \"client_files_course_path\",",
        "detail": "src.prairielearn.elements.pl-file-download.pl-file-download",
        "documentation": {}
    },
    {
        "label": "DIRECTORY_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-file-download.pl-file-download",
        "description": "src.prairielearn.elements.pl-file-download.pl-file-download",
        "peekOfCode": "DIRECTORY_DEFAULT = \"clientFilesQuestion\"\nFORCE_DOWNLOAD_DEFAULT = True\nDIRECTORY_URL_DICT = {\n    \"clientFilesQuestion\": \"client_files_question_url\",\n    \"clientFilesCourse\": \"client_files_course_url\",\n}\nDIRECTORY_PATH_DICT = {\n    \"clientFilesQuestion\": \"client_files_question_path\",\n    \"clientFilesCourse\": \"client_files_course_path\",\n}",
        "detail": "src.prairielearn.elements.pl-file-download.pl-file-download",
        "documentation": {}
    },
    {
        "label": "FORCE_DOWNLOAD_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-file-download.pl-file-download",
        "description": "src.prairielearn.elements.pl-file-download.pl-file-download",
        "peekOfCode": "FORCE_DOWNLOAD_DEFAULT = True\nDIRECTORY_URL_DICT = {\n    \"clientFilesQuestion\": \"client_files_question_url\",\n    \"clientFilesCourse\": \"client_files_course_url\",\n}\nDIRECTORY_PATH_DICT = {\n    \"clientFilesQuestion\": \"client_files_question_path\",\n    \"clientFilesCourse\": \"client_files_course_path\",\n}\ndef prepare(element_html: str, data: pl.QuestionData) -> None:",
        "detail": "src.prairielearn.elements.pl-file-download.pl-file-download",
        "documentation": {}
    },
    {
        "label": "DIRECTORY_URL_DICT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-file-download.pl-file-download",
        "description": "src.prairielearn.elements.pl-file-download.pl-file-download",
        "peekOfCode": "DIRECTORY_URL_DICT = {\n    \"clientFilesQuestion\": \"client_files_question_url\",\n    \"clientFilesCourse\": \"client_files_course_url\",\n}\nDIRECTORY_PATH_DICT = {\n    \"clientFilesQuestion\": \"client_files_question_path\",\n    \"clientFilesCourse\": \"client_files_course_path\",\n}\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)",
        "detail": "src.prairielearn.elements.pl-file-download.pl-file-download",
        "documentation": {}
    },
    {
        "label": "DIRECTORY_PATH_DICT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-file-download.pl-file-download",
        "description": "src.prairielearn.elements.pl-file-download.pl-file-download",
        "peekOfCode": "DIRECTORY_PATH_DICT = {\n    \"clientFilesQuestion\": \"client_files_question_path\",\n    \"clientFilesCourse\": \"client_files_course_path\",\n}\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    pl.check_attribs(\n        element,\n        required_attribs=[\"file-name\"],\n        optional_attribs=[\"type\", \"directory\", \"label\", \"force-download\"],",
        "detail": "src.prairielearn.elements.pl-file-download.pl-file-download",
        "documentation": {}
    },
    {
        "label": "get_answer_name",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "description": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "peekOfCode": "def get_answer_name(file_name: str) -> str:\n    return \"_file_editor_{0}\".format(\n        hashlib.sha1(file_name.encode(\"utf-8\")).hexdigest()\n    )\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"file-name\"]\n    optional_attribs = [\n        \"ace-mode\",\n        \"ace-theme\",",
        "detail": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "description": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "peekOfCode": "def prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"file-name\"]\n    optional_attribs = [\n        \"ace-mode\",\n        \"ace-theme\",\n        \"font-size\",\n        \"editor-config-function\",\n        \"source-file-name\",\n        \"min-lines\",",
        "detail": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "description": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "peekOfCode": "def render(element_html: str, data: pl.QuestionData) -> str:\n    if data[\"panel\"] != \"question\":\n        return \"\"\n    element = lxml.html.fragment_fromstring(element_html)\n    file_name = pl.get_string_attrib(element, \"file-name\", \"\")\n    answer_name = get_answer_name(file_name)\n    editor_config_function = pl.get_string_attrib(\n        element, \"editor-config-function\", EDITOR_CONFIG_FUNCTION_DEFAULT\n    )\n    ace_mode = pl.get_string_attrib(element, \"ace-mode\", ACE_MODE_DEFAULT)",
        "detail": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "description": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "peekOfCode": "def parse(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    file_name = pl.get_string_attrib(element, \"file-name\", \"\")\n    answer_name = get_answer_name(file_name)\n    normalize_to_ascii = pl.get_boolean_attrib(\n        element, \"normalize-to-ascii\", NORMALIZE_TO_ASCII_DEFAULT\n    )\n    allow_blank = pl.get_boolean_attrib(element, \"allow-blank\", ALLOW_BLANK_DEFAULT)\n    # Get submitted answer or return parse_error if it does not exist\n    file_contents = data[\"submitted_answers\"].get(answer_name, \"\")",
        "detail": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "documentation": {}
    },
    {
        "label": "EDITOR_CONFIG_FUNCTION_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "description": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "peekOfCode": "EDITOR_CONFIG_FUNCTION_DEFAULT = None\nACE_MODE_DEFAULT = None\nACE_THEME_DEFAULT = None\nFONT_SIZE_DEFAULT = None\nSOURCE_FILE_NAME_DEFAULT = None\nMIN_LINES_DEFAULT = None\nMAX_LINES_DEFAULT = None\nAUTO_RESIZE_DEFAULT = True\nPREVIEW_DEFAULT = None\nFOCUS_DEFAULT = False",
        "detail": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "documentation": {}
    },
    {
        "label": "ACE_MODE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "description": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "peekOfCode": "ACE_MODE_DEFAULT = None\nACE_THEME_DEFAULT = None\nFONT_SIZE_DEFAULT = None\nSOURCE_FILE_NAME_DEFAULT = None\nMIN_LINES_DEFAULT = None\nMAX_LINES_DEFAULT = None\nAUTO_RESIZE_DEFAULT = True\nPREVIEW_DEFAULT = None\nFOCUS_DEFAULT = False\nDIRECTORY_DEFAULT = \".\"",
        "detail": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "documentation": {}
    },
    {
        "label": "ACE_THEME_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "description": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "peekOfCode": "ACE_THEME_DEFAULT = None\nFONT_SIZE_DEFAULT = None\nSOURCE_FILE_NAME_DEFAULT = None\nMIN_LINES_DEFAULT = None\nMAX_LINES_DEFAULT = None\nAUTO_RESIZE_DEFAULT = True\nPREVIEW_DEFAULT = None\nFOCUS_DEFAULT = False\nDIRECTORY_DEFAULT = \".\"\nNORMALIZE_TO_ASCII_DEFAULT = False",
        "detail": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "documentation": {}
    },
    {
        "label": "FONT_SIZE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "description": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "peekOfCode": "FONT_SIZE_DEFAULT = None\nSOURCE_FILE_NAME_DEFAULT = None\nMIN_LINES_DEFAULT = None\nMAX_LINES_DEFAULT = None\nAUTO_RESIZE_DEFAULT = True\nPREVIEW_DEFAULT = None\nFOCUS_DEFAULT = False\nDIRECTORY_DEFAULT = \".\"\nNORMALIZE_TO_ASCII_DEFAULT = False\nALLOW_BLANK_DEFAULT = False",
        "detail": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "documentation": {}
    },
    {
        "label": "SOURCE_FILE_NAME_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "description": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "peekOfCode": "SOURCE_FILE_NAME_DEFAULT = None\nMIN_LINES_DEFAULT = None\nMAX_LINES_DEFAULT = None\nAUTO_RESIZE_DEFAULT = True\nPREVIEW_DEFAULT = None\nFOCUS_DEFAULT = False\nDIRECTORY_DEFAULT = \".\"\nNORMALIZE_TO_ASCII_DEFAULT = False\nALLOW_BLANK_DEFAULT = False\ndef get_answer_name(file_name: str) -> str:",
        "detail": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "documentation": {}
    },
    {
        "label": "MIN_LINES_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "description": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "peekOfCode": "MIN_LINES_DEFAULT = None\nMAX_LINES_DEFAULT = None\nAUTO_RESIZE_DEFAULT = True\nPREVIEW_DEFAULT = None\nFOCUS_DEFAULT = False\nDIRECTORY_DEFAULT = \".\"\nNORMALIZE_TO_ASCII_DEFAULT = False\nALLOW_BLANK_DEFAULT = False\ndef get_answer_name(file_name: str) -> str:\n    return \"_file_editor_{0}\".format(",
        "detail": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "documentation": {}
    },
    {
        "label": "MAX_LINES_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "description": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "peekOfCode": "MAX_LINES_DEFAULT = None\nAUTO_RESIZE_DEFAULT = True\nPREVIEW_DEFAULT = None\nFOCUS_DEFAULT = False\nDIRECTORY_DEFAULT = \".\"\nNORMALIZE_TO_ASCII_DEFAULT = False\nALLOW_BLANK_DEFAULT = False\ndef get_answer_name(file_name: str) -> str:\n    return \"_file_editor_{0}\".format(\n        hashlib.sha1(file_name.encode(\"utf-8\")).hexdigest()",
        "detail": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "documentation": {}
    },
    {
        "label": "AUTO_RESIZE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "description": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "peekOfCode": "AUTO_RESIZE_DEFAULT = True\nPREVIEW_DEFAULT = None\nFOCUS_DEFAULT = False\nDIRECTORY_DEFAULT = \".\"\nNORMALIZE_TO_ASCII_DEFAULT = False\nALLOW_BLANK_DEFAULT = False\ndef get_answer_name(file_name: str) -> str:\n    return \"_file_editor_{0}\".format(\n        hashlib.sha1(file_name.encode(\"utf-8\")).hexdigest()\n    )",
        "detail": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "documentation": {}
    },
    {
        "label": "PREVIEW_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "description": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "peekOfCode": "PREVIEW_DEFAULT = None\nFOCUS_DEFAULT = False\nDIRECTORY_DEFAULT = \".\"\nNORMALIZE_TO_ASCII_DEFAULT = False\nALLOW_BLANK_DEFAULT = False\ndef get_answer_name(file_name: str) -> str:\n    return \"_file_editor_{0}\".format(\n        hashlib.sha1(file_name.encode(\"utf-8\")).hexdigest()\n    )\ndef prepare(element_html: str, data: pl.QuestionData) -> None:",
        "detail": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "documentation": {}
    },
    {
        "label": "FOCUS_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "description": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "peekOfCode": "FOCUS_DEFAULT = False\nDIRECTORY_DEFAULT = \".\"\nNORMALIZE_TO_ASCII_DEFAULT = False\nALLOW_BLANK_DEFAULT = False\ndef get_answer_name(file_name: str) -> str:\n    return \"_file_editor_{0}\".format(\n        hashlib.sha1(file_name.encode(\"utf-8\")).hexdigest()\n    )\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)",
        "detail": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "documentation": {}
    },
    {
        "label": "DIRECTORY_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "description": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "peekOfCode": "DIRECTORY_DEFAULT = \".\"\nNORMALIZE_TO_ASCII_DEFAULT = False\nALLOW_BLANK_DEFAULT = False\ndef get_answer_name(file_name: str) -> str:\n    return \"_file_editor_{0}\".format(\n        hashlib.sha1(file_name.encode(\"utf-8\")).hexdigest()\n    )\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"file-name\"]",
        "detail": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "documentation": {}
    },
    {
        "label": "NORMALIZE_TO_ASCII_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "description": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "peekOfCode": "NORMALIZE_TO_ASCII_DEFAULT = False\nALLOW_BLANK_DEFAULT = False\ndef get_answer_name(file_name: str) -> str:\n    return \"_file_editor_{0}\".format(\n        hashlib.sha1(file_name.encode(\"utf-8\")).hexdigest()\n    )\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"file-name\"]\n    optional_attribs = [",
        "detail": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "documentation": {}
    },
    {
        "label": "ALLOW_BLANK_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "description": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "peekOfCode": "ALLOW_BLANK_DEFAULT = False\ndef get_answer_name(file_name: str) -> str:\n    return \"_file_editor_{0}\".format(\n        hashlib.sha1(file_name.encode(\"utf-8\")).hexdigest()\n    )\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"file-name\"]\n    optional_attribs = [\n        \"ace-mode\",",
        "detail": "src.prairielearn.elements.pl-file-editor.pl-file-editor",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-file-preview.pl-file-preview",
        "description": "src.prairielearn.elements.pl-file-preview.pl-file-preview",
        "peekOfCode": "def prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = []\n    optional_attribs = []\n    pl.check_attribs(element, required_attribs, optional_attribs)\ndef render(element_html: str, data: pl.QuestionData) -> str:\n    if data[\"panel\"] != \"submission\":\n        return \"\"\n    # Fetch any submitted files\n    submitted_files = data[\"submitted_answers\"].get(\"_files\", [])",
        "detail": "src.prairielearn.elements.pl-file-preview.pl-file-preview",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-file-preview.pl-file-preview",
        "description": "src.prairielearn.elements.pl-file-preview.pl-file-preview",
        "peekOfCode": "def render(element_html: str, data: pl.QuestionData) -> str:\n    if data[\"panel\"] != \"submission\":\n        return \"\"\n    # Fetch any submitted files\n    submitted_files = data[\"submitted_answers\"].get(\"_files\", [])\n    # Order alphabetically so we can display them in a consistent order\n    ordered_files = sorted(submitted_files, key=lambda x: x.get(\"name\", None))\n    html_params = {\n        \"uuid\": pl.get_uuid(),\n        \"submission_files_url\": data[\"options\"][\"submission_files_url\"],",
        "detail": "src.prairielearn.elements.pl-file-preview.pl-file-preview",
        "documentation": {}
    },
    {
        "label": "get_file_names_as_array",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-file-upload.pl-file-upload",
        "description": "src.prairielearn.elements.pl-file-upload.pl-file-upload",
        "peekOfCode": "def get_file_names_as_array(raw_file_names: str) -> list[str]:\n    reader = csv.reader(\n        StringIO(raw_file_names),\n        delimiter=\",\",\n        escapechar=\"\\\\\",\n        quoting=csv.QUOTE_NONE,\n        skipinitialspace=True,\n        strict=True,\n    )\n    return next(reader)",
        "detail": "src.prairielearn.elements.pl-file-upload.pl-file-upload",
        "documentation": {}
    },
    {
        "label": "get_answer_name",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-file-upload.pl-file-upload",
        "description": "src.prairielearn.elements.pl-file-upload.pl-file-upload",
        "peekOfCode": "def get_answer_name(file_names: str) -> str:\n    return \"_file_upload_{0}\".format(\n        hashlib.sha1(file_names.encode(\"utf-8\")).hexdigest()\n    )\ndef add_format_error(data: pl.QuestionData, error_string: str) -> None:\n    pl.add_files_format_error(data, error_string)\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"file-names\"]\n    optional_attribs = []",
        "detail": "src.prairielearn.elements.pl-file-upload.pl-file-upload",
        "documentation": {}
    },
    {
        "label": "add_format_error",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-file-upload.pl-file-upload",
        "description": "src.prairielearn.elements.pl-file-upload.pl-file-upload",
        "peekOfCode": "def add_format_error(data: pl.QuestionData, error_string: str) -> None:\n    pl.add_files_format_error(data, error_string)\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"file-names\"]\n    optional_attribs = []\n    pl.check_attribs(element, required_attribs, optional_attribs)\n    if \"_required_file_names\" not in data[\"params\"]:\n        data[\"params\"][\"_required_file_names\"] = []\n    file_names = get_file_names_as_array(pl.get_string_attrib(element, \"file-names\"))",
        "detail": "src.prairielearn.elements.pl-file-upload.pl-file-upload",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-file-upload.pl-file-upload",
        "description": "src.prairielearn.elements.pl-file-upload.pl-file-upload",
        "peekOfCode": "def prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"file-names\"]\n    optional_attribs = []\n    pl.check_attribs(element, required_attribs, optional_attribs)\n    if \"_required_file_names\" not in data[\"params\"]:\n        data[\"params\"][\"_required_file_names\"] = []\n    file_names = get_file_names_as_array(pl.get_string_attrib(element, \"file-names\"))\n    data[\"params\"][\"_required_file_names\"].extend(file_names)\ndef render(element_html: str, data: pl.QuestionData) -> str:",
        "detail": "src.prairielearn.elements.pl-file-upload.pl-file-upload",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-file-upload.pl-file-upload",
        "description": "src.prairielearn.elements.pl-file-upload.pl-file-upload",
        "peekOfCode": "def render(element_html: str, data: pl.QuestionData) -> str:\n    if data[\"panel\"] != \"question\":\n        return \"\"\n    element = lxml.html.fragment_fromstring(element_html)\n    uuid = pl.get_uuid()\n    raw_file_names = pl.get_string_attrib(element, \"file-names\", \"\")\n    file_names = sorted(get_file_names_as_array(raw_file_names))\n    file_names_json = json.dumps(file_names, allow_nan=False)\n    answer_name = get_answer_name(raw_file_names)\n    # Only send the file names to the client. We don't include the contents",
        "detail": "src.prairielearn.elements.pl-file-upload.pl-file-upload",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-file-upload.pl-file-upload",
        "description": "src.prairielearn.elements.pl-file-upload.pl-file-upload",
        "peekOfCode": "def parse(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    raw_file_names = pl.get_string_attrib(element, \"file-names\", \"\")\n    required_file_names = get_file_names_as_array(raw_file_names)\n    answer_name = get_answer_name(raw_file_names)\n    # Get submitted answer or return parse_error if it does not exist\n    files = data[\"submitted_answers\"].get(answer_name, None)\n    if not files:\n        add_format_error(data, \"No submitted answer for file upload.\")\n        return",
        "detail": "src.prairielearn.elements.pl-file-upload.pl-file-upload",
        "documentation": {}
    },
    {
        "label": "graphviz_from_networkx",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-graph.pl-graph",
        "description": "src.prairielearn.elements.pl-graph.pl-graph",
        "peekOfCode": "def graphviz_from_networkx(\n    element: lxml.html.HtmlElement, data: pl.QuestionData\n) -> str:\n    input_param_name = pl.get_string_attrib(element, \"params-name\")\n    networkx_graph = pl.from_json(data[\"params\"][input_param_name])\n    G = nx.nx_agraph.to_agraph(networkx_graph)\n    return G.string()\ndef graphviz_from_adj_matrix(\n    element: lxml.html.HtmlElement, data: pl.QuestionData\n) -> str:",
        "detail": "src.prairielearn.elements.pl-graph.pl-graph",
        "documentation": {}
    },
    {
        "label": "graphviz_from_adj_matrix",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-graph.pl-graph",
        "description": "src.prairielearn.elements.pl-graph.pl-graph",
        "peekOfCode": "def graphviz_from_adj_matrix(\n    element: lxml.html.HtmlElement, data: pl.QuestionData\n) -> str:\n    # Legacy input with passthrough\n    input_param_matrix = pl.get_string_attrib(\n        element, \"params-name-matrix\", PARAMS_NAME_DEFAULT\n    )\n    input_param_name = pl.get_string_attrib(element, \"params-name\", input_param_matrix)\n    # Exception to make typechecker happy.\n    if input_param_name is None:",
        "detail": "src.prairielearn.elements.pl-graph.pl-graph",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-graph.pl-graph",
        "description": "src.prairielearn.elements.pl-graph.pl-graph",
        "peekOfCode": "def prepare(element_html: str, data: pl.QuestionData) -> None:\n    optional_attribs = [\n        \"directed\",\n        \"engine\",\n        \"params-name-matrix\",\n        \"params-name\",\n        \"weights\",\n        \"weights-digits\",\n        \"weights-presentation-type\",\n        \"params-name-labels\",",
        "detail": "src.prairielearn.elements.pl-graph.pl-graph",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-graph.pl-graph",
        "description": "src.prairielearn.elements.pl-graph.pl-graph",
        "peekOfCode": "def render(element_html: str, data: pl.QuestionData) -> str:\n    matrix_backends = {\n        \"adjacency-matrix\": graphviz_from_adj_matrix,\n        \"networkx\": graphviz_from_networkx,\n    }\n    # Load all extensions\n    extensions = pl.load_all_extensions(data)\n    for extension in extensions.values():\n        matrix_backends.update(extension.backends)\n    # Get attribs",
        "detail": "src.prairielearn.elements.pl-graph.pl-graph",
        "documentation": {}
    },
    {
        "label": "ENGINE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-graph.pl-graph",
        "description": "src.prairielearn.elements.pl-graph.pl-graph",
        "peekOfCode": "ENGINE_DEFAULT = \"dot\"\n# Legacy default\nPARAMS_NAME_MATRIX_DEFAULT = None\nPARAMS_NAME_DEFAULT = None\nPARAMS_NAME_LABELS_DEFAULT = None\nPARAMS_TYPE_DEFAULT = \"adjacency-matrix\"\nWEIGHTS_DEFAULT = None\nWEIGHTS_DIGITS_DEFAULT = 2\nWEIGHTS_PRESENTATION_TYPE_DEFAULT = \"f\"\nNEGATIVE_WEIGHTS_DEFAULT = False",
        "detail": "src.prairielearn.elements.pl-graph.pl-graph",
        "documentation": {}
    },
    {
        "label": "PARAMS_NAME_MATRIX_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-graph.pl-graph",
        "description": "src.prairielearn.elements.pl-graph.pl-graph",
        "peekOfCode": "PARAMS_NAME_MATRIX_DEFAULT = None\nPARAMS_NAME_DEFAULT = None\nPARAMS_NAME_LABELS_DEFAULT = None\nPARAMS_TYPE_DEFAULT = \"adjacency-matrix\"\nWEIGHTS_DEFAULT = None\nWEIGHTS_DIGITS_DEFAULT = 2\nWEIGHTS_PRESENTATION_TYPE_DEFAULT = \"f\"\nNEGATIVE_WEIGHTS_DEFAULT = False\nDIRECTED_DEFAULT = True\nLOG_WARNINGS_DEFAULT = True",
        "detail": "src.prairielearn.elements.pl-graph.pl-graph",
        "documentation": {}
    },
    {
        "label": "PARAMS_NAME_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-graph.pl-graph",
        "description": "src.prairielearn.elements.pl-graph.pl-graph",
        "peekOfCode": "PARAMS_NAME_DEFAULT = None\nPARAMS_NAME_LABELS_DEFAULT = None\nPARAMS_TYPE_DEFAULT = \"adjacency-matrix\"\nWEIGHTS_DEFAULT = None\nWEIGHTS_DIGITS_DEFAULT = 2\nWEIGHTS_PRESENTATION_TYPE_DEFAULT = \"f\"\nNEGATIVE_WEIGHTS_DEFAULT = False\nDIRECTED_DEFAULT = True\nLOG_WARNINGS_DEFAULT = True\ndef graphviz_from_networkx(",
        "detail": "src.prairielearn.elements.pl-graph.pl-graph",
        "documentation": {}
    },
    {
        "label": "PARAMS_NAME_LABELS_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-graph.pl-graph",
        "description": "src.prairielearn.elements.pl-graph.pl-graph",
        "peekOfCode": "PARAMS_NAME_LABELS_DEFAULT = None\nPARAMS_TYPE_DEFAULT = \"adjacency-matrix\"\nWEIGHTS_DEFAULT = None\nWEIGHTS_DIGITS_DEFAULT = 2\nWEIGHTS_PRESENTATION_TYPE_DEFAULT = \"f\"\nNEGATIVE_WEIGHTS_DEFAULT = False\nDIRECTED_DEFAULT = True\nLOG_WARNINGS_DEFAULT = True\ndef graphviz_from_networkx(\n    element: lxml.html.HtmlElement, data: pl.QuestionData",
        "detail": "src.prairielearn.elements.pl-graph.pl-graph",
        "documentation": {}
    },
    {
        "label": "PARAMS_TYPE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-graph.pl-graph",
        "description": "src.prairielearn.elements.pl-graph.pl-graph",
        "peekOfCode": "PARAMS_TYPE_DEFAULT = \"adjacency-matrix\"\nWEIGHTS_DEFAULT = None\nWEIGHTS_DIGITS_DEFAULT = 2\nWEIGHTS_PRESENTATION_TYPE_DEFAULT = \"f\"\nNEGATIVE_WEIGHTS_DEFAULT = False\nDIRECTED_DEFAULT = True\nLOG_WARNINGS_DEFAULT = True\ndef graphviz_from_networkx(\n    element: lxml.html.HtmlElement, data: pl.QuestionData\n) -> str:",
        "detail": "src.prairielearn.elements.pl-graph.pl-graph",
        "documentation": {}
    },
    {
        "label": "WEIGHTS_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-graph.pl-graph",
        "description": "src.prairielearn.elements.pl-graph.pl-graph",
        "peekOfCode": "WEIGHTS_DEFAULT = None\nWEIGHTS_DIGITS_DEFAULT = 2\nWEIGHTS_PRESENTATION_TYPE_DEFAULT = \"f\"\nNEGATIVE_WEIGHTS_DEFAULT = False\nDIRECTED_DEFAULT = True\nLOG_WARNINGS_DEFAULT = True\ndef graphviz_from_networkx(\n    element: lxml.html.HtmlElement, data: pl.QuestionData\n) -> str:\n    input_param_name = pl.get_string_attrib(element, \"params-name\")",
        "detail": "src.prairielearn.elements.pl-graph.pl-graph",
        "documentation": {}
    },
    {
        "label": "WEIGHTS_DIGITS_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-graph.pl-graph",
        "description": "src.prairielearn.elements.pl-graph.pl-graph",
        "peekOfCode": "WEIGHTS_DIGITS_DEFAULT = 2\nWEIGHTS_PRESENTATION_TYPE_DEFAULT = \"f\"\nNEGATIVE_WEIGHTS_DEFAULT = False\nDIRECTED_DEFAULT = True\nLOG_WARNINGS_DEFAULT = True\ndef graphviz_from_networkx(\n    element: lxml.html.HtmlElement, data: pl.QuestionData\n) -> str:\n    input_param_name = pl.get_string_attrib(element, \"params-name\")\n    networkx_graph = pl.from_json(data[\"params\"][input_param_name])",
        "detail": "src.prairielearn.elements.pl-graph.pl-graph",
        "documentation": {}
    },
    {
        "label": "WEIGHTS_PRESENTATION_TYPE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-graph.pl-graph",
        "description": "src.prairielearn.elements.pl-graph.pl-graph",
        "peekOfCode": "WEIGHTS_PRESENTATION_TYPE_DEFAULT = \"f\"\nNEGATIVE_WEIGHTS_DEFAULT = False\nDIRECTED_DEFAULT = True\nLOG_WARNINGS_DEFAULT = True\ndef graphviz_from_networkx(\n    element: lxml.html.HtmlElement, data: pl.QuestionData\n) -> str:\n    input_param_name = pl.get_string_attrib(element, \"params-name\")\n    networkx_graph = pl.from_json(data[\"params\"][input_param_name])\n    G = nx.nx_agraph.to_agraph(networkx_graph)",
        "detail": "src.prairielearn.elements.pl-graph.pl-graph",
        "documentation": {}
    },
    {
        "label": "NEGATIVE_WEIGHTS_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-graph.pl-graph",
        "description": "src.prairielearn.elements.pl-graph.pl-graph",
        "peekOfCode": "NEGATIVE_WEIGHTS_DEFAULT = False\nDIRECTED_DEFAULT = True\nLOG_WARNINGS_DEFAULT = True\ndef graphviz_from_networkx(\n    element: lxml.html.HtmlElement, data: pl.QuestionData\n) -> str:\n    input_param_name = pl.get_string_attrib(element, \"params-name\")\n    networkx_graph = pl.from_json(data[\"params\"][input_param_name])\n    G = nx.nx_agraph.to_agraph(networkx_graph)\n    return G.string()",
        "detail": "src.prairielearn.elements.pl-graph.pl-graph",
        "documentation": {}
    },
    {
        "label": "DIRECTED_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-graph.pl-graph",
        "description": "src.prairielearn.elements.pl-graph.pl-graph",
        "peekOfCode": "DIRECTED_DEFAULT = True\nLOG_WARNINGS_DEFAULT = True\ndef graphviz_from_networkx(\n    element: lxml.html.HtmlElement, data: pl.QuestionData\n) -> str:\n    input_param_name = pl.get_string_attrib(element, \"params-name\")\n    networkx_graph = pl.from_json(data[\"params\"][input_param_name])\n    G = nx.nx_agraph.to_agraph(networkx_graph)\n    return G.string()\ndef graphviz_from_adj_matrix(",
        "detail": "src.prairielearn.elements.pl-graph.pl-graph",
        "documentation": {}
    },
    {
        "label": "LOG_WARNINGS_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-graph.pl-graph",
        "description": "src.prairielearn.elements.pl-graph.pl-graph",
        "peekOfCode": "LOG_WARNINGS_DEFAULT = True\ndef graphviz_from_networkx(\n    element: lxml.html.HtmlElement, data: pl.QuestionData\n) -> str:\n    input_param_name = pl.get_string_attrib(element, \"params-name\")\n    networkx_graph = pl.from_json(data[\"params\"][input_param_name])\n    G = nx.nx_agraph.to_agraph(networkx_graph)\n    return G.string()\ndef graphviz_from_adj_matrix(\n    element: lxml.html.HtmlElement, data: pl.QuestionData",
        "detail": "src.prairielearn.elements.pl-graph.pl-graph",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-hidden-hints.pl-hidden-hints",
        "description": "src.prairielearn.elements.pl-hidden-hints.pl-hidden-hints",
        "peekOfCode": "def render(element_html: str, data: pl.QuestionData) -> str:\n    element = lxml.html.fragment_fromstring(element_html)\n    pl.check_attribs(element, [], [])\n    # Parse hints from frontend\n    hints: list[tuple[int, int, Optional[str], str]] = []\n    # Use position so that hints appear in order if show-after-submission values are equal.\n    for position, child in enumerate(element):\n        if child.tag == \"pl-hint\":\n            pl.check_attribs(child, [], [\"show-after-submission\", \"hint-name\"])\n            # Default show-after-submission to -1 to automatically show hint (closed) at start",
        "detail": "src.prairielearn.elements.pl-hidden-hints.pl-hidden-hints",
        "documentation": {}
    },
    {
        "label": "PRIORITY_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-hidden-hints.pl-hidden-hints",
        "description": "src.prairielearn.elements.pl-hidden-hints.pl-hidden-hints",
        "peekOfCode": "PRIORITY_DEFAULT = -1\nHINT_NAME_DEFAULT = None\ndef render(element_html: str, data: pl.QuestionData) -> str:\n    element = lxml.html.fragment_fromstring(element_html)\n    pl.check_attribs(element, [], [])\n    # Parse hints from frontend\n    hints: list[tuple[int, int, Optional[str], str]] = []\n    # Use position so that hints appear in order if show-after-submission values are equal.\n    for position, child in enumerate(element):\n        if child.tag == \"pl-hint\":",
        "detail": "src.prairielearn.elements.pl-hidden-hints.pl-hidden-hints",
        "documentation": {}
    },
    {
        "label": "HINT_NAME_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-hidden-hints.pl-hidden-hints",
        "description": "src.prairielearn.elements.pl-hidden-hints.pl-hidden-hints",
        "peekOfCode": "HINT_NAME_DEFAULT = None\ndef render(element_html: str, data: pl.QuestionData) -> str:\n    element = lxml.html.fragment_fromstring(element_html)\n    pl.check_attribs(element, [], [])\n    # Parse hints from frontend\n    hints: list[tuple[int, int, Optional[str], str]] = []\n    # Use position so that hints appear in order if show-after-submission values are equal.\n    for position, child in enumerate(element):\n        if child.tag == \"pl-hint\":\n            pl.check_attribs(child, [], [\"show-after-submission\", \"hint-name\"])",
        "detail": "src.prairielearn.elements.pl-hidden-hints.pl-hidden-hints",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-hide-in-manual-grading.pl-hide-in-manual-grading",
        "description": "src.prairielearn.elements.pl-hide-in-manual-grading.pl-hide-in-manual-grading",
        "peekOfCode": "def prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    pl.check_attribs(element, [], [])\ndef render(element_html: str, data: pl.QuestionData) -> str:\n    if not data[\"manual_grading\"]:\n        element = lxml.html.fragment_fromstring(element_html)\n        return pl.inner_html(element)\n    return \"\"",
        "detail": "src.prairielearn.elements.pl-hide-in-manual-grading.pl-hide-in-manual-grading",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-hide-in-manual-grading.pl-hide-in-manual-grading",
        "description": "src.prairielearn.elements.pl-hide-in-manual-grading.pl-hide-in-manual-grading",
        "peekOfCode": "def render(element_html: str, data: pl.QuestionData) -> str:\n    if not data[\"manual_grading\"]:\n        element = lxml.html.fragment_fromstring(element_html)\n        return pl.inner_html(element)\n    return \"\"",
        "detail": "src.prairielearn.elements.pl-hide-in-manual-grading.pl-hide-in-manual-grading",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-hide-in-panel.pl-hide-in-panel",
        "description": "src.prairielearn.elements.pl-hide-in-panel.pl-hide-in-panel",
        "peekOfCode": "def prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = []\n    optional_attribs = [\"question\", \"submission\", \"answer\"]\n    pl.check_attribs(element, required_attribs, optional_attribs)\ndef render(element_html: str, data: pl.QuestionData) -> str:\n    element = lxml.html.fragment_fromstring(element_html)\n    hide_in_question = pl.get_boolean_attrib(element, \"question\", QUESTION_DEFAULT)\n    hide_in_submission = pl.get_boolean_attrib(\n        element, \"submission\", SUBMISSION_DEFAULT",
        "detail": "src.prairielearn.elements.pl-hide-in-panel.pl-hide-in-panel",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-hide-in-panel.pl-hide-in-panel",
        "description": "src.prairielearn.elements.pl-hide-in-panel.pl-hide-in-panel",
        "peekOfCode": "def render(element_html: str, data: pl.QuestionData) -> str:\n    element = lxml.html.fragment_fromstring(element_html)\n    hide_in_question = pl.get_boolean_attrib(element, \"question\", QUESTION_DEFAULT)\n    hide_in_submission = pl.get_boolean_attrib(\n        element, \"submission\", SUBMISSION_DEFAULT\n    )\n    hide_in_answer = pl.get_boolean_attrib(element, \"answer\", ANSWER_DEFAULT)\n    if (\n        (data[\"panel\"] == \"question\" and not hide_in_question)\n        or (data[\"panel\"] == \"submission\" and not hide_in_submission)",
        "detail": "src.prairielearn.elements.pl-hide-in-panel.pl-hide-in-panel",
        "documentation": {}
    },
    {
        "label": "QUESTION_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-hide-in-panel.pl-hide-in-panel",
        "description": "src.prairielearn.elements.pl-hide-in-panel.pl-hide-in-panel",
        "peekOfCode": "QUESTION_DEFAULT = False\nSUBMISSION_DEFAULT = False\nANSWER_DEFAULT = False\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = []\n    optional_attribs = [\"question\", \"submission\", \"answer\"]\n    pl.check_attribs(element, required_attribs, optional_attribs)\ndef render(element_html: str, data: pl.QuestionData) -> str:\n    element = lxml.html.fragment_fromstring(element_html)",
        "detail": "src.prairielearn.elements.pl-hide-in-panel.pl-hide-in-panel",
        "documentation": {}
    },
    {
        "label": "SUBMISSION_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-hide-in-panel.pl-hide-in-panel",
        "description": "src.prairielearn.elements.pl-hide-in-panel.pl-hide-in-panel",
        "peekOfCode": "SUBMISSION_DEFAULT = False\nANSWER_DEFAULT = False\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = []\n    optional_attribs = [\"question\", \"submission\", \"answer\"]\n    pl.check_attribs(element, required_attribs, optional_attribs)\ndef render(element_html: str, data: pl.QuestionData) -> str:\n    element = lxml.html.fragment_fromstring(element_html)\n    hide_in_question = pl.get_boolean_attrib(element, \"question\", QUESTION_DEFAULT)",
        "detail": "src.prairielearn.elements.pl-hide-in-panel.pl-hide-in-panel",
        "documentation": {}
    },
    {
        "label": "ANSWER_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-hide-in-panel.pl-hide-in-panel",
        "description": "src.prairielearn.elements.pl-hide-in-panel.pl-hide-in-panel",
        "peekOfCode": "ANSWER_DEFAULT = False\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = []\n    optional_attribs = [\"question\", \"submission\", \"answer\"]\n    pl.check_attribs(element, required_attribs, optional_attribs)\ndef render(element_html: str, data: pl.QuestionData) -> str:\n    element = lxml.html.fragment_fromstring(element_html)\n    hide_in_question = pl.get_boolean_attrib(element, \"question\", QUESTION_DEFAULT)\n    hide_in_submission = pl.get_boolean_attrib(",
        "detail": "src.prairielearn.elements.pl-hide-in-panel.pl-hide-in-panel",
        "documentation": {}
    },
    {
        "label": "DisplayType",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "description": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "peekOfCode": "class DisplayType(Enum):\n    INLINE = \"inline\"\n    BLOCK = \"block\"\nWEIGHT_DEFAULT = 1\nCORRECT_ANSWER_DEFAULT = None\nLABEL_DEFAULT = None\nSUFFIX_DEFAULT = None\nDISPLAY_DEFAULT = DisplayType.INLINE\nSIZE_DEFAULT = 35\nSHOW_HELP_TEXT_DEFAULT = True",
        "detail": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "description": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "peekOfCode": "def prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",\n        \"correct-answer\",\n        \"label\",\n        \"suffix\",\n        \"display\",\n        \"size\",",
        "detail": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "description": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "peekOfCode": "def render(element_html: str, data: pl.QuestionData) -> str:\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    label = pl.get_string_attrib(element, \"label\", LABEL_DEFAULT)\n    suffix = pl.get_string_attrib(element, \"suffix\", SUFFIX_DEFAULT)\n    display = pl.get_enum_attrib(element, \"display\", DisplayType, DISPLAY_DEFAULT)\n    size = pl.get_integer_attrib(element, \"size\", SIZE_DEFAULT)\n    base = pl.get_integer_attrib(element, \"base\", BASE_DEFAULT)\n    show_info = pl.get_boolean_attrib(element, \"show-help-text\", SHOW_HELP_TEXT_DEFAULT)\n    show_score = pl.get_boolean_attrib(element, \"show-score\", SHOW_SCORE_DEFAULT)",
        "detail": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "description": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "peekOfCode": "def parse(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    base = pl.get_integer_attrib(element, \"base\", BASE_DEFAULT)\n    # Get submitted answer or return parse_error if it does not exist\n    a_sub = data[\"submitted_answers\"].get(name)\n    if a_sub is None:\n        data[\"format_errors\"][name] = \"No submitted answer.\"\n        data[\"submitted_answers\"][name] = None\n        return",
        "detail": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "documentation": {}
    },
    {
        "label": "grade",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "description": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "peekOfCode": "def grade(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    base = pl.get_integer_attrib(element, \"base\", BASE_DEFAULT)\n    # Get weight\n    weight = pl.get_integer_attrib(element, \"weight\", WEIGHT_DEFAULT)\n    # Get true answer (if it does not exist, create no grade - leave it\n    # up to the question code)\n    a_tru = pl.from_json(data[\"correct_answers\"].get(name))\n    if a_tru is None:",
        "detail": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "description": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "peekOfCode": "def test(element_html: str, data: pl.ElementTestData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    weight = pl.get_integer_attrib(element, \"weight\", WEIGHT_DEFAULT)\n    base = pl.get_integer_attrib(element, \"base\", BASE_DEFAULT)\n    # Get correct answer\n    a_tru = data[\"correct_answers\"][name]\n    # If correct answer is in a format generated by pl.to_json, convert it\n    # back to a standard type (otherwise, do nothing)\n    a_tru_parsed = pl.from_json(a_tru)",
        "detail": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "documentation": {}
    },
    {
        "label": "WEIGHT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "description": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "peekOfCode": "WEIGHT_DEFAULT = 1\nCORRECT_ANSWER_DEFAULT = None\nLABEL_DEFAULT = None\nSUFFIX_DEFAULT = None\nDISPLAY_DEFAULT = DisplayType.INLINE\nSIZE_DEFAULT = 35\nSHOW_HELP_TEXT_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = 0\nBASE_DEFAULT = 10",
        "detail": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "documentation": {}
    },
    {
        "label": "CORRECT_ANSWER_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "description": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "peekOfCode": "CORRECT_ANSWER_DEFAULT = None\nLABEL_DEFAULT = None\nSUFFIX_DEFAULT = None\nDISPLAY_DEFAULT = DisplayType.INLINE\nSIZE_DEFAULT = 35\nSHOW_HELP_TEXT_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = 0\nBASE_DEFAULT = 10\nSHOW_SCORE_DEFAULT = True",
        "detail": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "documentation": {}
    },
    {
        "label": "LABEL_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "description": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "peekOfCode": "LABEL_DEFAULT = None\nSUFFIX_DEFAULT = None\nDISPLAY_DEFAULT = DisplayType.INLINE\nSIZE_DEFAULT = 35\nSHOW_HELP_TEXT_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = 0\nBASE_DEFAULT = 10\nSHOW_SCORE_DEFAULT = True\n# Get the absolute path of the current module",
        "detail": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "documentation": {}
    },
    {
        "label": "SUFFIX_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "description": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "peekOfCode": "SUFFIX_DEFAULT = None\nDISPLAY_DEFAULT = DisplayType.INLINE\nSIZE_DEFAULT = 35\nSHOW_HELP_TEXT_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = 0\nBASE_DEFAULT = 10\nSHOW_SCORE_DEFAULT = True\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)",
        "detail": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "documentation": {}
    },
    {
        "label": "DISPLAY_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "description": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "peekOfCode": "DISPLAY_DEFAULT = DisplayType.INLINE\nSIZE_DEFAULT = 35\nSHOW_HELP_TEXT_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = 0\nBASE_DEFAULT = 10\nSHOW_SCORE_DEFAULT = True\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module",
        "detail": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "documentation": {}
    },
    {
        "label": "SIZE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "description": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "peekOfCode": "SIZE_DEFAULT = 35\nSHOW_HELP_TEXT_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = 0\nBASE_DEFAULT = 10\nSHOW_SCORE_DEFAULT = True\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)",
        "detail": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "documentation": {}
    },
    {
        "label": "SHOW_HELP_TEXT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "description": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "peekOfCode": "SHOW_HELP_TEXT_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = 0\nBASE_DEFAULT = 10\nSHOW_SCORE_DEFAULT = True\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)\nINTEGER_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir,\"pl-integer-input.mustache\")",
        "detail": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "documentation": {}
    },
    {
        "label": "ALLOW_BLANK_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "description": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "peekOfCode": "ALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = 0\nBASE_DEFAULT = 10\nSHOW_SCORE_DEFAULT = True\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)\nINTEGER_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir,\"pl-integer-input.mustache\")\ndef prepare(element_html: str, data: pl.QuestionData) -> None:",
        "detail": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "documentation": {}
    },
    {
        "label": "BLANK_VALUE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "description": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "peekOfCode": "BLANK_VALUE_DEFAULT = 0\nBASE_DEFAULT = 10\nSHOW_SCORE_DEFAULT = True\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)\nINTEGER_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir,\"pl-integer-input.mustache\")\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)",
        "detail": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "documentation": {}
    },
    {
        "label": "BASE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "description": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "peekOfCode": "BASE_DEFAULT = 10\nSHOW_SCORE_DEFAULT = True\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)\nINTEGER_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir,\"pl-integer-input.mustache\")\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]",
        "detail": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "documentation": {}
    },
    {
        "label": "SHOW_SCORE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "description": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "peekOfCode": "SHOW_SCORE_DEFAULT = True\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)\nINTEGER_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir,\"pl-integer-input.mustache\")\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [",
        "detail": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "documentation": {}
    },
    {
        "label": "current_module_path",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "description": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "peekOfCode": "current_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)\nINTEGER_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir,\"pl-integer-input.mustache\")\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",\n        \"correct-answer\",",
        "detail": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "documentation": {}
    },
    {
        "label": "current_module_dir",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "description": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "peekOfCode": "current_module_dir = os.path.dirname(current_module_path)\nINTEGER_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir,\"pl-integer-input.mustache\")\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",\n        \"correct-answer\",\n        \"label\",\n        \"suffix\",",
        "detail": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "documentation": {}
    },
    {
        "label": "INTEGER_INPUT_MUSTACHE_TEMPLATE_NAME",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "description": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "peekOfCode": "INTEGER_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir,\"pl-integer-input.mustache\")\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",\n        \"correct-answer\",\n        \"label\",\n        \"suffix\",\n        \"display\",",
        "detail": "src.prairielearn.elements.pl-integer-input.pl-integer-input",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-manual-grading-only.pl-manual-grading-only",
        "description": "src.prairielearn.elements.pl-manual-grading-only.pl-manual-grading-only",
        "peekOfCode": "def prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    pl.check_attribs(element, [], [])\ndef render(element_html: str, data: pl.QuestionData) -> str:\n    if data[\"manual_grading\"]:\n        element = lxml.html.fragment_fromstring(element_html)\n        return pl.inner_html(element)\n    return \"\"",
        "detail": "src.prairielearn.elements.pl-manual-grading-only.pl-manual-grading-only",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-manual-grading-only.pl-manual-grading-only",
        "description": "src.prairielearn.elements.pl-manual-grading-only.pl-manual-grading-only",
        "peekOfCode": "def render(element_html: str, data: pl.QuestionData) -> str:\n    if data[\"manual_grading\"]:\n        element = lxml.html.fragment_fromstring(element_html)\n        return pl.inner_html(element)\n    return \"\"",
        "detail": "src.prairielearn.elements.pl-manual-grading-only.pl-manual-grading-only",
        "documentation": {}
    },
    {
        "label": "OptionsPlacementType",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-matching.pl-matching",
        "description": "src.prairielearn.elements.pl-matching.pl-matching",
        "peekOfCode": "class OptionsPlacementType(Enum):\n    RIGHT = \"right\"\n    BOTTOM = \"bottom\"\ndef get_form_name(answers_name, index):\n    return f\"{answers_name}-dropdown-{index}\"\ndef get_counter(i, counter_type):\n    \"\"\"Converts an integer counter to the specified CSS counter type\"\"\"\n    if counter_type == \"lower-alpha\":\n        return pl.index2key(i - 1)\n    elif counter_type == \"upper-alpha\":",
        "detail": "src.prairielearn.elements.pl-matching.pl-matching",
        "documentation": {}
    },
    {
        "label": "get_form_name",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-matching.pl-matching",
        "description": "src.prairielearn.elements.pl-matching.pl-matching",
        "peekOfCode": "def get_form_name(answers_name, index):\n    return f\"{answers_name}-dropdown-{index}\"\ndef get_counter(i, counter_type):\n    \"\"\"Converts an integer counter to the specified CSS counter type\"\"\"\n    if counter_type == \"lower-alpha\":\n        return pl.index2key(i - 1)\n    elif counter_type == \"upper-alpha\":\n        return pl.index2key(i - 1).upper()\n    elif counter_type == \"decimal\":\n        return str(i)",
        "detail": "src.prairielearn.elements.pl-matching.pl-matching",
        "documentation": {}
    },
    {
        "label": "get_counter",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-matching.pl-matching",
        "description": "src.prairielearn.elements.pl-matching.pl-matching",
        "peekOfCode": "def get_counter(i, counter_type):\n    \"\"\"Converts an integer counter to the specified CSS counter type\"\"\"\n    if counter_type == \"lower-alpha\":\n        return pl.index2key(i - 1)\n    elif counter_type == \"upper-alpha\":\n        return pl.index2key(i - 1).upper()\n    elif counter_type == \"decimal\":\n        return str(i)\n    elif counter_type == \"full-text\":\n        return \"\"",
        "detail": "src.prairielearn.elements.pl-matching.pl-matching",
        "documentation": {}
    },
    {
        "label": "legal_answer",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-matching.pl-matching",
        "description": "src.prairielearn.elements.pl-matching.pl-matching",
        "peekOfCode": "def legal_answer(answer, options):\n    \"\"\"Checks that the given answer is within the range of the given counter type.\"\"\"\n    return -1 <= answer < len(options)\ndef get_select_options(options_list, selected_value, blank_used):\n    def transform(i, opt):\n        index = i - int(blank_used)\n        return {\n            \"index\": index,\n            \"value\": opt,\n            \"selected\": \"selected\" if index == selected_value else \"\",",
        "detail": "src.prairielearn.elements.pl-matching.pl-matching",
        "documentation": {}
    },
    {
        "label": "get_select_options",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-matching.pl-matching",
        "description": "src.prairielearn.elements.pl-matching.pl-matching",
        "peekOfCode": "def get_select_options(options_list, selected_value, blank_used):\n    def transform(i, opt):\n        index = i - int(blank_used)\n        return {\n            \"index\": index,\n            \"value\": opt,\n            \"selected\": \"selected\" if index == selected_value else \"\",\n        }\n    return [transform(i, opt) for i, opt in enumerate(options_list)]\ndef partition(data, pred):",
        "detail": "src.prairielearn.elements.pl-matching.pl-matching",
        "documentation": {}
    },
    {
        "label": "partition",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-matching.pl-matching",
        "description": "src.prairielearn.elements.pl-matching.pl-matching",
        "peekOfCode": "def partition(data, pred):\n    \"\"\"Implements a partition function, splitting the data into two lists based on the predicate.\"\"\"\n    yes, no = [], []\n    for d in data:\n        if pred(d):\n            yes.append(d)\n        else:\n            no.append(d)\n    return (yes, no)\ndef categorize_matches(element, data):",
        "detail": "src.prairielearn.elements.pl-matching.pl-matching",
        "documentation": {}
    },
    {
        "label": "categorize_matches",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-matching.pl-matching",
        "description": "src.prairielearn.elements.pl-matching.pl-matching",
        "peekOfCode": "def categorize_matches(element, data):\n    \"\"\"Get provided statements and options from the pl-matching element\"\"\"\n    options = {}\n    statements = []\n    index = 0\n    # Sort the elements so that pl-options come first.\n    children = element[:]\n    children.sort(key=lambda child: child.tag)\n    def make_option(name, html):\n        nonlocal index",
        "detail": "src.prairielearn.elements.pl-matching.pl-matching",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-matching.pl-matching",
        "description": "src.prairielearn.elements.pl-matching.pl-matching",
        "peekOfCode": "def prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",\n        \"fixed-order\",\n        \"number-statements\",\n        \"number-options\",\n        \"none-of-the-above\",\n        \"blank\",",
        "detail": "src.prairielearn.elements.pl-matching.pl-matching",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-matching.pl-matching",
        "description": "src.prairielearn.elements.pl-matching.pl-matching",
        "peekOfCode": "def parse(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    allow_blank = pl.get_boolean_attrib(element, \"allow-blank\", ALLOW_BLANK_DEFAULT)\n    display_statements, display_options = data[\"params\"].get(name)\n    submitted_answers = data[\"submitted_answers\"]\n    for i in range(len(display_statements)):\n        expected_html_name = get_form_name(name, i)\n        try:\n            student_answer = int(submitted_answers.get(expected_html_name, None))",
        "detail": "src.prairielearn.elements.pl-matching.pl-matching",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-matching.pl-matching",
        "description": "src.prairielearn.elements.pl-matching.pl-matching",
        "peekOfCode": "def render(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    display_statements, display_options = data[\"params\"].get(name, ([], []))\n    options_placement = pl.get_enum_attrib(\n        element, \"options-placement\", OptionsPlacementType, OptionsPlacementType.RIGHT\n    )\n    submitted_answers = data[\"submitted_answers\"]\n    counter_type = pl.get_string_attrib(element, \"counter-type\", COUNTER_TYPE_DEFAULT)\n    hide_score_badge = pl.get_boolean_attrib(",
        "detail": "src.prairielearn.elements.pl-matching.pl-matching",
        "documentation": {}
    },
    {
        "label": "grade",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-matching.pl-matching",
        "description": "src.prairielearn.elements.pl-matching.pl-matching",
        "peekOfCode": "def grade(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    weight = pl.get_integer_attrib(element, \"weight\", WEIGHT_DEFAULT)\n    partial_credit = pl.get_boolean_attrib(\n        element, \"partial-credit\", PARTIAL_CREDIT_DEFAULT\n    )\n    display_statements, _ = data[\"params\"][name]\n    number_statements = len(display_statements)\n    submitted_answers = data[\"submitted_answers\"]",
        "detail": "src.prairielearn.elements.pl-matching.pl-matching",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-matching.pl-matching",
        "description": "src.prairielearn.elements.pl-matching.pl-matching",
        "peekOfCode": "def test(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    weight = pl.get_integer_attrib(element, \"weight\", WEIGHT_DEFAULT)\n    _, display_options = data[\"params\"][name]\n    correct_answers = data[\"correct_answers\"].get(name, [])\n    result = data[\"test_type\"]\n    if result == \"correct\":\n        for i in range(len(correct_answers)):\n            expected_html_name = get_form_name(name, i)",
        "detail": "src.prairielearn.elements.pl-matching.pl-matching",
        "documentation": {}
    },
    {
        "label": "WEIGHT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matching.pl-matching",
        "description": "src.prairielearn.elements.pl-matching.pl-matching",
        "peekOfCode": "WEIGHT_DEFAULT = 1\nFIXED_STATEMENTS_ORDER_DEFAULT = False\nFIXED_OPTIONS_ORDER_DEFAULT = False\nINLINE_DEFAULT = False\nPARTIAL_CREDIT_DEFAULT = True\nHIDE_ANSWER_PANEL_DEFAULT = False\nHIDE_HELP_TEXT_DEFAULT = False\nDETAILED_HELP_TEXT_DEFAULT = False\nHIDE_SCORE_BADGE_DEFAULT = False\nALLOW_BLANK_DEFAULT = False",
        "detail": "src.prairielearn.elements.pl-matching.pl-matching",
        "documentation": {}
    },
    {
        "label": "FIXED_STATEMENTS_ORDER_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matching.pl-matching",
        "description": "src.prairielearn.elements.pl-matching.pl-matching",
        "peekOfCode": "FIXED_STATEMENTS_ORDER_DEFAULT = False\nFIXED_OPTIONS_ORDER_DEFAULT = False\nINLINE_DEFAULT = False\nPARTIAL_CREDIT_DEFAULT = True\nHIDE_ANSWER_PANEL_DEFAULT = False\nHIDE_HELP_TEXT_DEFAULT = False\nDETAILED_HELP_TEXT_DEFAULT = False\nHIDE_SCORE_BADGE_DEFAULT = False\nALLOW_BLANK_DEFAULT = False\nBLANK_DEFAULT = True",
        "detail": "src.prairielearn.elements.pl-matching.pl-matching",
        "documentation": {}
    },
    {
        "label": "FIXED_OPTIONS_ORDER_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matching.pl-matching",
        "description": "src.prairielearn.elements.pl-matching.pl-matching",
        "peekOfCode": "FIXED_OPTIONS_ORDER_DEFAULT = False\nINLINE_DEFAULT = False\nPARTIAL_CREDIT_DEFAULT = True\nHIDE_ANSWER_PANEL_DEFAULT = False\nHIDE_HELP_TEXT_DEFAULT = False\nDETAILED_HELP_TEXT_DEFAULT = False\nHIDE_SCORE_BADGE_DEFAULT = False\nALLOW_BLANK_DEFAULT = False\nBLANK_DEFAULT = True\nBLANK_ANSWER = \" \"",
        "detail": "src.prairielearn.elements.pl-matching.pl-matching",
        "documentation": {}
    },
    {
        "label": "INLINE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matching.pl-matching",
        "description": "src.prairielearn.elements.pl-matching.pl-matching",
        "peekOfCode": "INLINE_DEFAULT = False\nPARTIAL_CREDIT_DEFAULT = True\nHIDE_ANSWER_PANEL_DEFAULT = False\nHIDE_HELP_TEXT_DEFAULT = False\nDETAILED_HELP_TEXT_DEFAULT = False\nHIDE_SCORE_BADGE_DEFAULT = False\nALLOW_BLANK_DEFAULT = False\nBLANK_DEFAULT = True\nBLANK_ANSWER = \" \"\nNOTA_DEFAULT = False",
        "detail": "src.prairielearn.elements.pl-matching.pl-matching",
        "documentation": {}
    },
    {
        "label": "PARTIAL_CREDIT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matching.pl-matching",
        "description": "src.prairielearn.elements.pl-matching.pl-matching",
        "peekOfCode": "PARTIAL_CREDIT_DEFAULT = True\nHIDE_ANSWER_PANEL_DEFAULT = False\nHIDE_HELP_TEXT_DEFAULT = False\nDETAILED_HELP_TEXT_DEFAULT = False\nHIDE_SCORE_BADGE_DEFAULT = False\nALLOW_BLANK_DEFAULT = False\nBLANK_DEFAULT = True\nBLANK_ANSWER = \" \"\nNOTA_DEFAULT = False\nCOUNTER_TYPE_DEFAULT = \"lower-alpha\"",
        "detail": "src.prairielearn.elements.pl-matching.pl-matching",
        "documentation": {}
    },
    {
        "label": "HIDE_ANSWER_PANEL_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matching.pl-matching",
        "description": "src.prairielearn.elements.pl-matching.pl-matching",
        "peekOfCode": "HIDE_ANSWER_PANEL_DEFAULT = False\nHIDE_HELP_TEXT_DEFAULT = False\nDETAILED_HELP_TEXT_DEFAULT = False\nHIDE_SCORE_BADGE_DEFAULT = False\nALLOW_BLANK_DEFAULT = False\nBLANK_DEFAULT = True\nBLANK_ANSWER = \" \"\nNOTA_DEFAULT = False\nCOUNTER_TYPE_DEFAULT = \"lower-alpha\"\n# Get the absolute path of the current module",
        "detail": "src.prairielearn.elements.pl-matching.pl-matching",
        "documentation": {}
    },
    {
        "label": "HIDE_HELP_TEXT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matching.pl-matching",
        "description": "src.prairielearn.elements.pl-matching.pl-matching",
        "peekOfCode": "HIDE_HELP_TEXT_DEFAULT = False\nDETAILED_HELP_TEXT_DEFAULT = False\nHIDE_SCORE_BADGE_DEFAULT = False\nALLOW_BLANK_DEFAULT = False\nBLANK_DEFAULT = True\nBLANK_ANSWER = \" \"\nNOTA_DEFAULT = False\nCOUNTER_TYPE_DEFAULT = \"lower-alpha\"\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)",
        "detail": "src.prairielearn.elements.pl-matching.pl-matching",
        "documentation": {}
    },
    {
        "label": "DETAILED_HELP_TEXT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matching.pl-matching",
        "description": "src.prairielearn.elements.pl-matching.pl-matching",
        "peekOfCode": "DETAILED_HELP_TEXT_DEFAULT = False\nHIDE_SCORE_BADGE_DEFAULT = False\nALLOW_BLANK_DEFAULT = False\nBLANK_DEFAULT = True\nBLANK_ANSWER = \" \"\nNOTA_DEFAULT = False\nCOUNTER_TYPE_DEFAULT = \"lower-alpha\"\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module",
        "detail": "src.prairielearn.elements.pl-matching.pl-matching",
        "documentation": {}
    },
    {
        "label": "HIDE_SCORE_BADGE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matching.pl-matching",
        "description": "src.prairielearn.elements.pl-matching.pl-matching",
        "peekOfCode": "HIDE_SCORE_BADGE_DEFAULT = False\nALLOW_BLANK_DEFAULT = False\nBLANK_DEFAULT = True\nBLANK_ANSWER = \" \"\nNOTA_DEFAULT = False\nCOUNTER_TYPE_DEFAULT = \"lower-alpha\"\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)",
        "detail": "src.prairielearn.elements.pl-matching.pl-matching",
        "documentation": {}
    },
    {
        "label": "ALLOW_BLANK_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matching.pl-matching",
        "description": "src.prairielearn.elements.pl-matching.pl-matching",
        "peekOfCode": "ALLOW_BLANK_DEFAULT = False\nBLANK_DEFAULT = True\nBLANK_ANSWER = \" \"\nNOTA_DEFAULT = False\nCOUNTER_TYPE_DEFAULT = \"lower-alpha\"\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)\nMATCHING_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_path,\"pl-matching.mustache\")",
        "detail": "src.prairielearn.elements.pl-matching.pl-matching",
        "documentation": {}
    },
    {
        "label": "BLANK_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matching.pl-matching",
        "description": "src.prairielearn.elements.pl-matching.pl-matching",
        "peekOfCode": "BLANK_DEFAULT = True\nBLANK_ANSWER = \" \"\nNOTA_DEFAULT = False\nCOUNTER_TYPE_DEFAULT = \"lower-alpha\"\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)\nMATCHING_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_path,\"pl-matching.mustache\")\nclass OptionsPlacementType(Enum):",
        "detail": "src.prairielearn.elements.pl-matching.pl-matching",
        "documentation": {}
    },
    {
        "label": "BLANK_ANSWER",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matching.pl-matching",
        "description": "src.prairielearn.elements.pl-matching.pl-matching",
        "peekOfCode": "BLANK_ANSWER = \" \"\nNOTA_DEFAULT = False\nCOUNTER_TYPE_DEFAULT = \"lower-alpha\"\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)\nMATCHING_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_path,\"pl-matching.mustache\")\nclass OptionsPlacementType(Enum):\n    RIGHT = \"right\"",
        "detail": "src.prairielearn.elements.pl-matching.pl-matching",
        "documentation": {}
    },
    {
        "label": "NOTA_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matching.pl-matching",
        "description": "src.prairielearn.elements.pl-matching.pl-matching",
        "peekOfCode": "NOTA_DEFAULT = False\nCOUNTER_TYPE_DEFAULT = \"lower-alpha\"\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)\nMATCHING_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_path,\"pl-matching.mustache\")\nclass OptionsPlacementType(Enum):\n    RIGHT = \"right\"\n    BOTTOM = \"bottom\"",
        "detail": "src.prairielearn.elements.pl-matching.pl-matching",
        "documentation": {}
    },
    {
        "label": "COUNTER_TYPE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matching.pl-matching",
        "description": "src.prairielearn.elements.pl-matching.pl-matching",
        "peekOfCode": "COUNTER_TYPE_DEFAULT = \"lower-alpha\"\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)\nMATCHING_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_path,\"pl-matching.mustache\")\nclass OptionsPlacementType(Enum):\n    RIGHT = \"right\"\n    BOTTOM = \"bottom\"\ndef get_form_name(answers_name, index):",
        "detail": "src.prairielearn.elements.pl-matching.pl-matching",
        "documentation": {}
    },
    {
        "label": "current_module_path",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matching.pl-matching",
        "description": "src.prairielearn.elements.pl-matching.pl-matching",
        "peekOfCode": "current_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)\nMATCHING_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_path,\"pl-matching.mustache\")\nclass OptionsPlacementType(Enum):\n    RIGHT = \"right\"\n    BOTTOM = \"bottom\"\ndef get_form_name(answers_name, index):\n    return f\"{answers_name}-dropdown-{index}\"\ndef get_counter(i, counter_type):",
        "detail": "src.prairielearn.elements.pl-matching.pl-matching",
        "documentation": {}
    },
    {
        "label": "current_module_dir",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matching.pl-matching",
        "description": "src.prairielearn.elements.pl-matching.pl-matching",
        "peekOfCode": "current_module_dir = os.path.dirname(current_module_path)\nMATCHING_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_path,\"pl-matching.mustache\")\nclass OptionsPlacementType(Enum):\n    RIGHT = \"right\"\n    BOTTOM = \"bottom\"\ndef get_form_name(answers_name, index):\n    return f\"{answers_name}-dropdown-{index}\"\ndef get_counter(i, counter_type):\n    \"\"\"Converts an integer counter to the specified CSS counter type\"\"\"\n    if counter_type == \"lower-alpha\":",
        "detail": "src.prairielearn.elements.pl-matching.pl-matching",
        "documentation": {}
    },
    {
        "label": "MATCHING_INPUT_MUSTACHE_TEMPLATE_NAME",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matching.pl-matching",
        "description": "src.prairielearn.elements.pl-matching.pl-matching",
        "peekOfCode": "MATCHING_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_path,\"pl-matching.mustache\")\nclass OptionsPlacementType(Enum):\n    RIGHT = \"right\"\n    BOTTOM = \"bottom\"\ndef get_form_name(answers_name, index):\n    return f\"{answers_name}-dropdown-{index}\"\ndef get_counter(i, counter_type):\n    \"\"\"Converts an integer counter to the specified CSS counter type\"\"\"\n    if counter_type == \"lower-alpha\":\n        return pl.index2key(i - 1)",
        "detail": "src.prairielearn.elements.pl-matching.pl-matching",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "description": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "peekOfCode": "def prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",\n        \"label\",\n        \"comparison\",\n        \"rtol\",\n        \"atol\",\n        \"digits\",",
        "detail": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "description": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "peekOfCode": "def render(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    # get the name of the element, in this case, the name of the array\n    name = pl.get_string_attrib(element, \"answers-name\")\n    label = pl.get_string_attrib(element, \"label\", LABEL_DEFAULT)\n    allow_partial_credit = pl.get_boolean_attrib(\n        element, \"allow-partial-credit\", ALLOW_PARTIAL_CREDIT_DEFAULT\n    )\n    allow_feedback = pl.get_boolean_attrib(\n        element, \"allow-feedback\", allow_partial_credit",
        "detail": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "description": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "peekOfCode": "def parse(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    allow_fractions = pl.get_boolean_attrib(\n        element, \"allow-fractions\", ALLOW_FRACTIONS_DEFAULT\n    )\n    allow_blank = pl.get_boolean_attrib(element, \"allow-blank\", ALLOW_BLANK_DEFAULT)\n    blank_value = pl.get_string_attrib(element, \"blank-value\", str(BLANK_VALUE_DEFAULT))\n    # Get dimensions of the input matrix\n    a_tru = pl.from_json(data[\"correct_answers\"].get(name, None))",
        "detail": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "documentation": {}
    },
    {
        "label": "grade",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "description": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "peekOfCode": "def grade(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    allow_partial_credit = pl.get_boolean_attrib(\n        element, \"allow-partial-credit\", ALLOW_PARTIAL_CREDIT_DEFAULT\n    )\n    # Get weight\n    weight = pl.get_integer_attrib(element, \"weight\", WEIGHT_DEFAULT)\n    # Get method of comparison, with relabs as default\n    comparison = pl.get_string_attrib(element, \"comparison\", COMPARISON_DEFAULT)",
        "detail": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "description": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "peekOfCode": "def test(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    weight = pl.get_integer_attrib(element, \"weight\", WEIGHT_DEFAULT)\n    allow_partial_credit = pl.get_boolean_attrib(\n        element, \"allow-partial-credit\", ALLOW_PARTIAL_CREDIT_DEFAULT\n    )\n    # Get correct answer\n    a_tru = data[\"correct_answers\"][name]\n    # If correct answer is in a format generated by pl.to_json, convert it",
        "detail": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "documentation": {}
    },
    {
        "label": "createTableForHTMLDisplay",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "description": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "peekOfCode": "def createTableForHTMLDisplay(m, n, name, label, data, format):\n    editable = data[\"editable\"]\n    if format == \"output-invalid\":\n        display_array = \"<table>\"\n        display_array += \"<tr>\"\n        display_array += (\n            '<td class=\"pl-matrix-component-input-close-left\" rowspan=\"'\n            + str(m)\n            + '\"></td>'\n        )",
        "detail": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "documentation": {}
    },
    {
        "label": "WEIGHT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "description": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "peekOfCode": "WEIGHT_DEFAULT = 1\nLABEL_DEFAULT = None\nCOMPARISON_DEFAULT = \"relabs\"\nRTOL_DEFAULT = 1e-2\nATOL_DEFAULT = 1e-8\nDIGITS_DEFAULT = 2\nALLOW_PARTIAL_CREDIT_DEFAULT = False\nALLOW_FRACTIONS_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = 0",
        "detail": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "documentation": {}
    },
    {
        "label": "LABEL_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "description": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "peekOfCode": "LABEL_DEFAULT = None\nCOMPARISON_DEFAULT = \"relabs\"\nRTOL_DEFAULT = 1e-2\nATOL_DEFAULT = 1e-8\nDIGITS_DEFAULT = 2\nALLOW_PARTIAL_CREDIT_DEFAULT = False\nALLOW_FRACTIONS_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = 0\n# Get the absolute path of the current module",
        "detail": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "documentation": {}
    },
    {
        "label": "COMPARISON_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "description": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "peekOfCode": "COMPARISON_DEFAULT = \"relabs\"\nRTOL_DEFAULT = 1e-2\nATOL_DEFAULT = 1e-8\nDIGITS_DEFAULT = 2\nALLOW_PARTIAL_CREDIT_DEFAULT = False\nALLOW_FRACTIONS_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = 0\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)",
        "detail": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "documentation": {}
    },
    {
        "label": "RTOL_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "description": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "peekOfCode": "RTOL_DEFAULT = 1e-2\nATOL_DEFAULT = 1e-8\nDIGITS_DEFAULT = 2\nALLOW_PARTIAL_CREDIT_DEFAULT = False\nALLOW_FRACTIONS_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = 0\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module",
        "detail": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "documentation": {}
    },
    {
        "label": "ATOL_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "description": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "peekOfCode": "ATOL_DEFAULT = 1e-8\nDIGITS_DEFAULT = 2\nALLOW_PARTIAL_CREDIT_DEFAULT = False\nALLOW_FRACTIONS_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = 0\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)",
        "detail": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "documentation": {}
    },
    {
        "label": "DIGITS_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "description": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "peekOfCode": "DIGITS_DEFAULT = 2\nALLOW_PARTIAL_CREDIT_DEFAULT = False\nALLOW_FRACTIONS_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = 0\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)\nMATRIX_COMP_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir,\"pl-matrix-component-input.mustache\")",
        "detail": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "documentation": {}
    },
    {
        "label": "ALLOW_PARTIAL_CREDIT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "description": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "peekOfCode": "ALLOW_PARTIAL_CREDIT_DEFAULT = False\nALLOW_FRACTIONS_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = 0\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)\nMATRIX_COMP_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir,\"pl-matrix-component-input.mustache\")\ndef prepare(element_html, data):",
        "detail": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "documentation": {}
    },
    {
        "label": "ALLOW_FRACTIONS_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "description": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "peekOfCode": "ALLOW_FRACTIONS_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = 0\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)\nMATRIX_COMP_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir,\"pl-matrix-component-input.mustache\")\ndef prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)",
        "detail": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "documentation": {}
    },
    {
        "label": "ALLOW_BLANK_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "description": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "peekOfCode": "ALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = 0\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)\nMATRIX_COMP_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir,\"pl-matrix-component-input.mustache\")\ndef prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]",
        "detail": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "documentation": {}
    },
    {
        "label": "BLANK_VALUE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "description": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "peekOfCode": "BLANK_VALUE_DEFAULT = 0\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)\nMATRIX_COMP_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir,\"pl-matrix-component-input.mustache\")\ndef prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [",
        "detail": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "documentation": {}
    },
    {
        "label": "current_module_path",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "description": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "peekOfCode": "current_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)\nMATRIX_COMP_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir,\"pl-matrix-component-input.mustache\")\ndef prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",\n        \"label\",",
        "detail": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "documentation": {}
    },
    {
        "label": "current_module_dir",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "description": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "peekOfCode": "current_module_dir = os.path.dirname(current_module_path)\nMATRIX_COMP_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir,\"pl-matrix-component-input.mustache\")\ndef prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",\n        \"label\",\n        \"comparison\",\n        \"rtol\",",
        "detail": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "documentation": {}
    },
    {
        "label": "MATRIX_COMP_INPUT_MUSTACHE_TEMPLATE_NAME",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "description": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "peekOfCode": "MATRIX_COMP_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir,\"pl-matrix-component-input.mustache\")\ndef prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",\n        \"label\",\n        \"comparison\",\n        \"rtol\",\n        \"atol\",",
        "detail": "src.prairielearn.elements.pl-matrix-component-input.pl-matrix-component-input",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "description": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "peekOfCode": "def prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",\n        \"label\",\n        \"comparison\",\n        \"rtol\",\n        \"atol\",\n        \"digits\",",
        "detail": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "description": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "peekOfCode": "def render(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    label = pl.get_string_attrib(element, \"label\", LABEL_DEFAULT)\n    if \"_pl_matrix_input_format\" in data[\"submitted_answers\"]:\n        format_type = data[\"submitted_answers\"][\"_pl_matrix_input_format\"].get(\n            name, \"matlab\"\n        )\n    else:\n        format_type = \"matlab\"",
        "detail": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "documentation": {}
    },
    {
        "label": "get_format_string",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "description": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "peekOfCode": "def get_format_string(message):\n    params = {\"format_error\": True, \"format_error_message\": message}\n    with open(MATRIX_INPUT_MUSTACHE_TEMPLATE_NAME, \"r\", encoding=\"utf-8\") as f:\n        return chevron.render(f, params).strip()\ndef parse(element_html, data):\n    # By convention, this function returns at the first error found\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    allow_complex = pl.get_boolean_attrib(\n        element, \"allow-complex\", ALLOW_COMPLEX_DEFAULT",
        "detail": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "description": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "peekOfCode": "def parse(element_html, data):\n    # By convention, this function returns at the first error found\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    allow_complex = pl.get_boolean_attrib(\n        element, \"allow-complex\", ALLOW_COMPLEX_DEFAULT\n    )\n    # Get submitted answer or return parse_error if it does not exist\n    a_sub = data[\"submitted_answers\"].get(name, None)\n    if a_sub is None:",
        "detail": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "documentation": {}
    },
    {
        "label": "grade",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "description": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "peekOfCode": "def grade(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    # Get weight\n    weight = pl.get_integer_attrib(element, \"weight\", WEIGHT_DEFAULT)\n    # Get true answer (if it does not exist, create no grade - leave it\n    # up to the question code)\n    a_tru = pl.from_json(data[\"correct_answers\"].get(name, None))\n    if a_tru is None:\n        return",
        "detail": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "description": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "peekOfCode": "def test(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    weight = pl.get_integer_attrib(element, \"weight\", WEIGHT_DEFAULT)\n    # Get correct answer\n    a_tru = data[\"correct_answers\"][name]\n    # If correct answer is in a format generated by pl.to_json, convert it\n    # back to a standard type (otherwise, do nothing)\n    a_tru = pl.from_json(a_tru)\n    # Wrap true answer in ndarray (if it already is one, this does nothing)",
        "detail": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "documentation": {}
    },
    {
        "label": "WEIGHT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "description": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "peekOfCode": "WEIGHT_DEFAULT = 1\nLABEL_DEFAULT = None\nCOMPARISON_DEFAULT = \"relabs\"\nRTOL_DEFAULT = 1e-2\nATOL_DEFAULT = 1e-8\nDIGITS_DEFAULT = 2\nALLOW_COMPLEX_DEFAULT = False\nSHOW_HELP_TEXT_DEFAULT = True\ncurrent_module_path = os.path.abspath(__file__)\nprint(current_module_path)",
        "detail": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "documentation": {}
    },
    {
        "label": "LABEL_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "description": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "peekOfCode": "LABEL_DEFAULT = None\nCOMPARISON_DEFAULT = \"relabs\"\nRTOL_DEFAULT = 1e-2\nATOL_DEFAULT = 1e-8\nDIGITS_DEFAULT = 2\nALLOW_COMPLEX_DEFAULT = False\nSHOW_HELP_TEXT_DEFAULT = True\ncurrent_module_path = os.path.abspath(__file__)\nprint(current_module_path)\nMATRIX_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_path,\"..\",\"pl-matrix-input.mustache\")",
        "detail": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "documentation": {}
    },
    {
        "label": "COMPARISON_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "description": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "peekOfCode": "COMPARISON_DEFAULT = \"relabs\"\nRTOL_DEFAULT = 1e-2\nATOL_DEFAULT = 1e-8\nDIGITS_DEFAULT = 2\nALLOW_COMPLEX_DEFAULT = False\nSHOW_HELP_TEXT_DEFAULT = True\ncurrent_module_path = os.path.abspath(__file__)\nprint(current_module_path)\nMATRIX_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_path,\"..\",\"pl-matrix-input.mustache\")\ndef prepare(element_html, data):",
        "detail": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "documentation": {}
    },
    {
        "label": "RTOL_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "description": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "peekOfCode": "RTOL_DEFAULT = 1e-2\nATOL_DEFAULT = 1e-8\nDIGITS_DEFAULT = 2\nALLOW_COMPLEX_DEFAULT = False\nSHOW_HELP_TEXT_DEFAULT = True\ncurrent_module_path = os.path.abspath(__file__)\nprint(current_module_path)\nMATRIX_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_path,\"..\",\"pl-matrix-input.mustache\")\ndef prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)",
        "detail": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "documentation": {}
    },
    {
        "label": "ATOL_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "description": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "peekOfCode": "ATOL_DEFAULT = 1e-8\nDIGITS_DEFAULT = 2\nALLOW_COMPLEX_DEFAULT = False\nSHOW_HELP_TEXT_DEFAULT = True\ncurrent_module_path = os.path.abspath(__file__)\nprint(current_module_path)\nMATRIX_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_path,\"..\",\"pl-matrix-input.mustache\")\ndef prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]",
        "detail": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "documentation": {}
    },
    {
        "label": "DIGITS_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "description": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "peekOfCode": "DIGITS_DEFAULT = 2\nALLOW_COMPLEX_DEFAULT = False\nSHOW_HELP_TEXT_DEFAULT = True\ncurrent_module_path = os.path.abspath(__file__)\nprint(current_module_path)\nMATRIX_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_path,\"..\",\"pl-matrix-input.mustache\")\ndef prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [",
        "detail": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "documentation": {}
    },
    {
        "label": "ALLOW_COMPLEX_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "description": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "peekOfCode": "ALLOW_COMPLEX_DEFAULT = False\nSHOW_HELP_TEXT_DEFAULT = True\ncurrent_module_path = os.path.abspath(__file__)\nprint(current_module_path)\nMATRIX_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_path,\"..\",\"pl-matrix-input.mustache\")\ndef prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",",
        "detail": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "documentation": {}
    },
    {
        "label": "SHOW_HELP_TEXT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "description": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "peekOfCode": "SHOW_HELP_TEXT_DEFAULT = True\ncurrent_module_path = os.path.abspath(__file__)\nprint(current_module_path)\nMATRIX_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_path,\"..\",\"pl-matrix-input.mustache\")\ndef prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",\n        \"label\",",
        "detail": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "documentation": {}
    },
    {
        "label": "current_module_path",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "description": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "peekOfCode": "current_module_path = os.path.abspath(__file__)\nprint(current_module_path)\nMATRIX_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_path,\"..\",\"pl-matrix-input.mustache\")\ndef prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",\n        \"label\",\n        \"comparison\",",
        "detail": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "documentation": {}
    },
    {
        "label": "MATRIX_INPUT_MUSTACHE_TEMPLATE_NAME",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "description": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "peekOfCode": "MATRIX_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_path,\"..\",\"pl-matrix-input.mustache\")\ndef prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",\n        \"label\",\n        \"comparison\",\n        \"rtol\",\n        \"atol\",",
        "detail": "src.prairielearn.elements.pl-matrix-input.pl-matrix-input",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-matrix-latex.pl-matrix-latex",
        "description": "src.prairielearn.elements.pl-matrix-latex.pl-matrix-latex",
        "peekOfCode": "def prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"params-name\"]\n    optional_attribs = [\"digits\", \"presentation-type\"]\n    pl.check_attribs(element, required_attribs, optional_attribs)\ndef render(element_html: str, data: pl.QuestionData) -> str:\n    element = lxml.html.fragment_fromstring(element_html)\n    # Get the number of digits to output\n    digits = pl.get_integer_attrib(element, \"digits\", DIGITS_DEFAULT)\n    # Get the presentation type",
        "detail": "src.prairielearn.elements.pl-matrix-latex.pl-matrix-latex",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-matrix-latex.pl-matrix-latex",
        "description": "src.prairielearn.elements.pl-matrix-latex.pl-matrix-latex",
        "peekOfCode": "def render(element_html: str, data: pl.QuestionData) -> str:\n    element = lxml.html.fragment_fromstring(element_html)\n    # Get the number of digits to output\n    digits = pl.get_integer_attrib(element, \"digits\", DIGITS_DEFAULT)\n    # Get the presentation type\n    presentation_type = pl.get_string_attrib(\n        element, \"presentation-type\", PRESENTATION_TYPE_DEFAULT\n    )\n    var_name = pl.get_string_attrib(element, \"params-name\")\n    # Get value of variable, raising exception if variable does not exist",
        "detail": "src.prairielearn.elements.pl-matrix-latex.pl-matrix-latex",
        "documentation": {}
    },
    {
        "label": "DIGITS_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matrix-latex.pl-matrix-latex",
        "description": "src.prairielearn.elements.pl-matrix-latex.pl-matrix-latex",
        "peekOfCode": "DIGITS_DEFAULT = 2\nPRESENTATION_TYPE_DEFAULT = \"f\"\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"params-name\"]\n    optional_attribs = [\"digits\", \"presentation-type\"]\n    pl.check_attribs(element, required_attribs, optional_attribs)\ndef render(element_html: str, data: pl.QuestionData) -> str:\n    element = lxml.html.fragment_fromstring(element_html)\n    # Get the number of digits to output",
        "detail": "src.prairielearn.elements.pl-matrix-latex.pl-matrix-latex",
        "documentation": {}
    },
    {
        "label": "PRESENTATION_TYPE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matrix-latex.pl-matrix-latex",
        "description": "src.prairielearn.elements.pl-matrix-latex.pl-matrix-latex",
        "peekOfCode": "PRESENTATION_TYPE_DEFAULT = \"f\"\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"params-name\"]\n    optional_attribs = [\"digits\", \"presentation-type\"]\n    pl.check_attribs(element, required_attribs, optional_attribs)\ndef render(element_html: str, data: pl.QuestionData) -> str:\n    element = lxml.html.fragment_fromstring(element_html)\n    # Get the number of digits to output\n    digits = pl.get_integer_attrib(element, \"digits\", DIGITS_DEFAULT)",
        "detail": "src.prairielearn.elements.pl-matrix-latex.pl-matrix-latex",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-matrix-output.pl-matrix-output",
        "description": "src.prairielearn.elements.pl-matrix-output.pl-matrix-output",
        "peekOfCode": "def prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    pl.check_attribs(element, required_attribs=[], optional_attribs=[\"digits\"])\ndef render(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    digits = pl.get_integer_attrib(element, \"digits\", DIGITS_DEFAULT)\n    matlab_data = \"\"\n    python_data = \"import numpy as np\\n\\n\"\n    for child in element:\n        if child.tag == \"variable\":",
        "detail": "src.prairielearn.elements.pl-matrix-output.pl-matrix-output",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-matrix-output.pl-matrix-output",
        "description": "src.prairielearn.elements.pl-matrix-output.pl-matrix-output",
        "peekOfCode": "def render(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    digits = pl.get_integer_attrib(element, \"digits\", DIGITS_DEFAULT)\n    matlab_data = \"\"\n    python_data = \"import numpy as np\\n\\n\"\n    for child in element:\n        if child.tag == \"variable\":\n            # Raise exception of variable does not have a name\n            pl.check_attribs(\n                child, required_attribs=[\"params-name\"], optional_attribs=[]",
        "detail": "src.prairielearn.elements.pl-matrix-output.pl-matrix-output",
        "documentation": {}
    },
    {
        "label": "DIGITS_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-matrix-output.pl-matrix-output",
        "description": "src.prairielearn.elements.pl-matrix-output.pl-matrix-output",
        "peekOfCode": "DIGITS_DEFAULT = 2\ndef prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    pl.check_attribs(element, required_attribs=[], optional_attribs=[\"digits\"])\ndef render(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    digits = pl.get_integer_attrib(element, \"digits\", DIGITS_DEFAULT)\n    matlab_data = \"\"\n    python_data = \"import numpy as np\\n\\n\"\n    for child in element:",
        "detail": "src.prairielearn.elements.pl-matrix-output.pl-matrix-output",
        "documentation": {}
    },
    {
        "label": "DisplayType",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "description": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "peekOfCode": "class DisplayType(Enum):\n    INLINE = \"inline\"\n    BLOCK = \"block\"\n    DROPDOWN = \"dropdown\"\nclass AotaNotaType(Enum):\n    FALSE = 1\n    RANDOM = 2\n    INCORRECT = 3\n    CORRECT = 4\nclass OrderType(Enum):",
        "detail": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "documentation": {}
    },
    {
        "label": "AotaNotaType",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "description": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "peekOfCode": "class AotaNotaType(Enum):\n    FALSE = 1\n    RANDOM = 2\n    INCORRECT = 3\n    CORRECT = 4\nclass OrderType(Enum):\n    RANDOM = \"random\"\n    ASCEND = \"ascend\"\n    DESCEND = \"descend\"\n    FIXED = \"fixed\"",
        "detail": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "documentation": {}
    },
    {
        "label": "OrderType",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "description": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "peekOfCode": "class OrderType(Enum):\n    RANDOM = \"random\"\n    ASCEND = \"ascend\"\n    DESCEND = \"descend\"\n    FIXED = \"fixed\"\nclass AnswerTuple(NamedTuple):\n    idx: int\n    correct: bool\n    html: str\n    feedback: Optional[str]",
        "detail": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "documentation": {}
    },
    {
        "label": "AnswerTuple",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "description": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "peekOfCode": "class AnswerTuple(NamedTuple):\n    idx: int\n    correct: bool\n    html: str\n    feedback: Optional[str]\n    score: float\nSCORE_INCORRECT_DEFAULT = 0.0\nSCORE_CORRECT_DEFAULT = 1.0\nWEIGHT_DEFAULT = 1\nFIXED_ORDER_DEFAULT = False",
        "detail": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "documentation": {}
    },
    {
        "label": "categorize_options",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "description": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "peekOfCode": "def categorize_options(\n    element: lxml.html.HtmlElement, data: pl.QuestionData\n) -> tuple[list[AnswerTuple], list[AnswerTuple]]:\n    \"\"\"Get provided correct and incorrect answers\"\"\"\n    correct_answers = []\n    incorrect_answers = []\n    index_counter = it.count(0)\n    # First, check internal HTML for answer choices\n    for child in element:\n        if child.tag in {\"pl-answer\", \"pl_answer\"}:",
        "detail": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "documentation": {}
    },
    {
        "label": "get_nota_aota_attrib",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "description": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "peekOfCode": "def get_nota_aota_attrib(\n    element: lxml.html.HtmlElement, name: str, default: AotaNotaType\n) -> AotaNotaType:\n    \"\"\"\n    NOTA and AOTA used to be boolean values, but are changed to\n    special strings. To ensure backwards compatibility, values\n    interpreted as true or false are assumed to be older\n    interpretations. If the value cannot be interpreted as boolean,\n    the string representation is used.\n    \"\"\"",
        "detail": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "documentation": {}
    },
    {
        "label": "get_order_type",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "description": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "peekOfCode": "def get_order_type(element: lxml.html.HtmlElement) -> OrderType:\n    \"\"\"Gets order type in a backwards-compatible way. New display overwrites old.\"\"\"\n    if pl.has_attrib(element, \"fixed-order\") and pl.has_attrib(element, \"order\"):\n        raise ValueError(\n            'Setting answer choice order should be done with the \"order\" attribute.'\n        )\n    fixed_order = pl.get_boolean_attrib(element, \"fixed-order\", FIXED_ORDER_DEFAULT)\n    order_type_default = OrderType.FIXED if fixed_order else OrderType.RANDOM\n    return pl.get_enum_attrib(element, \"order\", OrderType, order_type_default)\ndef get_display_type(element: lxml.html.HtmlElement) -> DisplayType:",
        "detail": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "documentation": {}
    },
    {
        "label": "get_display_type",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "description": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "peekOfCode": "def get_display_type(element: lxml.html.HtmlElement) -> DisplayType:\n    \"\"\"Gets display type in a backwards-compatible way. New display overwrites old.\"\"\"\n    if pl.has_attrib(element, \"inline\") and pl.has_attrib(element, \"display\"):\n        raise ValueError(\n            'Setting answer choice display should be done with the \"display\" attribute.'\n        )\n    inline = pl.get_boolean_attrib(element, \"inline\", INLINE_DEFAULT)\n    display_default = DisplayType.INLINE if inline else DisplayType.BLOCK\n    return pl.get_enum_attrib(element, \"display\", DisplayType, display_default)\ndef prepare_answers_to_display(",
        "detail": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "documentation": {}
    },
    {
        "label": "prepare_answers_to_display",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "description": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "peekOfCode": "def prepare_answers_to_display(\n    correct_answers: list[AnswerTuple],\n    incorrect_answers: list[AnswerTuple],\n    *,\n    number_answers: Optional[int],\n    aota: AotaNotaType,\n    nota: AotaNotaType,\n    aota_feedback: Optional[str],\n    nota_feedback: Optional[str],\n    order_type: OrderType,",
        "detail": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "description": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "peekOfCode": "def prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",\n        \"number-answers\",\n        \"fixed-order\",\n        \"inline\",\n        \"hide-letter-keys\",\n        \"none-of-the-above\",",
        "detail": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "description": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "peekOfCode": "def render(element_html: str, data: pl.QuestionData) -> str:\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    hide_score_badge = pl.get_boolean_attrib(\n        element, \"hide-score-badge\", HIDE_SCORE_BADGE_DEFAULT\n    )\n    answers = data[\"params\"].get(name, [])\n    display_type = get_display_type(element)\n    inline = display_type is not DisplayType.BLOCK\n    display_radio = display_type in {DisplayType.BLOCK, DisplayType.INLINE}",
        "detail": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "description": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "peekOfCode": "def parse(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    allow_blank = pl.get_boolean_attrib(element, \"allow-blank\", ALLOW_BLANK_DEFAULT)\n    submitted_key = data[\"submitted_answers\"].get(name, None)\n    all_keys = {a[\"key\"] for a in data[\"params\"][name]}\n    if not allow_blank and submitted_key is None:\n        data[\"format_errors\"][name] = \"No answer was submitted.\"\n        return\n    if submitted_key not in all_keys and submitted_key is not None:",
        "detail": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "documentation": {}
    },
    {
        "label": "grade",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "description": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "peekOfCode": "def grade(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    weight = pl.get_integer_attrib(element, \"weight\", WEIGHT_DEFAULT)\n    submitted_key = data[\"submitted_answers\"].get(name, None)\n    correct_key = data[\"correct_answers\"].get(name, {\"key\": None}).get(\"key\", None)\n    default_score = (\n        SCORE_CORRECT_DEFAULT\n        if submitted_key == correct_key\n        else SCORE_INCORRECT_DEFAULT",
        "detail": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "description": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "peekOfCode": "def test(element_html: str, data: pl.ElementTestData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    weight = pl.get_integer_attrib(element, \"weight\", WEIGHT_DEFAULT)\n    correct_key = data[\"correct_answers\"].get(name, {\"key\": None}).get(\"key\", None)\n    if correct_key is None:\n        raise ValueError(\"could not determine correct_key\")\n    number_answers = len(data[\"params\"][name])\n    all_keys = list(it.islice(pl.iter_keys(), number_answers))\n    incorrect_keys = list(set(all_keys) - {correct_key})",
        "detail": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "documentation": {}
    },
    {
        "label": "current_directory",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "description": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "peekOfCode": "current_directory = os.path.dirname(os.path.abspath(__file__))\nclass DisplayType(Enum):\n    INLINE = \"inline\"\n    BLOCK = \"block\"\n    DROPDOWN = \"dropdown\"\nclass AotaNotaType(Enum):\n    FALSE = 1\n    RANDOM = 2\n    INCORRECT = 3\n    CORRECT = 4",
        "detail": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "documentation": {}
    },
    {
        "label": "SCORE_INCORRECT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "description": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "peekOfCode": "SCORE_INCORRECT_DEFAULT = 0.0\nSCORE_CORRECT_DEFAULT = 1.0\nWEIGHT_DEFAULT = 1\nFIXED_ORDER_DEFAULT = False\nINLINE_DEFAULT = False\nNONE_OF_THE_ABOVE_DEFAULT = AotaNotaType.FALSE\nALL_OF_THE_ABOVE_DEFAULT = AotaNotaType.FALSE\nEXTERNAL_JSON_DEFAULT = None\nHIDE_LETTER_KEYS_DEFAULT = False\nEXTERNAL_JSON_CORRECT_KEY_DEFAULT = \"correct\"",
        "detail": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "documentation": {}
    },
    {
        "label": "SCORE_CORRECT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "description": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "peekOfCode": "SCORE_CORRECT_DEFAULT = 1.0\nWEIGHT_DEFAULT = 1\nFIXED_ORDER_DEFAULT = False\nINLINE_DEFAULT = False\nNONE_OF_THE_ABOVE_DEFAULT = AotaNotaType.FALSE\nALL_OF_THE_ABOVE_DEFAULT = AotaNotaType.FALSE\nEXTERNAL_JSON_DEFAULT = None\nHIDE_LETTER_KEYS_DEFAULT = False\nEXTERNAL_JSON_CORRECT_KEY_DEFAULT = \"correct\"\nEXTERNAL_JSON_INCORRECT_KEY_DEFAULT = \"incorrect\"",
        "detail": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "documentation": {}
    },
    {
        "label": "WEIGHT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "description": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "peekOfCode": "WEIGHT_DEFAULT = 1\nFIXED_ORDER_DEFAULT = False\nINLINE_DEFAULT = False\nNONE_OF_THE_ABOVE_DEFAULT = AotaNotaType.FALSE\nALL_OF_THE_ABOVE_DEFAULT = AotaNotaType.FALSE\nEXTERNAL_JSON_DEFAULT = None\nHIDE_LETTER_KEYS_DEFAULT = False\nEXTERNAL_JSON_CORRECT_KEY_DEFAULT = \"correct\"\nEXTERNAL_JSON_INCORRECT_KEY_DEFAULT = \"incorrect\"\nFEEDBACK_DEFAULT = None",
        "detail": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "documentation": {}
    },
    {
        "label": "FIXED_ORDER_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "description": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "peekOfCode": "FIXED_ORDER_DEFAULT = False\nINLINE_DEFAULT = False\nNONE_OF_THE_ABOVE_DEFAULT = AotaNotaType.FALSE\nALL_OF_THE_ABOVE_DEFAULT = AotaNotaType.FALSE\nEXTERNAL_JSON_DEFAULT = None\nHIDE_LETTER_KEYS_DEFAULT = False\nEXTERNAL_JSON_CORRECT_KEY_DEFAULT = \"correct\"\nEXTERNAL_JSON_INCORRECT_KEY_DEFAULT = \"incorrect\"\nFEEDBACK_DEFAULT = None\nHIDE_SCORE_BADGE_DEFAULT = False",
        "detail": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "documentation": {}
    },
    {
        "label": "INLINE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "description": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "peekOfCode": "INLINE_DEFAULT = False\nNONE_OF_THE_ABOVE_DEFAULT = AotaNotaType.FALSE\nALL_OF_THE_ABOVE_DEFAULT = AotaNotaType.FALSE\nEXTERNAL_JSON_DEFAULT = None\nHIDE_LETTER_KEYS_DEFAULT = False\nEXTERNAL_JSON_CORRECT_KEY_DEFAULT = \"correct\"\nEXTERNAL_JSON_INCORRECT_KEY_DEFAULT = \"incorrect\"\nFEEDBACK_DEFAULT = None\nHIDE_SCORE_BADGE_DEFAULT = False\nALLOW_BLANK_DEFAULT = False",
        "detail": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "documentation": {}
    },
    {
        "label": "NONE_OF_THE_ABOVE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "description": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "peekOfCode": "NONE_OF_THE_ABOVE_DEFAULT = AotaNotaType.FALSE\nALL_OF_THE_ABOVE_DEFAULT = AotaNotaType.FALSE\nEXTERNAL_JSON_DEFAULT = None\nHIDE_LETTER_KEYS_DEFAULT = False\nEXTERNAL_JSON_CORRECT_KEY_DEFAULT = \"correct\"\nEXTERNAL_JSON_INCORRECT_KEY_DEFAULT = \"incorrect\"\nFEEDBACK_DEFAULT = None\nHIDE_SCORE_BADGE_DEFAULT = False\nALLOW_BLANK_DEFAULT = False\nSIZE_DEFAULT = None",
        "detail": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "documentation": {}
    },
    {
        "label": "ALL_OF_THE_ABOVE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "description": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "peekOfCode": "ALL_OF_THE_ABOVE_DEFAULT = AotaNotaType.FALSE\nEXTERNAL_JSON_DEFAULT = None\nHIDE_LETTER_KEYS_DEFAULT = False\nEXTERNAL_JSON_CORRECT_KEY_DEFAULT = \"correct\"\nEXTERNAL_JSON_INCORRECT_KEY_DEFAULT = \"incorrect\"\nFEEDBACK_DEFAULT = None\nHIDE_SCORE_BADGE_DEFAULT = False\nALLOW_BLANK_DEFAULT = False\nSIZE_DEFAULT = None\nSUBMITTED_ANSWER_BLANK = {\"html\": \"No answer submitted\"}",
        "detail": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "documentation": {}
    },
    {
        "label": "EXTERNAL_JSON_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "description": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "peekOfCode": "EXTERNAL_JSON_DEFAULT = None\nHIDE_LETTER_KEYS_DEFAULT = False\nEXTERNAL_JSON_CORRECT_KEY_DEFAULT = \"correct\"\nEXTERNAL_JSON_INCORRECT_KEY_DEFAULT = \"incorrect\"\nFEEDBACK_DEFAULT = None\nHIDE_SCORE_BADGE_DEFAULT = False\nALLOW_BLANK_DEFAULT = False\nSIZE_DEFAULT = None\nSUBMITTED_ANSWER_BLANK = {\"html\": \"No answer submitted\"}\n# Get the absolute path of the current module",
        "detail": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "documentation": {}
    },
    {
        "label": "HIDE_LETTER_KEYS_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "description": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "peekOfCode": "HIDE_LETTER_KEYS_DEFAULT = False\nEXTERNAL_JSON_CORRECT_KEY_DEFAULT = \"correct\"\nEXTERNAL_JSON_INCORRECT_KEY_DEFAULT = \"incorrect\"\nFEEDBACK_DEFAULT = None\nHIDE_SCORE_BADGE_DEFAULT = False\nALLOW_BLANK_DEFAULT = False\nSIZE_DEFAULT = None\nSUBMITTED_ANSWER_BLANK = {\"html\": \"No answer submitted\"}\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)",
        "detail": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "documentation": {}
    },
    {
        "label": "EXTERNAL_JSON_CORRECT_KEY_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "description": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "peekOfCode": "EXTERNAL_JSON_CORRECT_KEY_DEFAULT = \"correct\"\nEXTERNAL_JSON_INCORRECT_KEY_DEFAULT = \"incorrect\"\nFEEDBACK_DEFAULT = None\nHIDE_SCORE_BADGE_DEFAULT = False\nALLOW_BLANK_DEFAULT = False\nSIZE_DEFAULT = None\nSUBMITTED_ANSWER_BLANK = {\"html\": \"No answer submitted\"}\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module",
        "detail": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "documentation": {}
    },
    {
        "label": "EXTERNAL_JSON_INCORRECT_KEY_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "description": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "peekOfCode": "EXTERNAL_JSON_INCORRECT_KEY_DEFAULT = \"incorrect\"\nFEEDBACK_DEFAULT = None\nHIDE_SCORE_BADGE_DEFAULT = False\nALLOW_BLANK_DEFAULT = False\nSIZE_DEFAULT = None\nSUBMITTED_ANSWER_BLANK = {\"html\": \"No answer submitted\"}\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)",
        "detail": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "documentation": {}
    },
    {
        "label": "FEEDBACK_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "description": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "peekOfCode": "FEEDBACK_DEFAULT = None\nHIDE_SCORE_BADGE_DEFAULT = False\nALLOW_BLANK_DEFAULT = False\nSIZE_DEFAULT = None\nSUBMITTED_ANSWER_BLANK = {\"html\": \"No answer submitted\"}\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)\nMULTIPLE_CHOICE_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir, \"pl-multiple-choice.mustache\")",
        "detail": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "documentation": {}
    },
    {
        "label": "HIDE_SCORE_BADGE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "description": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "peekOfCode": "HIDE_SCORE_BADGE_DEFAULT = False\nALLOW_BLANK_DEFAULT = False\nSIZE_DEFAULT = None\nSUBMITTED_ANSWER_BLANK = {\"html\": \"No answer submitted\"}\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)\nMULTIPLE_CHOICE_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir, \"pl-multiple-choice.mustache\")\ndef categorize_options(",
        "detail": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "documentation": {}
    },
    {
        "label": "ALLOW_BLANK_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "description": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "peekOfCode": "ALLOW_BLANK_DEFAULT = False\nSIZE_DEFAULT = None\nSUBMITTED_ANSWER_BLANK = {\"html\": \"No answer submitted\"}\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)\nMULTIPLE_CHOICE_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir, \"pl-multiple-choice.mustache\")\ndef categorize_options(\n    element: lxml.html.HtmlElement, data: pl.QuestionData",
        "detail": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "documentation": {}
    },
    {
        "label": "SIZE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "description": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "peekOfCode": "SIZE_DEFAULT = None\nSUBMITTED_ANSWER_BLANK = {\"html\": \"No answer submitted\"}\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)\nMULTIPLE_CHOICE_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir, \"pl-multiple-choice.mustache\")\ndef categorize_options(\n    element: lxml.html.HtmlElement, data: pl.QuestionData\n) -> tuple[list[AnswerTuple], list[AnswerTuple]]:",
        "detail": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "documentation": {}
    },
    {
        "label": "SUBMITTED_ANSWER_BLANK",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "description": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "peekOfCode": "SUBMITTED_ANSWER_BLANK = {\"html\": \"No answer submitted\"}\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)\nMULTIPLE_CHOICE_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir, \"pl-multiple-choice.mustache\")\ndef categorize_options(\n    element: lxml.html.HtmlElement, data: pl.QuestionData\n) -> tuple[list[AnswerTuple], list[AnswerTuple]]:\n    \"\"\"Get provided correct and incorrect answers\"\"\"",
        "detail": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "documentation": {}
    },
    {
        "label": "current_module_path",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "description": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "peekOfCode": "current_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)\nMULTIPLE_CHOICE_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir, \"pl-multiple-choice.mustache\")\ndef categorize_options(\n    element: lxml.html.HtmlElement, data: pl.QuestionData\n) -> tuple[list[AnswerTuple], list[AnswerTuple]]:\n    \"\"\"Get provided correct and incorrect answers\"\"\"\n    correct_answers = []\n    incorrect_answers = []",
        "detail": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "documentation": {}
    },
    {
        "label": "current_module_dir",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "description": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "peekOfCode": "current_module_dir = os.path.dirname(current_module_path)\nMULTIPLE_CHOICE_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir, \"pl-multiple-choice.mustache\")\ndef categorize_options(\n    element: lxml.html.HtmlElement, data: pl.QuestionData\n) -> tuple[list[AnswerTuple], list[AnswerTuple]]:\n    \"\"\"Get provided correct and incorrect answers\"\"\"\n    correct_answers = []\n    incorrect_answers = []\n    index_counter = it.count(0)\n    # First, check internal HTML for answer choices",
        "detail": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "documentation": {}
    },
    {
        "label": "MULTIPLE_CHOICE_MUSTACHE_TEMPLATE_NAME",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "description": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "peekOfCode": "MULTIPLE_CHOICE_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir, \"pl-multiple-choice.mustache\")\ndef categorize_options(\n    element: lxml.html.HtmlElement, data: pl.QuestionData\n) -> tuple[list[AnswerTuple], list[AnswerTuple]]:\n    \"\"\"Get provided correct and incorrect answers\"\"\"\n    correct_answers = []\n    incorrect_answers = []\n    index_counter = it.count(0)\n    # First, check internal HTML for answer choices\n    for child in element:",
        "detail": "src.prairielearn.elements.pl-multiple-choice.pl-multiple-choice",
        "documentation": {}
    },
    {
        "label": "DisplayType",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "description": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "peekOfCode": "class DisplayType(Enum):\n    INLINE = \"inline\"\n    BLOCK = \"block\"\nclass ComparisonType(Enum):\n    RELABS = \"relabs\"\n    SIGFIG = \"sigfig\"\n    DECDIG = \"decdig\"\nRTOL_DEFAULT = 1e-2\nATOL_DEFAULT = 1e-8\nSIZE_DEFAULT = 35",
        "detail": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "documentation": {}
    },
    {
        "label": "ComparisonType",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "description": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "peekOfCode": "class ComparisonType(Enum):\n    RELABS = \"relabs\"\n    SIGFIG = \"sigfig\"\n    DECDIG = \"decdig\"\nRTOL_DEFAULT = 1e-2\nATOL_DEFAULT = 1e-8\nSIZE_DEFAULT = 35\nDIGITS_DEFAULT = 2\nWEIGHT_DEFAULT = 1\nDISPLAY_DEFAULT = DisplayType.INLINE",
        "detail": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "description": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "peekOfCode": "def prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",\n        \"correct-answer\",\n        \"label\",\n        \"suffix\",\n        \"display\",\n        \"comparison\",",
        "detail": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "documentation": {}
    },
    {
        "label": "format_true_ans",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "description": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "peekOfCode": "def format_true_ans(\n    element: lxml.html.HtmlElement, data: pl.QuestionData, name: str\n) -> str:\n    correct_answer = pl.from_json(data[\"correct_answers\"].get(name, None))\n    if correct_answer is not None:\n        # Get format and comparison parameters\n        custom_format = pl.get_string_attrib(element, \"custom-format\", None)\n        comparison = pl.get_enum_attrib(\n            element, \"comparison\", ComparisonType, COMPARISON_DEFAULT\n        )",
        "detail": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "documentation": {}
    },
    {
        "label": "get_string_precision",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "description": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "peekOfCode": "def get_string_precision(number_string: str) -> float:\n    if \".\" in number_string:\n        return 10 ** -len(number_string.partition(\".\")[2])\n    return 10 ** (len(number_string) - len(number_string.rstrip(\"0\")))\ndef get_string_significant_digits(number_string: str) -> int:\n    if \".\" in number_string:\n        number_string_partition = number_string.partition(\".\")\n        integer_part = len(number_string_partition[0].lstrip(\"0\"))\n        decimal_part = len(number_string_partition[2].lstrip(\"0\"))\n        return integer_part + decimal_part",
        "detail": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "documentation": {}
    },
    {
        "label": "get_string_significant_digits",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "description": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "peekOfCode": "def get_string_significant_digits(number_string: str) -> int:\n    if \".\" in number_string:\n        number_string_partition = number_string.partition(\".\")\n        integer_part = len(number_string_partition[0].lstrip(\"0\"))\n        decimal_part = len(number_string_partition[2].lstrip(\"0\"))\n        return integer_part + decimal_part\n    return len(number_string.strip(\"0\"))\ndef get_string_decimal_digits(number_string: str) -> int:\n    if \".\" in number_string:\n        number_string_partition = number_string.partition(\".\")",
        "detail": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "documentation": {}
    },
    {
        "label": "get_string_decimal_digits",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "description": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "peekOfCode": "def get_string_decimal_digits(number_string: str) -> int:\n    if \".\" in number_string:\n        number_string_partition = number_string.partition(\".\")\n        decimal_part = len(number_string_partition[2].lstrip(\"0\"))\n        return decimal_part\n    return 0  # no decimal seperator means there are no decimal digits\ndef render(element_html: str, data: pl.QuestionData) -> str:\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    label = pl.get_string_attrib(element, \"label\", None)",
        "detail": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "description": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "peekOfCode": "def render(element_html: str, data: pl.QuestionData) -> str:\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    label = pl.get_string_attrib(element, \"label\", None)\n    suffix = pl.get_string_attrib(element, \"suffix\", None)\n    display = pl.get_enum_attrib(element, \"display\", DisplayType, DISPLAY_DEFAULT)\n    allow_fractions = pl.get_boolean_attrib(\n        element, \"allow-fractions\", ALLOW_FRACTIONS_DEFAULT\n    )\n    custom_format = pl.get_string_attrib(",
        "detail": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "documentation": {}
    },
    {
        "label": "get_format_string",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "description": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "peekOfCode": "def get_format_string(\n    is_complex: bool = False,\n    allow_fractions: bool = False,\n    message: str | None = None,\n) -> str:\n    params = {\n        \"complex\": is_complex,\n        \"format_error\": True,\n        \"allow_fractions\": allow_fractions,\n        \"format_error_message\": message,",
        "detail": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "description": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "peekOfCode": "def parse(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    allow_complex = pl.get_boolean_attrib(\n        element, \"allow-complex\", ALLOW_COMPLEX_DEFAULT\n    )\n    allow_fractions = pl.get_boolean_attrib(\n        element, \"allow-fractions\", ALLOW_FRACTIONS_DEFAULT\n    )\n    allow_blank = pl.get_boolean_attrib(element, \"allow-blank\", ALLOW_BLANK_DEFAULT)",
        "detail": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "documentation": {}
    },
    {
        "label": "grade",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "description": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "peekOfCode": "def grade(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    # Get weight\n    weight = pl.get_integer_attrib(element, \"weight\", WEIGHT_DEFAULT)\n    # Get true answer (if it does not exist, create no grade - leave it\n    # up to the question code)\n    correct_answer: Any = pl.from_json(data[\"correct_answers\"].get(name))\n    if correct_answer is None:\n        return",
        "detail": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "description": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "peekOfCode": "def test(element_html: str, data: pl.ElementTestData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    weight = pl.get_integer_attrib(element, \"weight\", WEIGHT_DEFAULT)\n    # Get correct answer\n    correct_answer = data[\"correct_answers\"][name]\n    # If correct answer is in a format generated by pl.to_json, convert it\n    # back to a standard type (otherwise, do nothing)\n    correct_answer = pl.from_json(correct_answer)\n    correct_answer_converted = np.float64(correct_answer)",
        "detail": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "documentation": {}
    },
    {
        "label": "RTOL_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "description": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "peekOfCode": "RTOL_DEFAULT = 1e-2\nATOL_DEFAULT = 1e-8\nSIZE_DEFAULT = 35\nDIGITS_DEFAULT = 2\nWEIGHT_DEFAULT = 1\nDISPLAY_DEFAULT = DisplayType.INLINE\nCOMPARISON_DEFAULT = ComparisonType.RELABS\nALLOW_COMPLEX_DEFAULT = False\nSHOW_HELP_TEXT_DEFAULT = True\nSHOW_PLACEHOLDER_DEFAULT = True",
        "detail": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "documentation": {}
    },
    {
        "label": "ATOL_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "description": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "peekOfCode": "ATOL_DEFAULT = 1e-8\nSIZE_DEFAULT = 35\nDIGITS_DEFAULT = 2\nWEIGHT_DEFAULT = 1\nDISPLAY_DEFAULT = DisplayType.INLINE\nCOMPARISON_DEFAULT = ComparisonType.RELABS\nALLOW_COMPLEX_DEFAULT = False\nSHOW_HELP_TEXT_DEFAULT = True\nSHOW_PLACEHOLDER_DEFAULT = True\nSHOW_CORRECT_ANSWER_DEFAULT = True",
        "detail": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "documentation": {}
    },
    {
        "label": "SIZE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "description": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "peekOfCode": "SIZE_DEFAULT = 35\nDIGITS_DEFAULT = 2\nWEIGHT_DEFAULT = 1\nDISPLAY_DEFAULT = DisplayType.INLINE\nCOMPARISON_DEFAULT = ComparisonType.RELABS\nALLOW_COMPLEX_DEFAULT = False\nSHOW_HELP_TEXT_DEFAULT = True\nSHOW_PLACEHOLDER_DEFAULT = True\nSHOW_CORRECT_ANSWER_DEFAULT = True\nALLOW_FRACTIONS_DEFAULT = True",
        "detail": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "documentation": {}
    },
    {
        "label": "DIGITS_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "description": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "peekOfCode": "DIGITS_DEFAULT = 2\nWEIGHT_DEFAULT = 1\nDISPLAY_DEFAULT = DisplayType.INLINE\nCOMPARISON_DEFAULT = ComparisonType.RELABS\nALLOW_COMPLEX_DEFAULT = False\nSHOW_HELP_TEXT_DEFAULT = True\nSHOW_PLACEHOLDER_DEFAULT = True\nSHOW_CORRECT_ANSWER_DEFAULT = True\nALLOW_FRACTIONS_DEFAULT = True\nALLOW_BLANK_DEFAULT = False",
        "detail": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "documentation": {}
    },
    {
        "label": "WEIGHT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "description": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "peekOfCode": "WEIGHT_DEFAULT = 1\nDISPLAY_DEFAULT = DisplayType.INLINE\nCOMPARISON_DEFAULT = ComparisonType.RELABS\nALLOW_COMPLEX_DEFAULT = False\nSHOW_HELP_TEXT_DEFAULT = True\nSHOW_PLACEHOLDER_DEFAULT = True\nSHOW_CORRECT_ANSWER_DEFAULT = True\nALLOW_FRACTIONS_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = 0",
        "detail": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "documentation": {}
    },
    {
        "label": "DISPLAY_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "description": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "peekOfCode": "DISPLAY_DEFAULT = DisplayType.INLINE\nCOMPARISON_DEFAULT = ComparisonType.RELABS\nALLOW_COMPLEX_DEFAULT = False\nSHOW_HELP_TEXT_DEFAULT = True\nSHOW_PLACEHOLDER_DEFAULT = True\nSHOW_CORRECT_ANSWER_DEFAULT = True\nALLOW_FRACTIONS_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = 0\nCUSTOM_FORMAT_DEFAULT = '.12g'",
        "detail": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "documentation": {}
    },
    {
        "label": "COMPARISON_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "description": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "peekOfCode": "COMPARISON_DEFAULT = ComparisonType.RELABS\nALLOW_COMPLEX_DEFAULT = False\nSHOW_HELP_TEXT_DEFAULT = True\nSHOW_PLACEHOLDER_DEFAULT = True\nSHOW_CORRECT_ANSWER_DEFAULT = True\nALLOW_FRACTIONS_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = 0\nCUSTOM_FORMAT_DEFAULT = '.12g'\nSHOW_SCORE_DEFAULT = True",
        "detail": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "documentation": {}
    },
    {
        "label": "ALLOW_COMPLEX_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "description": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "peekOfCode": "ALLOW_COMPLEX_DEFAULT = False\nSHOW_HELP_TEXT_DEFAULT = True\nSHOW_PLACEHOLDER_DEFAULT = True\nSHOW_CORRECT_ANSWER_DEFAULT = True\nALLOW_FRACTIONS_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = 0\nCUSTOM_FORMAT_DEFAULT = '.12g'\nSHOW_SCORE_DEFAULT = True\nANSWER_INSUFFICIENT_PRECISION_WARNING = (",
        "detail": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "documentation": {}
    },
    {
        "label": "SHOW_HELP_TEXT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "description": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "peekOfCode": "SHOW_HELP_TEXT_DEFAULT = True\nSHOW_PLACEHOLDER_DEFAULT = True\nSHOW_CORRECT_ANSWER_DEFAULT = True\nALLOW_FRACTIONS_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = 0\nCUSTOM_FORMAT_DEFAULT = '.12g'\nSHOW_SCORE_DEFAULT = True\nANSWER_INSUFFICIENT_PRECISION_WARNING = (\n    \"Your answer does not have precision within the specified relative tolerance.\"",
        "detail": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "documentation": {}
    },
    {
        "label": "SHOW_PLACEHOLDER_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "description": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "peekOfCode": "SHOW_PLACEHOLDER_DEFAULT = True\nSHOW_CORRECT_ANSWER_DEFAULT = True\nALLOW_FRACTIONS_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = 0\nCUSTOM_FORMAT_DEFAULT = '.12g'\nSHOW_SCORE_DEFAULT = True\nANSWER_INSUFFICIENT_PRECISION_WARNING = (\n    \"Your answer does not have precision within the specified relative tolerance.\"\n)",
        "detail": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "documentation": {}
    },
    {
        "label": "SHOW_CORRECT_ANSWER_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "description": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "peekOfCode": "SHOW_CORRECT_ANSWER_DEFAULT = True\nALLOW_FRACTIONS_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = 0\nCUSTOM_FORMAT_DEFAULT = '.12g'\nSHOW_SCORE_DEFAULT = True\nANSWER_INSUFFICIENT_PRECISION_WARNING = (\n    \"Your answer does not have precision within the specified relative tolerance.\"\n)\n# Get the absolute path of the current module",
        "detail": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "documentation": {}
    },
    {
        "label": "ALLOW_FRACTIONS_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "description": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "peekOfCode": "ALLOW_FRACTIONS_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = 0\nCUSTOM_FORMAT_DEFAULT = '.12g'\nSHOW_SCORE_DEFAULT = True\nANSWER_INSUFFICIENT_PRECISION_WARNING = (\n    \"Your answer does not have precision within the specified relative tolerance.\"\n)\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)",
        "detail": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "documentation": {}
    },
    {
        "label": "ALLOW_BLANK_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "description": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "peekOfCode": "ALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = 0\nCUSTOM_FORMAT_DEFAULT = '.12g'\nSHOW_SCORE_DEFAULT = True\nANSWER_INSUFFICIENT_PRECISION_WARNING = (\n    \"Your answer does not have precision within the specified relative tolerance.\"\n)\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module",
        "detail": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "documentation": {}
    },
    {
        "label": "BLANK_VALUE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "description": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "peekOfCode": "BLANK_VALUE_DEFAULT = 0\nCUSTOM_FORMAT_DEFAULT = '.12g'\nSHOW_SCORE_DEFAULT = True\nANSWER_INSUFFICIENT_PRECISION_WARNING = (\n    \"Your answer does not have precision within the specified relative tolerance.\"\n)\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)",
        "detail": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "documentation": {}
    },
    {
        "label": "CUSTOM_FORMAT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "description": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "peekOfCode": "CUSTOM_FORMAT_DEFAULT = '.12g'\nSHOW_SCORE_DEFAULT = True\nANSWER_INSUFFICIENT_PRECISION_WARNING = (\n    \"Your answer does not have precision within the specified relative tolerance.\"\n)\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)\n# Construct the path to the 'pl-number-input.mustache' file in the same directory",
        "detail": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "documentation": {}
    },
    {
        "label": "SHOW_SCORE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "description": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "peekOfCode": "SHOW_SCORE_DEFAULT = True\nANSWER_INSUFFICIENT_PRECISION_WARNING = (\n    \"Your answer does not have precision within the specified relative tolerance.\"\n)\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)\n# Construct the path to the 'pl-number-input.mustache' file in the same directory\nNUMBER_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir, \"pl-number-input.mustache\")",
        "detail": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "documentation": {}
    },
    {
        "label": "ANSWER_INSUFFICIENT_PRECISION_WARNING",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "description": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "peekOfCode": "ANSWER_INSUFFICIENT_PRECISION_WARNING = (\n    \"Your answer does not have precision within the specified relative tolerance.\"\n)\n# Get the absolute path of the current module\ncurrent_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)\n# Construct the path to the 'pl-number-input.mustache' file in the same directory\nNUMBER_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir, \"pl-number-input.mustache\")\nprint(NUMBER_INPUT_MUSTACHE_TEMPLATE_NAME)",
        "detail": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "documentation": {}
    },
    {
        "label": "current_module_path",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "description": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "peekOfCode": "current_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)\n# Construct the path to the 'pl-number-input.mustache' file in the same directory\nNUMBER_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir, \"pl-number-input.mustache\")\nprint(NUMBER_INPUT_MUSTACHE_TEMPLATE_NAME)\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [",
        "detail": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "documentation": {}
    },
    {
        "label": "current_module_dir",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "description": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "peekOfCode": "current_module_dir = os.path.dirname(current_module_path)\n# Construct the path to the 'pl-number-input.mustache' file in the same directory\nNUMBER_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir, \"pl-number-input.mustache\")\nprint(NUMBER_INPUT_MUSTACHE_TEMPLATE_NAME)\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",\n        \"correct-answer\",",
        "detail": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "documentation": {}
    },
    {
        "label": "NUMBER_INPUT_MUSTACHE_TEMPLATE_NAME",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "description": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "peekOfCode": "NUMBER_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir, \"pl-number-input.mustache\")\nprint(NUMBER_INPUT_MUSTACHE_TEMPLATE_NAME)\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",\n        \"correct-answer\",\n        \"label\",\n        \"suffix\",",
        "detail": "src.prairielearn.elements.pl-number-input.pl-number-input",
        "documentation": {}
    },
    {
        "label": "test_only_string_precision_fn",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-number-input.pl_number_input_test",
        "description": "src.prairielearn.elements.pl-number-input.pl_number_input_test",
        "peekOfCode": "def test_only_string_precision_fn(\n    number_string: str, expected_precision: float\n) -> None:\n    precision = number_input.get_string_precision(number_string)\n    assert precision == expected_precision\n@pytest.mark.parametrize(\n    \"number_string, expected_significant_digits\",\n    [\n        (\"4\", 1),\n        (\"42\", 2),",
        "detail": "src.prairielearn.elements.pl-number-input.pl_number_input_test",
        "documentation": {}
    },
    {
        "label": "test_only_significant_digits_fn",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-number-input.pl_number_input_test",
        "description": "src.prairielearn.elements.pl-number-input.pl_number_input_test",
        "peekOfCode": "def test_only_significant_digits_fn(\n    number_string: str, expected_significant_digits: float\n) -> None:\n    precision = number_input.get_string_significant_digits(number_string)\n    assert precision == expected_significant_digits\n@pytest.mark.parametrize(\n    \"number_string, expected_decimal_digits\",\n    [\n        (\"4\", 0),\n        (\"42\", 0),",
        "detail": "src.prairielearn.elements.pl-number-input.pl_number_input_test",
        "documentation": {}
    },
    {
        "label": "test_only_decimal_digits_fn",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-number-input.pl_number_input_test",
        "description": "src.prairielearn.elements.pl-number-input.pl_number_input_test",
        "peekOfCode": "def test_only_decimal_digits_fn(\n    number_string: str, expected_decimal_digits: float\n) -> None:\n    precision = number_input.get_string_decimal_digits(number_string)\n    assert precision == expected_decimal_digits",
        "detail": "src.prairielearn.elements.pl-number-input.pl_number_input_test",
        "documentation": {}
    },
    {
        "label": "number_input",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-number-input.pl_number_input_test",
        "description": "src.prairielearn.elements.pl-number-input.pl_number_input_test",
        "peekOfCode": "number_input = importlib.import_module(\"pl-number-input\")\n@pytest.mark.parametrize(\n    \"number_string, expected_precision\",\n    [\n        (\"42\", 1),\n        (\"420\", 10),\n        (\"420.\", 1),\n        (\"420.6\", 0.1),\n        (\"420.69\", 0.01),\n        (\"420.691\", 0.001),",
        "detail": "src.prairielearn.elements.pl-number-input.pl_number_input_test",
        "documentation": {}
    },
    {
        "label": "validate_grouping",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-order-blocks.dag_checker",
        "description": "src.prairielearn.elements.pl-order-blocks.dag_checker",
        "peekOfCode": "def validate_grouping(\n    graph: nx.DiGraph, group_belonging: Mapping[str, Optional[str]]\n) -> bool:\n    for node in graph:\n        group_tag = group_belonging.get(node)\n        if group_tag is None:\n            if (\n                sum(\n                    group_belonging.get(dependency) is not None\n                    for (dependency, _) in graph.in_edges(node)",
        "detail": "src.prairielearn.elements.pl-order-blocks.dag_checker",
        "documentation": {}
    },
    {
        "label": "solve_dag",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-order-blocks.dag_checker",
        "description": "src.prairielearn.elements.pl-order-blocks.dag_checker",
        "peekOfCode": "def solve_dag(\n    depends_graph: Mapping[str, list[str]], group_belonging: Mapping[str, Optional[str]]\n) -> list[str]:\n    \"\"\"Solve the given problem\n    :param depends_graph: The dependency graph between blocks specified in the question\n    :param group_belonging: which pl-block-group each block belongs to, specified in the question\n    :return: a list that is a topological sort of the input DAG with blocks in the same group occuring\n    contiguously, making it a solution to the given problem\n    \"\"\"\n    graph = dag_to_nx(depends_graph, group_belonging)",
        "detail": "src.prairielearn.elements.pl-order-blocks.dag_checker",
        "documentation": {}
    },
    {
        "label": "check_topological_sorting",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-order-blocks.dag_checker",
        "description": "src.prairielearn.elements.pl-order-blocks.dag_checker",
        "peekOfCode": "def check_topological_sorting(submission: list[str], graph: nx.DiGraph) -> int:\n    \"\"\"\n    :param submission: candidate for topological sorting\n    :param graph: graph to check topological sorting over\n    :return: index of first element not topologically sorted, or length of list if sorted\n    \"\"\"\n    seen = set()\n    for i, node in enumerate(submission):\n        if node is None or not all(u in seen for (u, _) in graph.in_edges(node)):\n            return i",
        "detail": "src.prairielearn.elements.pl-order-blocks.dag_checker",
        "documentation": {}
    },
    {
        "label": "check_grouping",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-order-blocks.dag_checker",
        "description": "src.prairielearn.elements.pl-order-blocks.dag_checker",
        "peekOfCode": "def check_grouping(\n    submission: list[str], group_belonging: Mapping[str, Optional[str]]\n) -> int:\n    \"\"\"\n    :param submission: candidate solution\n    :param group_belonging: group that each block belongs to\n    :return: index of first element breaking condition that members of the same group must be\n    adjacent, or length of list if they all meet the condition\n    \"\"\"\n    group_sizes = Counter(group_belonging.values())",
        "detail": "src.prairielearn.elements.pl-order-blocks.dag_checker",
        "documentation": {}
    },
    {
        "label": "dag_to_nx",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-order-blocks.dag_checker",
        "description": "src.prairielearn.elements.pl-order-blocks.dag_checker",
        "peekOfCode": "def dag_to_nx(\n    depends_graph: Mapping[str, list[str]], group_belonging: Mapping[str, Optional[str]]\n) -> nx.DiGraph:\n    \"\"\"Convert input graph format into NetworkX object to utilize their algorithms.\"\"\"\n    graph = nx.DiGraph()\n    for node in depends_graph:\n        graph.add_node(node)\n        for node2 in depends_graph[node]:\n            # the depends graph lists the *incoming* edges of a node\n            graph.add_edge(node2, node)",
        "detail": "src.prairielearn.elements.pl-order-blocks.dag_checker",
        "documentation": {}
    },
    {
        "label": "add_edges_for_groups",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-order-blocks.dag_checker",
        "description": "src.prairielearn.elements.pl-order-blocks.dag_checker",
        "peekOfCode": "def add_edges_for_groups(\n    graph: nx.DiGraph, group_belonging: Mapping[str, Optional[str]]\n) -> None:\n    groups = {\n        group: [tag for tag in group_belonging if group_belonging[tag] == group]\n        for group in set(group_belonging.values())\n        if group is not None\n    }\n    if not validate_grouping(graph, group_belonging):\n        raise Exception(",
        "detail": "src.prairielearn.elements.pl-order-blocks.dag_checker",
        "documentation": {}
    },
    {
        "label": "grade_dag",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-order-blocks.dag_checker",
        "description": "src.prairielearn.elements.pl-order-blocks.dag_checker",
        "peekOfCode": "def grade_dag(\n    submission: list[str],\n    depends_graph: Mapping[str, list[str]],\n    group_belonging: Mapping[str, Optional[str]],\n) -> tuple[int, int]:\n    \"\"\"In order for a student submission to a DAG graded question to be deemed correct, the student\n    submission must be a topological sort of the DAG and blocks which are in the same pl-block-group\n    as one another must all appear contiguously.\n    :param submission: the block ordering given by the student\n    :param depends_graph: The dependency graph between blocks specified in the question",
        "detail": "src.prairielearn.elements.pl-order-blocks.dag_checker",
        "documentation": {}
    },
    {
        "label": "is_vertex_cover",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-order-blocks.dag_checker",
        "description": "src.prairielearn.elements.pl-order-blocks.dag_checker",
        "peekOfCode": "def is_vertex_cover(G: nx.DiGraph, vertex_cover: Iterable[str]) -> bool:\n    \"\"\"this function from\n    https://docs.ocean.dwavesys.com/en/stable/docs_dnx/reference/algorithms/generated/dwave_networkx.algorithms.cover.is_vertex_cover.html\n    \"\"\"\n    cover = set(vertex_cover)\n    return all(u in cover or v in cover for u, v in G.edges)\ndef lcs_partial_credit(\n    submission: list[str],\n    depends_graph: Mapping[str, list[str]],\n    group_belonging: Mapping[str, Optional[str]],",
        "detail": "src.prairielearn.elements.pl-order-blocks.dag_checker",
        "documentation": {}
    },
    {
        "label": "lcs_partial_credit",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-order-blocks.dag_checker",
        "description": "src.prairielearn.elements.pl-order-blocks.dag_checker",
        "peekOfCode": "def lcs_partial_credit(\n    submission: list[str],\n    depends_graph: Mapping[str, list[str]],\n    group_belonging: Mapping[str, Optional[str]],\n) -> int:\n    \"\"\"Computes the number of edits required to change the student solution into a correct solution using\n    largest common subsequence edit distance (allows only additions and deletions, not replacing).\n    The naive solution would be to enumerate all topological sorts, then get the edit distance to each of them,\n    but this would be too slow. Instead, our algorithm is as follows:\n        1. Remove all distractors from the student solution",
        "detail": "src.prairielearn.elements.pl-order-blocks.dag_checker",
        "documentation": {}
    },
    {
        "label": "test_grade_dag",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "description": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "peekOfCode": "def test_grade_dag():\n    for submission, expected, expected_ed in zip(\n        problem_1_submissions, problem_1_expected, problem_1_expected_ed\n    ):\n        assert grade_dag(submission, problem_1_dag, problem_1_groups) == (expected, 10)\n        assert lcs_partial_credit(submission, problem_1_dag, {}) == expected_ed\n    for submission, expected, expected_ed_no_groups, expected_ed_groups in zip(\n        problem_2_submissions,\n        problem_2_expected,\n        problem_2_expected_ed_no_groups,",
        "detail": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "documentation": {}
    },
    {
        "label": "test_problem_validation",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "description": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "peekOfCode": "def test_problem_validation():\n    dag_to_nx(problem_1_dag, problem_1_groups)\n    dag_to_nx(problem_2_dag, problem_2_groups)\n    with pytest.raises(Exception):\n        dag_to_nx(problem_3_invalid_dag_1, problem_3_groups)\n    with pytest.raises(Exception):\n        dag_to_nx(problem_3_invalid_dag_2, problem_3_groups)\n    with pytest.raises(Exception):\n        dag_to_nx(problem_3_invalid_dag_3, problem_3_groups)\n    dag_to_nx(problem_3_dag, problem_3_groups)",
        "detail": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "documentation": {}
    },
    {
        "label": "test_solve_dag",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "description": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "peekOfCode": "def test_solve_dag():\n    problems = [\n        (problem_1_dag, problem_1_groups),\n        (problem_2_dag, problem_2_groups),\n        (problem_3_dag, problem_3_groups),\n    ]\n    for depends_graph, group_belonging in problems:\n        solution = solve_dag(depends_graph, group_belonging)\n        assert len(solution) == grade_dag(solution, depends_graph, group_belonging)[0]",
        "detail": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "documentation": {}
    },
    {
        "label": "problem_1_dag",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "description": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "peekOfCode": "problem_1_dag = {\n    \"1\": [],\n    \"2\": [\"1\"],\n    \"3\": [\"1\"],\n    \"4\": [\"2\", \"3\"],\n    \"5\": [\"1\"],\n    \"6\": [\"2\"],\n    \"7\": [\"4\", \"5\", \"6\"],\n    \"8\": [],\n    \"9\": [\"7\", \"8\"],",
        "detail": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "documentation": {}
    },
    {
        "label": "problem_1_groups",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "description": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "peekOfCode": "problem_1_groups = {str(i): None for i in range(1, 11)}\nproblem_1_submissions = [\n    [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\"],\n    [\"8\", \"1\", \"3\", \"2\", \"6\", \"4\", \"5\", \"7\", \"9\", \"10\"],\n    [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"9\", \"8\", \"10\"],\n    [\"1\", \"2\", \"6\", \"3\", \"4\", \"5\"],\n]\nproblem_1_expected = [\n    10,\n    10,",
        "detail": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "documentation": {}
    },
    {
        "label": "problem_1_submissions",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "description": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "peekOfCode": "problem_1_submissions = [\n    [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\"],\n    [\"8\", \"1\", \"3\", \"2\", \"6\", \"4\", \"5\", \"7\", \"9\", \"10\"],\n    [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"9\", \"8\", \"10\"],\n    [\"1\", \"2\", \"6\", \"3\", \"4\", \"5\"],\n]\nproblem_1_expected = [\n    10,\n    10,\n    7,",
        "detail": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "documentation": {}
    },
    {
        "label": "problem_1_expected",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "description": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "peekOfCode": "problem_1_expected = [\n    10,\n    10,\n    7,\n    6,\n]\nproblem_1_expected_ed = [\n    0,\n    0,\n    2,",
        "detail": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "documentation": {}
    },
    {
        "label": "problem_1_expected_ed",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "description": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "peekOfCode": "problem_1_expected_ed = [\n    0,\n    0,\n    2,\n    4,\n]\nproblem_2_dag = {\n    \"1\": [],\n    \"2\": [\"1\"],\n    \"3\": [\"2\"],",
        "detail": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "documentation": {}
    },
    {
        "label": "problem_2_dag",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "description": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "peekOfCode": "problem_2_dag = {\n    \"1\": [],\n    \"2\": [\"1\"],\n    \"3\": [\"2\"],\n    \"4\": [],\n    \"5\": [\"4\"],\n    \"6\": [\"5\"],\n    \"7\": [\"g1\", \"g2\"],\n    \"g1\": [],\n    \"g2\": [],",
        "detail": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "documentation": {}
    },
    {
        "label": "problem_2_groups",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "description": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "peekOfCode": "problem_2_groups = {\n    \"1\": \"g1\",\n    \"2\": \"g1\",\n    \"3\": \"g1\",\n    \"4\": \"g2\",\n    \"5\": \"g2\",\n    \"6\": \"g2\",\n    \"7\": None,\n}\nproblem_2_submissions = [",
        "detail": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "documentation": {}
    },
    {
        "label": "problem_2_submissions",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "description": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "peekOfCode": "problem_2_submissions = [\n    [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\"],\n    [\"4\", \"5\", \"6\", \"1\", \"2\", \"3\", \"7\"],\n    [\"4\", \"5\", \"6\", \"1\", \"2\", \"7\"],\n    [\"1\", \"2\", \"4\", \"3\", \"5\", \"6\", \"7\"],\n    [\"1\", \"2\", \"3\", \"7\"],\n    [\"1\", \"5\", \"6\", \"2\", \"3\"],\n    [\"1\", \"6\", \"5\", \"2\", \"3\"],\n    [\"2\", None, \"3\"],\n]",
        "detail": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "documentation": {}
    },
    {
        "label": "problem_2_expected",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "description": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "peekOfCode": "problem_2_expected = [7, 7, 5, 2, 3, 1, 1, 0]\nproblem_2_expected_ed_groups = [0, 0, 1, 2, 3, 4, 6, 6]\nproblem_2_dag_no_groups = {\n    \"1\": [],\n    \"2\": [\"1\"],\n    \"3\": [\"2\"],\n    \"4\": [],\n    \"5\": [\"4\"],\n    \"6\": [\"5\"],\n    \"7\": [\"3\", \"6\"],",
        "detail": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "documentation": {}
    },
    {
        "label": "problem_2_expected_ed_groups",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "description": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "peekOfCode": "problem_2_expected_ed_groups = [0, 0, 1, 2, 3, 4, 6, 6]\nproblem_2_dag_no_groups = {\n    \"1\": [],\n    \"2\": [\"1\"],\n    \"3\": [\"2\"],\n    \"4\": [],\n    \"5\": [\"4\"],\n    \"6\": [\"5\"],\n    \"7\": [\"3\", \"6\"],\n}",
        "detail": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "documentation": {}
    },
    {
        "label": "problem_2_dag_no_groups",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "description": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "peekOfCode": "problem_2_dag_no_groups = {\n    \"1\": [],\n    \"2\": [\"1\"],\n    \"3\": [\"2\"],\n    \"4\": [],\n    \"5\": [\"4\"],\n    \"6\": [\"5\"],\n    \"7\": [\"3\", \"6\"],\n}\nproblem_2_expected_ed_no_groups = [0, 0, 1, 0, 3, 2, 4, 6]",
        "detail": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "documentation": {}
    },
    {
        "label": "problem_2_expected_ed_no_groups",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "description": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "peekOfCode": "problem_2_expected_ed_no_groups = [0, 0, 1, 0, 3, 2, 4, 6]\ndef test_grade_dag():\n    for submission, expected, expected_ed in zip(\n        problem_1_submissions, problem_1_expected, problem_1_expected_ed\n    ):\n        assert grade_dag(submission, problem_1_dag, problem_1_groups) == (expected, 10)\n        assert lcs_partial_credit(submission, problem_1_dag, {}) == expected_ed\n    for submission, expected, expected_ed_no_groups, expected_ed_groups in zip(\n        problem_2_submissions,\n        problem_2_expected,",
        "detail": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "documentation": {}
    },
    {
        "label": "problem_3_invalid_dag_1",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "description": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "peekOfCode": "problem_3_invalid_dag_1 = {\n    \"1\": [],\n    \"2\": [\"1\"],\n    \"3\": [\"2\"],\n    \"4\": [\"1\"],\n    \"5\": [\"4\"],\n    \"6\": [\"g1\", \"g2\"],\n}\nproblem_3_invalid_dag_2 = {\n    \"1\": [],",
        "detail": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "documentation": {}
    },
    {
        "label": "problem_3_invalid_dag_2",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "description": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "peekOfCode": "problem_3_invalid_dag_2 = {\n    \"1\": [],\n    \"2\": [],\n    \"3\": [\"2\"],\n    \"4\": [],\n    \"5\": [\"4\"],\n    \"6\": [\"3\", \"5\"],\n}\nproblem_3_invalid_dag_3 = {\n    \"1\": [],",
        "detail": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "documentation": {}
    },
    {
        "label": "problem_3_invalid_dag_3",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "description": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "peekOfCode": "problem_3_invalid_dag_3 = {\n    \"1\": [],\n    \"2\": [],\n    \"3\": [\"2\"],\n    \"4\": [],\n    \"5\": [\"4\", \"g1\"],\n    \"6\": [\"g1\", \"g2\"],\n}\nproblem_3_dag = {\n    \"1\": [],",
        "detail": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "documentation": {}
    },
    {
        "label": "problem_3_dag",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "description": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "peekOfCode": "problem_3_dag = {\n    \"1\": [],\n    \"2\": [],\n    \"3\": [\"2\"],\n    \"4\": [],\n    \"5\": [\"4\"],\n    \"6\": [\"g1\", \"g2\"],\n    \"g1\": [],\n    \"g2\": [],\n}",
        "detail": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "documentation": {}
    },
    {
        "label": "problem_3_groups",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "description": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "peekOfCode": "problem_3_groups = {\"1\": None, \"2\": \"g1\", \"3\": \"g1\", \"4\": \"g2\", \"5\": \"g2\", \"6\": None}\ndef test_problem_validation():\n    dag_to_nx(problem_1_dag, problem_1_groups)\n    dag_to_nx(problem_2_dag, problem_2_groups)\n    with pytest.raises(Exception):\n        dag_to_nx(problem_3_invalid_dag_1, problem_3_groups)\n    with pytest.raises(Exception):\n        dag_to_nx(problem_3_invalid_dag_2, problem_3_groups)\n    with pytest.raises(Exception):\n        dag_to_nx(problem_3_invalid_dag_3, problem_3_groups)",
        "detail": "src.prairielearn.elements.pl-order-blocks.dag_checker_test",
        "documentation": {}
    },
    {
        "label": "GradingMethodType",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "class GradingMethodType(Enum):\n    UNORDERED = \"unordered\"\n    ORDERED = \"ordered\"\n    RANKING = \"ranking\"\n    DAG = \"dag\"\n    EXTERNAL = \"external\"\nclass SourceBlocksOrderType(Enum):\n    RANDOM = \"random\"\n    ALPHABETIZED = \"alphabetized\"\n    ORDERED = \"ordered\"",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "SourceBlocksOrderType",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "class SourceBlocksOrderType(Enum):\n    RANDOM = \"random\"\n    ALPHABETIZED = \"alphabetized\"\n    ORDERED = \"ordered\"\nclass SolutionPlacementType(Enum):\n    RIGHT = \"right\"\n    BOTTOM = \"bottom\"\nclass FeedbackType(Enum):\n    NONE = \"none\"\n    FIRST_WRONG = \"first-wrong\"",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "SolutionPlacementType",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "class SolutionPlacementType(Enum):\n    RIGHT = \"right\"\n    BOTTOM = \"bottom\"\nclass FeedbackType(Enum):\n    NONE = \"none\"\n    FIRST_WRONG = \"first-wrong\"\n    FIRST_WRONG_VERBOSE = \"first-wrong-verbose\"\nclass PartialCreditType(Enum):\n    NONE = \"none\"\n    LCS = \"lcs\"",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "FeedbackType",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "class FeedbackType(Enum):\n    NONE = \"none\"\n    FIRST_WRONG = \"first-wrong\"\n    FIRST_WRONG_VERBOSE = \"first-wrong-verbose\"\nclass PartialCreditType(Enum):\n    NONE = \"none\"\n    LCS = \"lcs\"\nclass FormatType(Enum):\n    DEFAULT = \"default\"\n    CODE = \"code\"",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "PartialCreditType",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "class PartialCreditType(Enum):\n    NONE = \"none\"\n    LCS = \"lcs\"\nclass FormatType(Enum):\n    DEFAULT = \"default\"\n    CODE = \"code\"\nclass GroupInfo(TypedDict):\n    tag: Optional[str]\n    depends: Optional[list[str]]\nclass OrderBlocksAnswerData(TypedDict):",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "FormatType",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "class FormatType(Enum):\n    DEFAULT = \"default\"\n    CODE = \"code\"\nclass GroupInfo(TypedDict):\n    tag: Optional[str]\n    depends: Optional[list[str]]\nclass OrderBlocksAnswerData(TypedDict):\n    inner_html: str\n    indent: Optional[int]\n    ranking: int",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "GroupInfo",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "class GroupInfo(TypedDict):\n    tag: Optional[str]\n    depends: Optional[list[str]]\nclass OrderBlocksAnswerData(TypedDict):\n    inner_html: str\n    indent: Optional[int]\n    ranking: int\n    index: int\n    tag: str\n    distractor_for: Optional[str]",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "OrderBlocksAnswerData",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "class OrderBlocksAnswerData(TypedDict):\n    inner_html: str\n    indent: Optional[int]\n    ranking: int\n    index: int\n    tag: str\n    distractor_for: Optional[str]\n    depends: list[str]  # only used with DAG grader\n    group_info: GroupInfo  # only used with DAG grader\n    distractor_bin: NotRequired[str]",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "get_graph_info",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "def get_graph_info(html_tags: lxml.html.HtmlElement) -> tuple[str, list[str]]:\n    tag = pl.get_string_attrib(html_tags, \"tag\", pl.get_uuid()).strip()\n    depends = pl.get_string_attrib(html_tags, \"depends\", \"\")\n    depends = [tag.strip() for tag in depends.split(\",\")] if depends else []\n    return tag, depends\ndef extract_dag(\n    answers_list: list[OrderBlocksAnswerData],\n) -> tuple[dict[str, list[str]], dict[str, Optional[str]]]:\n    depends_graph = {ans[\"tag\"]: ans[\"depends\"] for ans in answers_list}\n    group_belonging = {ans[\"tag\"]: ans[\"group_info\"][\"tag\"] for ans in answers_list}",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "extract_dag",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "def extract_dag(\n    answers_list: list[OrderBlocksAnswerData],\n) -> tuple[dict[str, list[str]], dict[str, Optional[str]]]:\n    depends_graph = {ans[\"tag\"]: ans[\"depends\"] for ans in answers_list}\n    group_belonging = {ans[\"tag\"]: ans[\"group_info\"][\"tag\"] for ans in answers_list}\n    group_depends = {\n        ans[\"group_info\"][\"tag\"]: ans[\"group_info\"][\"depends\"]\n        for ans in answers_list\n        if ans[\"group_info\"][\"depends\"] is not None\n        and ans[\"group_info\"][\"tag\"] is not None",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "solve_problem",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "def solve_problem(\n    answers_list: list[OrderBlocksAnswerData], grading_method: GradingMethodType\n) -> list[OrderBlocksAnswerData]:\n    if (\n        grading_method is GradingMethodType.EXTERNAL\n        or grading_method is GradingMethodType.UNORDERED\n        or grading_method is GradingMethodType.ORDERED\n    ):\n        return answers_list\n    elif grading_method is GradingMethodType.RANKING:",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "def prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"source-blocks-order\",\n        \"grading-method\",\n        \"indentation\",\n        \"source-header\",\n        \"solution-header\",\n        \"file-name\",",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "get_distractors",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "def get_distractors(\n    all_blocks: list[OrderBlocksAnswerData], correct_blocks: list[OrderBlocksAnswerData]\n) -> list[OrderBlocksAnswerData]:\n    return [\n        block\n        for block in all_blocks\n        if block[\"uuid\"] not in set(block2[\"uuid\"] for block2 in correct_blocks)\n    ]\ndef render(element_html: str, data: pl.QuestionData) -> str:\n    element = lxml.html.fragment_fromstring(element_html)",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "def render(element_html: str, data: pl.QuestionData) -> str:\n    element = lxml.html.fragment_fromstring(element_html)\n    answer_name = pl.get_string_attrib(element, \"answers-name\")\n    format = pl.get_enum_attrib(element, \"format\", FormatType, FormatType.DEFAULT)\n    inline = pl.get_boolean_attrib(element, \"inline\", INLINE_DEFAULT)\n    dropzone_layout = pl.get_enum_attrib(\n        element,\n        \"solution-placement\",\n        SolutionPlacementType,\n        SolutionPlacementType.RIGHT,",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "def parse(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    answer_name = pl.get_string_attrib(element, \"answers-name\")\n    allow_blank_submission = pl.get_boolean_attrib(\n        element, \"allow-blank\", ALLOW_BLANK_DEFAULT\n    )\n    answer_raw_name = answer_name + \"-input\"\n    student_answer = data[\"raw_submitted_answers\"].get(answer_raw_name, \"[]\")\n    student_answer = json.loads(student_answer)\n    if (not allow_blank_submission) and (",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "construct_feedback",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "def construct_feedback(\n    feedback_type: FeedbackType,\n    first_wrong: Optional[int],\n    group_belonging: dict[str, Optional[str]],\n    check_indentation: bool,\n    first_wrong_is_distractor: bool,\n) -> str:\n    if feedback_type is FeedbackType.NONE:\n        return \"\"\n    if first_wrong is None:",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "grade",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "def grade(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    answer_name = pl.get_string_attrib(element, \"answers-name\")\n    student_answer = data[\"submitted_answers\"][answer_name]\n    grading_method = pl.get_enum_attrib(\n        element, \"grading-method\", GradingMethodType, GRADING_METHOD_DEFAULT\n    )\n    check_indentation = pl.get_boolean_attrib(element, \"indentation\", INDENTION_DEFAULT)\n    feedback_type = pl.get_enum_attrib(\n        element, \"feedback\", FeedbackType, FEEDBACK_DEFAULT",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "get_default_partial_credit_type",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "def get_default_partial_credit_type(\n    grading_method: GradingMethodType,\n) -> PartialCreditType:\n    # For backward compatibility, we need to override the default partial credit type\n    # when grading_method = ORDERED\n    return (\n        PartialCreditType.NONE\n        if grading_method is GradingMethodType.ORDERED\n        else PartialCreditType.LCS\n    )",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "def test(element_html: str, data: pl.ElementTestData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    grading_method = pl.get_enum_attrib(\n        element, \"grading-method\", GradingMethodType, GRADING_METHOD_DEFAULT\n    )\n    answer_name = pl.get_string_attrib(element, \"answers-name\")\n    answer_name_field = answer_name + \"-input\"\n    weight = pl.get_integer_attrib(element, \"weight\", WEIGHT_DEFAULT)\n    check_indentation = pl.get_boolean_attrib(element, \"indentation\", INDENTION_DEFAULT)\n    feedback_type = pl.get_enum_attrib(",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "pl_order_blocks_path",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "pl_order_blocks_path = os.path.join(os.getcwd(), 'src','prairielearn', 'elements', 'pl-order-blocks')\nprint(pl_order_blocks_path)\nsys.path.append(pl_order_blocks_path)\nfrom dag_checker import grade_dag, lcs_partial_credit, solve_dag\nimport chevron\nimport lxml.html\nfrom prairielearn.python import prairielearn as pl\nfrom lxml.etree import Comment\nfrom typing_extensions import NotRequired, assert_never\n# from .dag_checker import grade_dag, lcs_partial_credit,solve_dag",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "current_module_path",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "current_module_path = os.path.abspath(__file__)\nprint(current_module_path)\nORDER_BLOCKS_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_path,\"..\",\"pl-order-blocks.mustache\")\nclass GradingMethodType(Enum):\n    UNORDERED = \"unordered\"\n    ORDERED = \"ordered\"\n    RANKING = \"ranking\"\n    DAG = \"dag\"\n    EXTERNAL = \"external\"\nclass SourceBlocksOrderType(Enum):",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "ORDER_BLOCKS_MUSTACHE_TEMPLATE_NAME",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "ORDER_BLOCKS_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_path,\"..\",\"pl-order-blocks.mustache\")\nclass GradingMethodType(Enum):\n    UNORDERED = \"unordered\"\n    ORDERED = \"ordered\"\n    RANKING = \"ranking\"\n    DAG = \"dag\"\n    EXTERNAL = \"external\"\nclass SourceBlocksOrderType(Enum):\n    RANDOM = \"random\"\n    ALPHABETIZED = \"alphabetized\"",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "FIRST_WRONG_TYPES",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "FIRST_WRONG_TYPES = frozenset(\n    [FeedbackType.FIRST_WRONG, FeedbackType.FIRST_WRONG_VERBOSE]\n)\nLCS_GRADABLE_TYPES = frozenset(\n    [GradingMethodType.RANKING, GradingMethodType.DAG, GradingMethodType.ORDERED]\n)\nGRADING_METHOD_DEFAULT = GradingMethodType.ORDERED\nSOURCE_BLOCKS_ORDER_DEFAULT = SourceBlocksOrderType.ALPHABETIZED\nFEEDBACK_DEFAULT = FeedbackType.NONE\nPL_ANSWER_CORRECT_DEFAULT = True",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "LCS_GRADABLE_TYPES",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "LCS_GRADABLE_TYPES = frozenset(\n    [GradingMethodType.RANKING, GradingMethodType.DAG, GradingMethodType.ORDERED]\n)\nGRADING_METHOD_DEFAULT = GradingMethodType.ORDERED\nSOURCE_BLOCKS_ORDER_DEFAULT = SourceBlocksOrderType.ALPHABETIZED\nFEEDBACK_DEFAULT = FeedbackType.NONE\nPL_ANSWER_CORRECT_DEFAULT = True\nPL_ANSWER_INDENT_DEFAULT = -1\nALLOW_BLANK_DEFAULT = False\nINDENTION_DEFAULT = False",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "GRADING_METHOD_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "GRADING_METHOD_DEFAULT = GradingMethodType.ORDERED\nSOURCE_BLOCKS_ORDER_DEFAULT = SourceBlocksOrderType.ALPHABETIZED\nFEEDBACK_DEFAULT = FeedbackType.NONE\nPL_ANSWER_CORRECT_DEFAULT = True\nPL_ANSWER_INDENT_DEFAULT = -1\nALLOW_BLANK_DEFAULT = False\nINDENTION_DEFAULT = False\nINLINE_DEFAULT = False\nMAX_INDENTION_DEFAULT = 4\nSOURCE_HEADER_DEFAULT = \"Drag from here:\"",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "SOURCE_BLOCKS_ORDER_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "SOURCE_BLOCKS_ORDER_DEFAULT = SourceBlocksOrderType.ALPHABETIZED\nFEEDBACK_DEFAULT = FeedbackType.NONE\nPL_ANSWER_CORRECT_DEFAULT = True\nPL_ANSWER_INDENT_DEFAULT = -1\nALLOW_BLANK_DEFAULT = False\nINDENTION_DEFAULT = False\nINLINE_DEFAULT = False\nMAX_INDENTION_DEFAULT = 4\nSOURCE_HEADER_DEFAULT = \"Drag from here:\"\nSOLUTION_HEADER_DEFAULT = \"Construct your solution here:\"",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "FEEDBACK_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "FEEDBACK_DEFAULT = FeedbackType.NONE\nPL_ANSWER_CORRECT_DEFAULT = True\nPL_ANSWER_INDENT_DEFAULT = -1\nALLOW_BLANK_DEFAULT = False\nINDENTION_DEFAULT = False\nINLINE_DEFAULT = False\nMAX_INDENTION_DEFAULT = 4\nSOURCE_HEADER_DEFAULT = \"Drag from here:\"\nSOLUTION_HEADER_DEFAULT = \"Construct your solution here:\"\nFILE_NAME_DEFAULT = \"user_code.py\"",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "PL_ANSWER_CORRECT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "PL_ANSWER_CORRECT_DEFAULT = True\nPL_ANSWER_INDENT_DEFAULT = -1\nALLOW_BLANK_DEFAULT = False\nINDENTION_DEFAULT = False\nINLINE_DEFAULT = False\nMAX_INDENTION_DEFAULT = 4\nSOURCE_HEADER_DEFAULT = \"Drag from here:\"\nSOLUTION_HEADER_DEFAULT = \"Construct your solution here:\"\nFILE_NAME_DEFAULT = \"user_code.py\"\nWEIGHT_DEFAULT = 1",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "PL_ANSWER_INDENT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "PL_ANSWER_INDENT_DEFAULT = -1\nALLOW_BLANK_DEFAULT = False\nINDENTION_DEFAULT = False\nINLINE_DEFAULT = False\nMAX_INDENTION_DEFAULT = 4\nSOURCE_HEADER_DEFAULT = \"Drag from here:\"\nSOLUTION_HEADER_DEFAULT = \"Construct your solution here:\"\nFILE_NAME_DEFAULT = \"user_code.py\"\nWEIGHT_DEFAULT = 1\nTAB_SIZE_PX = 50",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "ALLOW_BLANK_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "ALLOW_BLANK_DEFAULT = False\nINDENTION_DEFAULT = False\nINLINE_DEFAULT = False\nMAX_INDENTION_DEFAULT = 4\nSOURCE_HEADER_DEFAULT = \"Drag from here:\"\nSOLUTION_HEADER_DEFAULT = \"Construct your solution here:\"\nFILE_NAME_DEFAULT = \"user_code.py\"\nWEIGHT_DEFAULT = 1\nTAB_SIZE_PX = 50\nFIRST_WRONG_FEEDBACK = {",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "INDENTION_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "INDENTION_DEFAULT = False\nINLINE_DEFAULT = False\nMAX_INDENTION_DEFAULT = 4\nSOURCE_HEADER_DEFAULT = \"Drag from here:\"\nSOLUTION_HEADER_DEFAULT = \"Construct your solution here:\"\nFILE_NAME_DEFAULT = \"user_code.py\"\nWEIGHT_DEFAULT = 1\nTAB_SIZE_PX = 50\nFIRST_WRONG_FEEDBACK = {\n    \"incomplete\": \"Your answer is correct so far, but it is incomplete.\",",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "INLINE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "INLINE_DEFAULT = False\nMAX_INDENTION_DEFAULT = 4\nSOURCE_HEADER_DEFAULT = \"Drag from here:\"\nSOLUTION_HEADER_DEFAULT = \"Construct your solution here:\"\nFILE_NAME_DEFAULT = \"user_code.py\"\nWEIGHT_DEFAULT = 1\nTAB_SIZE_PX = 50\nFIRST_WRONG_FEEDBACK = {\n    \"incomplete\": \"Your answer is correct so far, but it is incomplete.\",\n    \"wrong-at-block\": r\"\"\"Your answer is incorrect starting at <span style=\"color:red;\">block number {}</span>.",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "MAX_INDENTION_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "MAX_INDENTION_DEFAULT = 4\nSOURCE_HEADER_DEFAULT = \"Drag from here:\"\nSOLUTION_HEADER_DEFAULT = \"Construct your solution here:\"\nFILE_NAME_DEFAULT = \"user_code.py\"\nWEIGHT_DEFAULT = 1\nTAB_SIZE_PX = 50\nFIRST_WRONG_FEEDBACK = {\n    \"incomplete\": \"Your answer is correct so far, but it is incomplete.\",\n    \"wrong-at-block\": r\"\"\"Your answer is incorrect starting at <span style=\"color:red;\">block number {}</span>.\n        The problem is most likely one of the following:",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "SOURCE_HEADER_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "SOURCE_HEADER_DEFAULT = \"Drag from here:\"\nSOLUTION_HEADER_DEFAULT = \"Construct your solution here:\"\nFILE_NAME_DEFAULT = \"user_code.py\"\nWEIGHT_DEFAULT = 1\nTAB_SIZE_PX = 50\nFIRST_WRONG_FEEDBACK = {\n    \"incomplete\": \"Your answer is correct so far, but it is incomplete.\",\n    \"wrong-at-block\": r\"\"\"Your answer is incorrect starting at <span style=\"color:red;\">block number {}</span>.\n        The problem is most likely one of the following:\n        <ul><li> This block is not a part of the correct solution </li>",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "SOLUTION_HEADER_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "SOLUTION_HEADER_DEFAULT = \"Construct your solution here:\"\nFILE_NAME_DEFAULT = \"user_code.py\"\nWEIGHT_DEFAULT = 1\nTAB_SIZE_PX = 50\nFIRST_WRONG_FEEDBACK = {\n    \"incomplete\": \"Your answer is correct so far, but it is incomplete.\",\n    \"wrong-at-block\": r\"\"\"Your answer is incorrect starting at <span style=\"color:red;\">block number {}</span>.\n        The problem is most likely one of the following:\n        <ul><li> This block is not a part of the correct solution </li>\n        <li>This block needs to come after a block that did not appear before it </li>\"\"\",",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "FILE_NAME_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "FILE_NAME_DEFAULT = \"user_code.py\"\nWEIGHT_DEFAULT = 1\nTAB_SIZE_PX = 50\nFIRST_WRONG_FEEDBACK = {\n    \"incomplete\": \"Your answer is correct so far, but it is incomplete.\",\n    \"wrong-at-block\": r\"\"\"Your answer is incorrect starting at <span style=\"color:red;\">block number {}</span>.\n        The problem is most likely one of the following:\n        <ul><li> This block is not a part of the correct solution </li>\n        <li>This block needs to come after a block that did not appear before it </li>\"\"\",\n    \"indentation\": r\"\"\"<li>This line is indented incorrectly </li>\"\"\",",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "WEIGHT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "WEIGHT_DEFAULT = 1\nTAB_SIZE_PX = 50\nFIRST_WRONG_FEEDBACK = {\n    \"incomplete\": \"Your answer is correct so far, but it is incomplete.\",\n    \"wrong-at-block\": r\"\"\"Your answer is incorrect starting at <span style=\"color:red;\">block number {}</span>.\n        The problem is most likely one of the following:\n        <ul><li> This block is not a part of the correct solution </li>\n        <li>This block needs to come after a block that did not appear before it </li>\"\"\",\n    \"indentation\": r\"\"\"<li>This line is indented incorrectly </li>\"\"\",\n    \"block-group\": r\"\"\"<li> You have attempted to start a new section of the answer without finishing the previous section </li>\"\"\",",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "TAB_SIZE_PX",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "TAB_SIZE_PX = 50\nFIRST_WRONG_FEEDBACK = {\n    \"incomplete\": \"Your answer is correct so far, but it is incomplete.\",\n    \"wrong-at-block\": r\"\"\"Your answer is incorrect starting at <span style=\"color:red;\">block number {}</span>.\n        The problem is most likely one of the following:\n        <ul><li> This block is not a part of the correct solution </li>\n        <li>This block needs to come after a block that did not appear before it </li>\"\"\",\n    \"indentation\": r\"\"\"<li>This line is indented incorrectly </li>\"\"\",\n    \"block-group\": r\"\"\"<li> You have attempted to start a new section of the answer without finishing the previous section </li>\"\"\",\n    \"distractor-feedback\": r\"\"\"Your answer is incorrect starting at <span style=\"color:red;\">block number {}</span> as the block at that location is not a part of any correct solution.\"\"\",",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "FIRST_WRONG_FEEDBACK",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "description": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "peekOfCode": "FIRST_WRONG_FEEDBACK = {\n    \"incomplete\": \"Your answer is correct so far, but it is incomplete.\",\n    \"wrong-at-block\": r\"\"\"Your answer is incorrect starting at <span style=\"color:red;\">block number {}</span>.\n        The problem is most likely one of the following:\n        <ul><li> This block is not a part of the correct solution </li>\n        <li>This block needs to come after a block that did not appear before it </li>\"\"\",\n    \"indentation\": r\"\"\"<li>This line is indented incorrectly </li>\"\"\",\n    \"block-group\": r\"\"\"<li> You have attempted to start a new section of the answer without finishing the previous section </li>\"\"\",\n    \"distractor-feedback\": r\"\"\"Your answer is incorrect starting at <span style=\"color:red;\">block number {}</span> as the block at that location is not a part of any correct solution.\"\"\",\n}",
        "detail": "src.prairielearn.elements.pl-order-blocks.pl-order-blocks",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-overlay.pl-overlay",
        "description": "src.prairielearn.elements.pl-overlay.pl-overlay",
        "peekOfCode": "def prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    num_backgrounds = 0\n    for child in element:\n        if isinstance(child, lxml.html.HtmlComment):\n            continue\n        if child.tag == \"pl-location\":\n            pl.check_attribs(\n                child,\n                required_attribs=[],",
        "detail": "src.prairielearn.elements.pl-overlay.pl-overlay",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-overlay.pl-overlay",
        "description": "src.prairielearn.elements.pl-overlay.pl-overlay",
        "peekOfCode": "def render(element_html: str, data: pl.QuestionData) -> str:\n    element = lxml.html.fragment_fromstring(element_html)\n    width = pl.get_float_attrib(element, \"width\", None)\n    height = pl.get_float_attrib(element, \"height\", None)\n    background = None\n    # Assign layer index in order children are defined\n    # Later defined elements will be placed on top of earlier ones\n    locations = []\n    z_index = count(0)\n    for child in element:",
        "detail": "src.prairielearn.elements.pl-overlay.pl-overlay",
        "documentation": {}
    },
    {
        "label": "VALIGN_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-overlay.pl-overlay",
        "description": "src.prairielearn.elements.pl-overlay.pl-overlay",
        "peekOfCode": "VALIGN_DEFAULT = \"middle\"\nHALIGN_DEFAULT = \"center\"\nCLIP_DEFAULT = True\nVALIGN_VALUES = frozenset((\"top\", \"middle\", \"center\", \"bottom\"))\nHALIGN_VALUES = frozenset((\"left\", \"middle\", \"center\", \"right\"))\n# Percent to translate each alignment by.  This is relative to the top-left corner of the element.\nALIGNMENT_TO_PERC = {\n    \"top\": \"0%\",\n    \"left\": \"0%\",\n    \"middle\": \"-50%\",",
        "detail": "src.prairielearn.elements.pl-overlay.pl-overlay",
        "documentation": {}
    },
    {
        "label": "HALIGN_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-overlay.pl-overlay",
        "description": "src.prairielearn.elements.pl-overlay.pl-overlay",
        "peekOfCode": "HALIGN_DEFAULT = \"center\"\nCLIP_DEFAULT = True\nVALIGN_VALUES = frozenset((\"top\", \"middle\", \"center\", \"bottom\"))\nHALIGN_VALUES = frozenset((\"left\", \"middle\", \"center\", \"right\"))\n# Percent to translate each alignment by.  This is relative to the top-left corner of the element.\nALIGNMENT_TO_PERC = {\n    \"top\": \"0%\",\n    \"left\": \"0%\",\n    \"middle\": \"-50%\",\n    \"center\": \"-50%\",",
        "detail": "src.prairielearn.elements.pl-overlay.pl-overlay",
        "documentation": {}
    },
    {
        "label": "CLIP_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-overlay.pl-overlay",
        "description": "src.prairielearn.elements.pl-overlay.pl-overlay",
        "peekOfCode": "CLIP_DEFAULT = True\nVALIGN_VALUES = frozenset((\"top\", \"middle\", \"center\", \"bottom\"))\nHALIGN_VALUES = frozenset((\"left\", \"middle\", \"center\", \"right\"))\n# Percent to translate each alignment by.  This is relative to the top-left corner of the element.\nALIGNMENT_TO_PERC = {\n    \"top\": \"0%\",\n    \"left\": \"0%\",\n    \"middle\": \"-50%\",\n    \"center\": \"-50%\",\n    \"bottom\": \"-100%\",",
        "detail": "src.prairielearn.elements.pl-overlay.pl-overlay",
        "documentation": {}
    },
    {
        "label": "VALIGN_VALUES",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-overlay.pl-overlay",
        "description": "src.prairielearn.elements.pl-overlay.pl-overlay",
        "peekOfCode": "VALIGN_VALUES = frozenset((\"top\", \"middle\", \"center\", \"bottom\"))\nHALIGN_VALUES = frozenset((\"left\", \"middle\", \"center\", \"right\"))\n# Percent to translate each alignment by.  This is relative to the top-left corner of the element.\nALIGNMENT_TO_PERC = {\n    \"top\": \"0%\",\n    \"left\": \"0%\",\n    \"middle\": \"-50%\",\n    \"center\": \"-50%\",\n    \"bottom\": \"-100%\",\n    \"right\": \"-100%\",",
        "detail": "src.prairielearn.elements.pl-overlay.pl-overlay",
        "documentation": {}
    },
    {
        "label": "HALIGN_VALUES",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-overlay.pl-overlay",
        "description": "src.prairielearn.elements.pl-overlay.pl-overlay",
        "peekOfCode": "HALIGN_VALUES = frozenset((\"left\", \"middle\", \"center\", \"right\"))\n# Percent to translate each alignment by.  This is relative to the top-left corner of the element.\nALIGNMENT_TO_PERC = {\n    \"top\": \"0%\",\n    \"left\": \"0%\",\n    \"middle\": \"-50%\",\n    \"center\": \"-50%\",\n    \"bottom\": \"-100%\",\n    \"right\": \"-100%\",\n}",
        "detail": "src.prairielearn.elements.pl-overlay.pl-overlay",
        "documentation": {}
    },
    {
        "label": "ALIGNMENT_TO_PERC",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-overlay.pl-overlay",
        "description": "src.prairielearn.elements.pl-overlay.pl-overlay",
        "peekOfCode": "ALIGNMENT_TO_PERC = {\n    \"top\": \"0%\",\n    \"left\": \"0%\",\n    \"middle\": \"-50%\",\n    \"center\": \"-50%\",\n    \"bottom\": \"-100%\",\n    \"right\": \"-100%\",\n}\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)",
        "detail": "src.prairielearn.elements.pl-overlay.pl-overlay",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-prairiedraw-figure.pl-prairiedraw-figure",
        "description": "src.prairielearn.elements.pl-prairiedraw-figure.pl-prairiedraw-figure",
        "peekOfCode": "def prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"script-name\"]\n    optional_attribs = [\"param-names\", \"width\", \"height\"]\n    pl.check_attribs(element, required_attribs, optional_attribs)\ndef render(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    script_name = pl.get_string_attrib(element, \"script-name\", None)\n    with open(os.path.join(data[\"options\"][\"question_path\"], script_name)) as f:\n        script = f.read()",
        "detail": "src.prairielearn.elements.pl-prairiedraw-figure.pl-prairiedraw-figure",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-prairiedraw-figure.pl-prairiedraw-figure",
        "description": "src.prairielearn.elements.pl-prairiedraw-figure.pl-prairiedraw-figure",
        "peekOfCode": "def render(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    script_name = pl.get_string_attrib(element, \"script-name\", None)\n    with open(os.path.join(data[\"options\"][\"question_path\"], script_name)) as f:\n        script = f.read()\n    width = pl.get_string_attrib(element, \"width\", WIDTH_DEFAULT)\n    height = pl.get_string_attrib(element, \"height\", HEIGHT_DEFAULT)\n    params_names = pl.get_string_attrib(element, \"param-names\", PARAM_NAMES_DEFAULT)\n    if params_names is None:\n        client_params = {}",
        "detail": "src.prairielearn.elements.pl-prairiedraw-figure.pl-prairiedraw-figure",
        "documentation": {}
    },
    {
        "label": "PARAM_NAMES_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-prairiedraw-figure.pl-prairiedraw-figure",
        "description": "src.prairielearn.elements.pl-prairiedraw-figure.pl-prairiedraw-figure",
        "peekOfCode": "PARAM_NAMES_DEFAULT = None\nWIDTH_DEFAULT = \"500\"\nHEIGHT_DEFAULT = \"300\"\ndef prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"script-name\"]\n    optional_attribs = [\"param-names\", \"width\", \"height\"]\n    pl.check_attribs(element, required_attribs, optional_attribs)\ndef render(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)",
        "detail": "src.prairielearn.elements.pl-prairiedraw-figure.pl-prairiedraw-figure",
        "documentation": {}
    },
    {
        "label": "WIDTH_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-prairiedraw-figure.pl-prairiedraw-figure",
        "description": "src.prairielearn.elements.pl-prairiedraw-figure.pl-prairiedraw-figure",
        "peekOfCode": "WIDTH_DEFAULT = \"500\"\nHEIGHT_DEFAULT = \"300\"\ndef prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"script-name\"]\n    optional_attribs = [\"param-names\", \"width\", \"height\"]\n    pl.check_attribs(element, required_attribs, optional_attribs)\ndef render(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    script_name = pl.get_string_attrib(element, \"script-name\", None)",
        "detail": "src.prairielearn.elements.pl-prairiedraw-figure.pl-prairiedraw-figure",
        "documentation": {}
    },
    {
        "label": "HEIGHT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-prairiedraw-figure.pl-prairiedraw-figure",
        "description": "src.prairielearn.elements.pl-prairiedraw-figure.pl-prairiedraw-figure",
        "peekOfCode": "HEIGHT_DEFAULT = \"300\"\ndef prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"script-name\"]\n    optional_attribs = [\"param-names\", \"width\", \"height\"]\n    pl.check_attribs(element, required_attribs, optional_attribs)\ndef render(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    script_name = pl.get_string_attrib(element, \"script-name\", None)\n    with open(os.path.join(data[\"options\"][\"question_path\"], script_name)) as f:",
        "detail": "src.prairielearn.elements.pl-prairiedraw-figure.pl-prairiedraw-figure",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "description": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "peekOfCode": "def prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    pl.check_attribs(\n        element,\n        required_attribs=[\"params-name\"],\n        optional_attribs=[\n            \"no-highlight\",\n            \"prefix\",\n            \"suffix\",\n            \"prefix-newline\",",
        "detail": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "description": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "peekOfCode": "def render(element_html: str, data: pl.QuestionData) -> str:\n    element = lxml.html.fragment_fromstring(element_html)\n    varname = pl.get_string_attrib(element, \"params-name\")\n    no_highlight = pl.get_boolean_attrib(element, \"no-highlight\", NO_HIGHLIGHT_DEFAULT)\n    prefix = pl.get_string_attrib(element, \"prefix\", PREFIX_DEFAULT)\n    suffix = pl.get_string_attrib(element, \"suffix\", SUFFIX_DEFAULT)\n    # Pretty print parameters\n    indent = pl.get_integer_attrib(element, \"indent\", INDENT_DEFAULT)\n    depth = pl.get_integer_attrib(element, \"depth\", DEPTH_DEFAULT)\n    width = pl.get_integer_attrib(element, \"width\", WIDTH_DEFAULT)",
        "detail": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "documentation": {}
    },
    {
        "label": "NO_HIGHLIGHT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "description": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "peekOfCode": "NO_HIGHLIGHT_DEFAULT = False\nPREFIX_DEFAULT = \"\"\nSUFFIX_DEFAULT = \"\"\nPREFIX_NEWLINE_DEFAULT = False\nSUFFIX_NEWLINE_DEFAULT = False\n# Pretty print parameters\nINDENT_DEFAULT = 1\nDEPTH_DEFAULT = None\nWIDTH_DEFAULT = 80\nCOMPACT_DEFAULT = False",
        "detail": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "documentation": {}
    },
    {
        "label": "PREFIX_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "description": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "peekOfCode": "PREFIX_DEFAULT = \"\"\nSUFFIX_DEFAULT = \"\"\nPREFIX_NEWLINE_DEFAULT = False\nSUFFIX_NEWLINE_DEFAULT = False\n# Pretty print parameters\nINDENT_DEFAULT = 1\nDEPTH_DEFAULT = None\nWIDTH_DEFAULT = 80\nCOMPACT_DEFAULT = False\nSORT_DICTS_DEFAULT = False",
        "detail": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "documentation": {}
    },
    {
        "label": "SUFFIX_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "description": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "peekOfCode": "SUFFIX_DEFAULT = \"\"\nPREFIX_NEWLINE_DEFAULT = False\nSUFFIX_NEWLINE_DEFAULT = False\n# Pretty print parameters\nINDENT_DEFAULT = 1\nDEPTH_DEFAULT = None\nWIDTH_DEFAULT = 80\nCOMPACT_DEFAULT = False\nSORT_DICTS_DEFAULT = False\n# Legacy dataframe parameters",
        "detail": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "documentation": {}
    },
    {
        "label": "PREFIX_NEWLINE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "description": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "peekOfCode": "PREFIX_NEWLINE_DEFAULT = False\nSUFFIX_NEWLINE_DEFAULT = False\n# Pretty print parameters\nINDENT_DEFAULT = 1\nDEPTH_DEFAULT = None\nWIDTH_DEFAULT = 80\nCOMPACT_DEFAULT = False\nSORT_DICTS_DEFAULT = False\n# Legacy dataframe parameters\nTEXT_DEFAULT = False",
        "detail": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "documentation": {}
    },
    {
        "label": "SUFFIX_NEWLINE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "description": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "peekOfCode": "SUFFIX_NEWLINE_DEFAULT = False\n# Pretty print parameters\nINDENT_DEFAULT = 1\nDEPTH_DEFAULT = None\nWIDTH_DEFAULT = 80\nCOMPACT_DEFAULT = False\nSORT_DICTS_DEFAULT = False\n# Legacy dataframe parameters\nTEXT_DEFAULT = False\nSHOW_HEADER_DEFAULT = True",
        "detail": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "documentation": {}
    },
    {
        "label": "INDENT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "description": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "peekOfCode": "INDENT_DEFAULT = 1\nDEPTH_DEFAULT = None\nWIDTH_DEFAULT = 80\nCOMPACT_DEFAULT = False\nSORT_DICTS_DEFAULT = False\n# Legacy dataframe parameters\nTEXT_DEFAULT = False\nSHOW_HEADER_DEFAULT = True\nSHOW_INDEX_DEFAULT = True\nSHOW_DIMENSIONS_DEFAULT = True",
        "detail": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "documentation": {}
    },
    {
        "label": "DEPTH_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "description": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "peekOfCode": "DEPTH_DEFAULT = None\nWIDTH_DEFAULT = 80\nCOMPACT_DEFAULT = False\nSORT_DICTS_DEFAULT = False\n# Legacy dataframe parameters\nTEXT_DEFAULT = False\nSHOW_HEADER_DEFAULT = True\nSHOW_INDEX_DEFAULT = True\nSHOW_DIMENSIONS_DEFAULT = True\nCOPY_CODE_BUTTON_DEFAULT = False",
        "detail": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "documentation": {}
    },
    {
        "label": "WIDTH_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "description": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "peekOfCode": "WIDTH_DEFAULT = 80\nCOMPACT_DEFAULT = False\nSORT_DICTS_DEFAULT = False\n# Legacy dataframe parameters\nTEXT_DEFAULT = False\nSHOW_HEADER_DEFAULT = True\nSHOW_INDEX_DEFAULT = True\nSHOW_DIMENSIONS_DEFAULT = True\nCOPY_CODE_BUTTON_DEFAULT = False\nSHOW_LINE_NUMBERS_DEFAULT = False",
        "detail": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "documentation": {}
    },
    {
        "label": "COMPACT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "description": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "peekOfCode": "COMPACT_DEFAULT = False\nSORT_DICTS_DEFAULT = False\n# Legacy dataframe parameters\nTEXT_DEFAULT = False\nSHOW_HEADER_DEFAULT = True\nSHOW_INDEX_DEFAULT = True\nSHOW_DIMENSIONS_DEFAULT = True\nCOPY_CODE_BUTTON_DEFAULT = False\nSHOW_LINE_NUMBERS_DEFAULT = False\ndef prepare(element_html: str, data: pl.QuestionData) -> None:",
        "detail": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "documentation": {}
    },
    {
        "label": "SORT_DICTS_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "description": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "peekOfCode": "SORT_DICTS_DEFAULT = False\n# Legacy dataframe parameters\nTEXT_DEFAULT = False\nSHOW_HEADER_DEFAULT = True\nSHOW_INDEX_DEFAULT = True\nSHOW_DIMENSIONS_DEFAULT = True\nCOPY_CODE_BUTTON_DEFAULT = False\nSHOW_LINE_NUMBERS_DEFAULT = False\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)",
        "detail": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "documentation": {}
    },
    {
        "label": "TEXT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "description": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "peekOfCode": "TEXT_DEFAULT = False\nSHOW_HEADER_DEFAULT = True\nSHOW_INDEX_DEFAULT = True\nSHOW_DIMENSIONS_DEFAULT = True\nCOPY_CODE_BUTTON_DEFAULT = False\nSHOW_LINE_NUMBERS_DEFAULT = False\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    pl.check_attribs(\n        element,",
        "detail": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "documentation": {}
    },
    {
        "label": "SHOW_HEADER_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "description": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "peekOfCode": "SHOW_HEADER_DEFAULT = True\nSHOW_INDEX_DEFAULT = True\nSHOW_DIMENSIONS_DEFAULT = True\nCOPY_CODE_BUTTON_DEFAULT = False\nSHOW_LINE_NUMBERS_DEFAULT = False\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    pl.check_attribs(\n        element,\n        required_attribs=[\"params-name\"],",
        "detail": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "documentation": {}
    },
    {
        "label": "SHOW_INDEX_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "description": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "peekOfCode": "SHOW_INDEX_DEFAULT = True\nSHOW_DIMENSIONS_DEFAULT = True\nCOPY_CODE_BUTTON_DEFAULT = False\nSHOW_LINE_NUMBERS_DEFAULT = False\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    pl.check_attribs(\n        element,\n        required_attribs=[\"params-name\"],\n        optional_attribs=[",
        "detail": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "documentation": {}
    },
    {
        "label": "SHOW_DIMENSIONS_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "description": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "peekOfCode": "SHOW_DIMENSIONS_DEFAULT = True\nCOPY_CODE_BUTTON_DEFAULT = False\nSHOW_LINE_NUMBERS_DEFAULT = False\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    pl.check_attribs(\n        element,\n        required_attribs=[\"params-name\"],\n        optional_attribs=[\n            \"no-highlight\",",
        "detail": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "documentation": {}
    },
    {
        "label": "COPY_CODE_BUTTON_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "description": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "peekOfCode": "COPY_CODE_BUTTON_DEFAULT = False\nSHOW_LINE_NUMBERS_DEFAULT = False\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    pl.check_attribs(\n        element,\n        required_attribs=[\"params-name\"],\n        optional_attribs=[\n            \"no-highlight\",\n            \"prefix\",",
        "detail": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "documentation": {}
    },
    {
        "label": "SHOW_LINE_NUMBERS_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "description": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "peekOfCode": "SHOW_LINE_NUMBERS_DEFAULT = False\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    pl.check_attribs(\n        element,\n        required_attribs=[\"params-name\"],\n        optional_attribs=[\n            \"no-highlight\",\n            \"prefix\",\n            \"suffix\",",
        "detail": "src.prairielearn.elements.pl-python-variable.pl-python-variable",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-question-panel.pl-question-panel",
        "description": "src.prairielearn.elements.pl-question-panel.pl-question-panel",
        "peekOfCode": "def prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    pl.check_attribs(element, required_attribs=[], optional_attribs=[])\ndef render(element_html: str, data: pl.QuestionData) -> str:\n    if data[\"panel\"] == \"question\":\n        element = lxml.html.fragment_fromstring(element_html)\n        return pl.inner_html(element)\n    return \"\"",
        "detail": "src.prairielearn.elements.pl-question-panel.pl-question-panel",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-question-panel.pl-question-panel",
        "description": "src.prairielearn.elements.pl-question-panel.pl-question-panel",
        "peekOfCode": "def render(element_html: str, data: pl.QuestionData) -> str:\n    if data[\"panel\"] == \"question\":\n        element = lxml.html.fragment_fromstring(element_html)\n        return pl.inner_html(element)\n    return \"\"",
        "detail": "src.prairielearn.elements.pl-question-panel.pl-question-panel",
        "documentation": {}
    },
    {
        "label": "Counter",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "description": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "peekOfCode": "class Counter(Enum):\n    NONE = \"none\"\n    CHARACTER = \"character\"\n    WORD = \"word\"\nclass OutputFormat(Enum):\n    HTML = \"html\"\n    MARKDOWN = \"markdown\"\nQUILL_THEME_DEFAULT = \"snow\"\nPLACEHOLDER_DEFAULT = \"Your answer here\"\nALLOW_BLANK_DEFAULT = False",
        "detail": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "documentation": {}
    },
    {
        "label": "OutputFormat",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "description": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "peekOfCode": "class OutputFormat(Enum):\n    HTML = \"html\"\n    MARKDOWN = \"markdown\"\nQUILL_THEME_DEFAULT = \"snow\"\nPLACEHOLDER_DEFAULT = \"Your answer here\"\nALLOW_BLANK_DEFAULT = False\nSOURCE_FILE_NAME_DEFAULT = None\nDIRECTORY_DEFAULT = \".\"\nMARKDOWN_SHORTCUTS_DEFAULT = True\ndef get_answer_name(file_name):",
        "detail": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "documentation": {}
    },
    {
        "label": "get_answer_name",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "description": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "peekOfCode": "def get_answer_name(file_name):\n    return \"_rich_text_editor_{0}\".format(\n        hashlib.sha1(file_name.encode(\"utf-8\")).hexdigest()\n    )\ndef element_inner_html(element):\n    return (element.text or \"\") + \"\".join(\n        [str(lxml.html.tostring(c), \"utf-8\") for c in element.iterchildren()]\n    )\ndef prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)",
        "detail": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "documentation": {}
    },
    {
        "label": "element_inner_html",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "description": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "peekOfCode": "def element_inner_html(element):\n    return (element.text or \"\") + \"\".join(\n        [str(lxml.html.tostring(c), \"utf-8\") for c in element.iterchildren()]\n    )\ndef prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"file-name\"]\n    optional_attribs = [\n        \"quill-theme\",\n        \"source-file-name\",",
        "detail": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "description": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "peekOfCode": "def prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"file-name\"]\n    optional_attribs = [\n        \"quill-theme\",\n        \"source-file-name\",\n        \"directory\",\n        \"placeholder\",\n        \"allow-blank\",\n        \"format\",",
        "detail": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "description": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "peekOfCode": "def render(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    file_name = pl.get_string_attrib(element, \"file-name\", \"\")\n    answer_name = get_answer_name(file_name)\n    quill_theme = pl.get_string_attrib(element, \"quill-theme\", QUILL_THEME_DEFAULT)\n    placeholder = pl.get_string_attrib(element, \"placeholder\", PLACEHOLDER_DEFAULT)\n    uuid = pl.get_uuid()\n    source_file_name = pl.get_string_attrib(\n        element, \"source-file-name\", SOURCE_FILE_NAME_DEFAULT\n    )",
        "detail": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "description": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "peekOfCode": "def parse(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    allow_blank = pl.get_boolean_attrib(element, \"allow-blank\", ALLOW_BLANK_DEFAULT)\n    file_name = pl.get_string_attrib(element, \"file-name\", \"\")\n    answer_name = get_answer_name(file_name)\n    # Get submitted answer or return parse_error if it does not exist\n    file_contents = data[\"submitted_answers\"].get(answer_name, None)\n    if not file_contents and not allow_blank:\n        pl.add_files_format_error(data, f\"No submitted answer for {file_name}\")\n        return",
        "detail": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "documentation": {}
    },
    {
        "label": "QUILL_THEME_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "description": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "peekOfCode": "QUILL_THEME_DEFAULT = \"snow\"\nPLACEHOLDER_DEFAULT = \"Your answer here\"\nALLOW_BLANK_DEFAULT = False\nSOURCE_FILE_NAME_DEFAULT = None\nDIRECTORY_DEFAULT = \".\"\nMARKDOWN_SHORTCUTS_DEFAULT = True\ndef get_answer_name(file_name):\n    return \"_rich_text_editor_{0}\".format(\n        hashlib.sha1(file_name.encode(\"utf-8\")).hexdigest()\n    )",
        "detail": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "documentation": {}
    },
    {
        "label": "PLACEHOLDER_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "description": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "peekOfCode": "PLACEHOLDER_DEFAULT = \"Your answer here\"\nALLOW_BLANK_DEFAULT = False\nSOURCE_FILE_NAME_DEFAULT = None\nDIRECTORY_DEFAULT = \".\"\nMARKDOWN_SHORTCUTS_DEFAULT = True\ndef get_answer_name(file_name):\n    return \"_rich_text_editor_{0}\".format(\n        hashlib.sha1(file_name.encode(\"utf-8\")).hexdigest()\n    )\ndef element_inner_html(element):",
        "detail": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "documentation": {}
    },
    {
        "label": "ALLOW_BLANK_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "description": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "peekOfCode": "ALLOW_BLANK_DEFAULT = False\nSOURCE_FILE_NAME_DEFAULT = None\nDIRECTORY_DEFAULT = \".\"\nMARKDOWN_SHORTCUTS_DEFAULT = True\ndef get_answer_name(file_name):\n    return \"_rich_text_editor_{0}\".format(\n        hashlib.sha1(file_name.encode(\"utf-8\")).hexdigest()\n    )\ndef element_inner_html(element):\n    return (element.text or \"\") + \"\".join(",
        "detail": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "documentation": {}
    },
    {
        "label": "SOURCE_FILE_NAME_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "description": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "peekOfCode": "SOURCE_FILE_NAME_DEFAULT = None\nDIRECTORY_DEFAULT = \".\"\nMARKDOWN_SHORTCUTS_DEFAULT = True\ndef get_answer_name(file_name):\n    return \"_rich_text_editor_{0}\".format(\n        hashlib.sha1(file_name.encode(\"utf-8\")).hexdigest()\n    )\ndef element_inner_html(element):\n    return (element.text or \"\") + \"\".join(\n        [str(lxml.html.tostring(c), \"utf-8\") for c in element.iterchildren()]",
        "detail": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "documentation": {}
    },
    {
        "label": "DIRECTORY_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "description": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "peekOfCode": "DIRECTORY_DEFAULT = \".\"\nMARKDOWN_SHORTCUTS_DEFAULT = True\ndef get_answer_name(file_name):\n    return \"_rich_text_editor_{0}\".format(\n        hashlib.sha1(file_name.encode(\"utf-8\")).hexdigest()\n    )\ndef element_inner_html(element):\n    return (element.text or \"\") + \"\".join(\n        [str(lxml.html.tostring(c), \"utf-8\") for c in element.iterchildren()]\n    )",
        "detail": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "documentation": {}
    },
    {
        "label": "MARKDOWN_SHORTCUTS_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "description": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "peekOfCode": "MARKDOWN_SHORTCUTS_DEFAULT = True\ndef get_answer_name(file_name):\n    return \"_rich_text_editor_{0}\".format(\n        hashlib.sha1(file_name.encode(\"utf-8\")).hexdigest()\n    )\ndef element_inner_html(element):\n    return (element.text or \"\") + \"\".join(\n        [str(lxml.html.tostring(c), \"utf-8\") for c in element.iterchildren()]\n    )\ndef prepare(element_html, data):",
        "detail": "src.prairielearn.elements.pl-rich-text-editor.pl-rich-text-editor",
        "documentation": {}
    },
    {
        "label": "DisplayType",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "description": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "peekOfCode": "class DisplayType(Enum):\n    INLINE = \"inline\"\n    BLOCK = \"block\"\nWEIGHT_DEFAULT = 1\nCORRECT_ANSWER_DEFAULT = None\nLABEL_DEFAULT = None\nSUFFIX_DEFAULT = None\nDISPLAY_DEFAULT = DisplayType.INLINE\nREMOVE_LEADING_TRAILING_DEFAULT = False\nREMOVE_SPACES_DEFAULT = False",
        "detail": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "description": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "peekOfCode": "def prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",\n        \"correct-answer\",\n        \"label\",\n        \"suffix\",\n        \"display\",\n        \"remove-leading-trailing\",",
        "detail": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "description": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "peekOfCode": "def render(element_html: str, data: pl.QuestionData) -> str:\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    label = pl.get_string_attrib(element, \"label\", LABEL_DEFAULT)\n    suffix = pl.get_string_attrib(element, \"suffix\", SUFFIX_DEFAULT)\n    display = pl.get_enum_attrib(element, \"display\", DisplayType, DISPLAY_DEFAULT)\n    remove_leading_trailing = pl.get_boolean_attrib(\n        element, \"remove-leading-trailing\", REMOVE_LEADING_TRAILING_DEFAULT\n    )\n    remove_spaces = pl.get_boolean_attrib(",
        "detail": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "description": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "peekOfCode": "def parse(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    # Get allow-blank option\n    allow_blank = pl.get_boolean_attrib(element, \"allow-blank\", ALLOW_BLANK_DEFAULT)\n    normalize_to_ascii = pl.get_boolean_attrib(\n        element, \"normalize-to-ascii\", NORMALIZE_TO_ASCII_DEFAULT\n    )\n    remove_spaces = pl.get_boolean_attrib(\n        element, \"remove-spaces\", REMOVE_SPACES_DEFAULT",
        "detail": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "documentation": {}
    },
    {
        "label": "grade",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "description": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "peekOfCode": "def grade(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    # Get weight\n    weight = pl.get_integer_attrib(element, \"weight\", WEIGHT_DEFAULT)\n    # Get remove-spaces option\n    remove_spaces = pl.get_boolean_attrib(\n        element, \"remove-spaces\", REMOVE_SPACES_DEFAULT\n    )\n    # Get remove-leading-trailing option",
        "detail": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "description": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "peekOfCode": "def test(element_html: str, data: pl.ElementTestData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    weight = pl.get_integer_attrib(element, \"weight\", WEIGHT_DEFAULT)\n    allow_blank = pl.get_boolean_attrib(element, \"allow-blank\", ALLOW_BLANK_DEFAULT)\n    # Get correct answer\n    a_tru = data[\"correct_answers\"][name]\n    # If correct answer is in a format generated by pl.to_json, convert it\n    # back to a standard type (otherwise, do nothing)\n    a_tru = pl.from_json(a_tru)",
        "detail": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "documentation": {}
    },
    {
        "label": "WEIGHT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "description": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "peekOfCode": "WEIGHT_DEFAULT = 1\nCORRECT_ANSWER_DEFAULT = None\nLABEL_DEFAULT = None\nSUFFIX_DEFAULT = None\nDISPLAY_DEFAULT = DisplayType.INLINE\nREMOVE_LEADING_TRAILING_DEFAULT = False\nREMOVE_SPACES_DEFAULT = False\nPLACEHOLDER_DEFAULT = None\nALLOW_BLANK_DEFAULT = False\nIGNORE_CASE_DEFAULT = False",
        "detail": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "documentation": {}
    },
    {
        "label": "CORRECT_ANSWER_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "description": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "peekOfCode": "CORRECT_ANSWER_DEFAULT = None\nLABEL_DEFAULT = None\nSUFFIX_DEFAULT = None\nDISPLAY_DEFAULT = DisplayType.INLINE\nREMOVE_LEADING_TRAILING_DEFAULT = False\nREMOVE_SPACES_DEFAULT = False\nPLACEHOLDER_DEFAULT = None\nALLOW_BLANK_DEFAULT = False\nIGNORE_CASE_DEFAULT = False\nSIZE_DEFAULT = 35",
        "detail": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "documentation": {}
    },
    {
        "label": "LABEL_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "description": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "peekOfCode": "LABEL_DEFAULT = None\nSUFFIX_DEFAULT = None\nDISPLAY_DEFAULT = DisplayType.INLINE\nREMOVE_LEADING_TRAILING_DEFAULT = False\nREMOVE_SPACES_DEFAULT = False\nPLACEHOLDER_DEFAULT = None\nALLOW_BLANK_DEFAULT = False\nIGNORE_CASE_DEFAULT = False\nSIZE_DEFAULT = 35\nSHOW_HELP_TEXT_DEFAULT = True",
        "detail": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "documentation": {}
    },
    {
        "label": "SUFFIX_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "description": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "peekOfCode": "SUFFIX_DEFAULT = None\nDISPLAY_DEFAULT = DisplayType.INLINE\nREMOVE_LEADING_TRAILING_DEFAULT = False\nREMOVE_SPACES_DEFAULT = False\nPLACEHOLDER_DEFAULT = None\nALLOW_BLANK_DEFAULT = False\nIGNORE_CASE_DEFAULT = False\nSIZE_DEFAULT = 35\nSHOW_HELP_TEXT_DEFAULT = True\nSHOW_SCORE_DEFAULT = True",
        "detail": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "documentation": {}
    },
    {
        "label": "DISPLAY_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "description": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "peekOfCode": "DISPLAY_DEFAULT = DisplayType.INLINE\nREMOVE_LEADING_TRAILING_DEFAULT = False\nREMOVE_SPACES_DEFAULT = False\nPLACEHOLDER_DEFAULT = None\nALLOW_BLANK_DEFAULT = False\nIGNORE_CASE_DEFAULT = False\nSIZE_DEFAULT = 35\nSHOW_HELP_TEXT_DEFAULT = True\nSHOW_SCORE_DEFAULT = True\nNORMALIZE_TO_ASCII_DEFAULT = False",
        "detail": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "documentation": {}
    },
    {
        "label": "REMOVE_LEADING_TRAILING_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "description": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "peekOfCode": "REMOVE_LEADING_TRAILING_DEFAULT = False\nREMOVE_SPACES_DEFAULT = False\nPLACEHOLDER_DEFAULT = None\nALLOW_BLANK_DEFAULT = False\nIGNORE_CASE_DEFAULT = False\nSIZE_DEFAULT = 35\nSHOW_HELP_TEXT_DEFAULT = True\nSHOW_SCORE_DEFAULT = True\nNORMALIZE_TO_ASCII_DEFAULT = False\nSTRING_INPUT_MUSTACHE_TEMPLATE_NAME = \"pl-string-input.mustache\"",
        "detail": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "documentation": {}
    },
    {
        "label": "REMOVE_SPACES_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "description": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "peekOfCode": "REMOVE_SPACES_DEFAULT = False\nPLACEHOLDER_DEFAULT = None\nALLOW_BLANK_DEFAULT = False\nIGNORE_CASE_DEFAULT = False\nSIZE_DEFAULT = 35\nSHOW_HELP_TEXT_DEFAULT = True\nSHOW_SCORE_DEFAULT = True\nNORMALIZE_TO_ASCII_DEFAULT = False\nSTRING_INPUT_MUSTACHE_TEMPLATE_NAME = \"pl-string-input.mustache\"\ndef prepare(element_html: str, data: pl.QuestionData) -> None:",
        "detail": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "documentation": {}
    },
    {
        "label": "PLACEHOLDER_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "description": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "peekOfCode": "PLACEHOLDER_DEFAULT = None\nALLOW_BLANK_DEFAULT = False\nIGNORE_CASE_DEFAULT = False\nSIZE_DEFAULT = 35\nSHOW_HELP_TEXT_DEFAULT = True\nSHOW_SCORE_DEFAULT = True\nNORMALIZE_TO_ASCII_DEFAULT = False\nSTRING_INPUT_MUSTACHE_TEMPLATE_NAME = \"pl-string-input.mustache\"\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)",
        "detail": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "documentation": {}
    },
    {
        "label": "ALLOW_BLANK_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "description": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "peekOfCode": "ALLOW_BLANK_DEFAULT = False\nIGNORE_CASE_DEFAULT = False\nSIZE_DEFAULT = 35\nSHOW_HELP_TEXT_DEFAULT = True\nSHOW_SCORE_DEFAULT = True\nNORMALIZE_TO_ASCII_DEFAULT = False\nSTRING_INPUT_MUSTACHE_TEMPLATE_NAME = \"pl-string-input.mustache\"\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]",
        "detail": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "documentation": {}
    },
    {
        "label": "IGNORE_CASE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "description": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "peekOfCode": "IGNORE_CASE_DEFAULT = False\nSIZE_DEFAULT = 35\nSHOW_HELP_TEXT_DEFAULT = True\nSHOW_SCORE_DEFAULT = True\nNORMALIZE_TO_ASCII_DEFAULT = False\nSTRING_INPUT_MUSTACHE_TEMPLATE_NAME = \"pl-string-input.mustache\"\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [",
        "detail": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "documentation": {}
    },
    {
        "label": "SIZE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "description": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "peekOfCode": "SIZE_DEFAULT = 35\nSHOW_HELP_TEXT_DEFAULT = True\nSHOW_SCORE_DEFAULT = True\nNORMALIZE_TO_ASCII_DEFAULT = False\nSTRING_INPUT_MUSTACHE_TEMPLATE_NAME = \"pl-string-input.mustache\"\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",",
        "detail": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "documentation": {}
    },
    {
        "label": "SHOW_HELP_TEXT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "description": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "peekOfCode": "SHOW_HELP_TEXT_DEFAULT = True\nSHOW_SCORE_DEFAULT = True\nNORMALIZE_TO_ASCII_DEFAULT = False\nSTRING_INPUT_MUSTACHE_TEMPLATE_NAME = \"pl-string-input.mustache\"\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",\n        \"correct-answer\",",
        "detail": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "documentation": {}
    },
    {
        "label": "SHOW_SCORE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "description": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "peekOfCode": "SHOW_SCORE_DEFAULT = True\nNORMALIZE_TO_ASCII_DEFAULT = False\nSTRING_INPUT_MUSTACHE_TEMPLATE_NAME = \"pl-string-input.mustache\"\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",\n        \"correct-answer\",\n        \"label\",",
        "detail": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "documentation": {}
    },
    {
        "label": "NORMALIZE_TO_ASCII_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "description": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "peekOfCode": "NORMALIZE_TO_ASCII_DEFAULT = False\nSTRING_INPUT_MUSTACHE_TEMPLATE_NAME = \"pl-string-input.mustache\"\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",\n        \"correct-answer\",\n        \"label\",\n        \"suffix\",",
        "detail": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "documentation": {}
    },
    {
        "label": "STRING_INPUT_MUSTACHE_TEMPLATE_NAME",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "description": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "peekOfCode": "STRING_INPUT_MUSTACHE_TEMPLATE_NAME = \"pl-string-input.mustache\"\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",\n        \"correct-answer\",\n        \"label\",\n        \"suffix\",\n        \"display\",",
        "detail": "src.prairielearn.elements.pl-string-input.pl-string-input",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-submission-panel.pl-submission-panel",
        "description": "src.prairielearn.elements.pl-submission-panel.pl-submission-panel",
        "peekOfCode": "def prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    pl.check_attribs(element, required_attribs=[], optional_attribs=[])\ndef render(element_html: str, data: pl.QuestionData) -> str:\n    if data[\"panel\"] == \"submission\":\n        element = lxml.html.fragment_fromstring(element_html)\n        return pl.inner_html(element)\n    return \"\"",
        "detail": "src.prairielearn.elements.pl-submission-panel.pl-submission-panel",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-submission-panel.pl-submission-panel",
        "description": "src.prairielearn.elements.pl-submission-panel.pl-submission-panel",
        "peekOfCode": "def render(element_html: str, data: pl.QuestionData) -> str:\n    if data[\"panel\"] == \"submission\":\n        element = lxml.html.fragment_fromstring(element_html)\n        return pl.inner_html(element)\n    return \"\"",
        "detail": "src.prairielearn.elements.pl-submission-panel.pl-submission-panel",
        "documentation": {}
    },
    {
        "label": "DisplayType",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "description": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "peekOfCode": "class DisplayType(Enum):\n    INLINE = \"inline\"\n    BLOCK = \"block\"\nWEIGHT_DEFAULT = 1\nVARIABLES_DEFAULT = None\nCUSTOM_FUNCTIONS_DEFAULT = None\nLABEL_DEFAULT = None\nSUFFIX_DEFAULT = None\nDISPLAY_DEFAULT = DisplayType.INLINE\nALLOW_COMPLEX_DEFAULT = False",
        "detail": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "description": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "peekOfCode": "def prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",\n        \"correct-answer\",\n        \"variables\",\n        \"label\",\n        \"display\",\n        \"allow-complex\",",
        "detail": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "description": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "peekOfCode": "def render(element_html: str, data: pl.QuestionData) -> str:\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    label = pl.get_string_attrib(element, \"label\", LABEL_DEFAULT)\n    suffix = pl.get_string_attrib(element, \"suffix\", SUFFIX_DEFAULT)\n    variables = phs.get_items_list(\n        pl.get_string_attrib(element, \"variables\", VARIABLES_DEFAULT)\n    )\n    custom_functions = phs.get_items_list(\n        pl.get_string_attrib(element, \"custom-functions\", CUSTOM_FUNCTIONS_DEFAULT)",
        "detail": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "description": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "peekOfCode": "def parse(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    variables = phs.get_items_list(\n        pl.get_string_attrib(element, \"variables\", VARIABLES_DEFAULT)\n    )\n    custom_functions = phs.get_items_list(\n        pl.get_string_attrib(element, \"custom-functions\", CUSTOM_FUNCTIONS_DEFAULT)\n    )\n    allow_complex = pl.get_boolean_attrib(",
        "detail": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "documentation": {}
    },
    {
        "label": "grade",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "description": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "peekOfCode": "def grade(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    variables = phs.get_items_list(\n        pl.get_string_attrib(element, \"variables\", VARIABLES_DEFAULT)\n    )\n    custom_functions = phs.get_items_list(\n        pl.get_string_attrib(element, \"custom-functions\", CUSTOM_FUNCTIONS_DEFAULT)\n    )\n    allow_complex = pl.get_boolean_attrib(",
        "detail": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "description": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "peekOfCode": "def test(element_html: str, data: pl.ElementTestData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    variables = phs.get_items_list(\n        pl.get_string_attrib(element, \"variables\", VARIABLES_DEFAULT)\n    )\n    custom_functions = phs.get_items_list(\n        pl.get_string_attrib(element, \"custom-functions\", CUSTOM_FUNCTIONS_DEFAULT)\n    )\n    allow_complex = pl.get_boolean_attrib(",
        "detail": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "documentation": {}
    },
    {
        "label": "WEIGHT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "description": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "peekOfCode": "WEIGHT_DEFAULT = 1\nVARIABLES_DEFAULT = None\nCUSTOM_FUNCTIONS_DEFAULT = None\nLABEL_DEFAULT = None\nSUFFIX_DEFAULT = None\nDISPLAY_DEFAULT = DisplayType.INLINE\nALLOW_COMPLEX_DEFAULT = False\nIMAGINARY_UNIT_FOR_DISPLAY_DEFAULT = \"i\"\nALLOW_TRIG_FUNCTIONS_DEFAULT = True\nSIZE_DEFAULT = 35",
        "detail": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "documentation": {}
    },
    {
        "label": "VARIABLES_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "description": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "peekOfCode": "VARIABLES_DEFAULT = None\nCUSTOM_FUNCTIONS_DEFAULT = None\nLABEL_DEFAULT = None\nSUFFIX_DEFAULT = None\nDISPLAY_DEFAULT = DisplayType.INLINE\nALLOW_COMPLEX_DEFAULT = False\nIMAGINARY_UNIT_FOR_DISPLAY_DEFAULT = \"i\"\nALLOW_TRIG_FUNCTIONS_DEFAULT = True\nSIZE_DEFAULT = 35\nSHOW_HELP_TEXT_DEFAULT = True",
        "detail": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "documentation": {}
    },
    {
        "label": "CUSTOM_FUNCTIONS_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "description": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "peekOfCode": "CUSTOM_FUNCTIONS_DEFAULT = None\nLABEL_DEFAULT = None\nSUFFIX_DEFAULT = None\nDISPLAY_DEFAULT = DisplayType.INLINE\nALLOW_COMPLEX_DEFAULT = False\nIMAGINARY_UNIT_FOR_DISPLAY_DEFAULT = \"i\"\nALLOW_TRIG_FUNCTIONS_DEFAULT = True\nSIZE_DEFAULT = 35\nSHOW_HELP_TEXT_DEFAULT = True\nALLOW_BLANK_DEFAULT = False",
        "detail": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "documentation": {}
    },
    {
        "label": "LABEL_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "description": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "peekOfCode": "LABEL_DEFAULT = None\nSUFFIX_DEFAULT = None\nDISPLAY_DEFAULT = DisplayType.INLINE\nALLOW_COMPLEX_DEFAULT = False\nIMAGINARY_UNIT_FOR_DISPLAY_DEFAULT = \"i\"\nALLOW_TRIG_FUNCTIONS_DEFAULT = True\nSIZE_DEFAULT = 35\nSHOW_HELP_TEXT_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = \"0\"",
        "detail": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "documentation": {}
    },
    {
        "label": "SUFFIX_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "description": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "peekOfCode": "SUFFIX_DEFAULT = None\nDISPLAY_DEFAULT = DisplayType.INLINE\nALLOW_COMPLEX_DEFAULT = False\nIMAGINARY_UNIT_FOR_DISPLAY_DEFAULT = \"i\"\nALLOW_TRIG_FUNCTIONS_DEFAULT = True\nSIZE_DEFAULT = 35\nSHOW_HELP_TEXT_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = \"0\"\nPLACEHOLDER_DEFAULT = \"symbolic expression\"",
        "detail": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "documentation": {}
    },
    {
        "label": "DISPLAY_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "description": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "peekOfCode": "DISPLAY_DEFAULT = DisplayType.INLINE\nALLOW_COMPLEX_DEFAULT = False\nIMAGINARY_UNIT_FOR_DISPLAY_DEFAULT = \"i\"\nALLOW_TRIG_FUNCTIONS_DEFAULT = True\nSIZE_DEFAULT = 35\nSHOW_HELP_TEXT_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = \"0\"\nPLACEHOLDER_DEFAULT = \"symbolic expression\"\nSHOW_SCORE_DEFAULT = True",
        "detail": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "documentation": {}
    },
    {
        "label": "ALLOW_COMPLEX_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "description": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "peekOfCode": "ALLOW_COMPLEX_DEFAULT = False\nIMAGINARY_UNIT_FOR_DISPLAY_DEFAULT = \"i\"\nALLOW_TRIG_FUNCTIONS_DEFAULT = True\nSIZE_DEFAULT = 35\nSHOW_HELP_TEXT_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = \"0\"\nPLACEHOLDER_DEFAULT = \"symbolic expression\"\nSHOW_SCORE_DEFAULT = True\nimport os",
        "detail": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "documentation": {}
    },
    {
        "label": "IMAGINARY_UNIT_FOR_DISPLAY_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "description": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "peekOfCode": "IMAGINARY_UNIT_FOR_DISPLAY_DEFAULT = \"i\"\nALLOW_TRIG_FUNCTIONS_DEFAULT = True\nSIZE_DEFAULT = 35\nSHOW_HELP_TEXT_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = \"0\"\nPLACEHOLDER_DEFAULT = \"symbolic expression\"\nSHOW_SCORE_DEFAULT = True\nimport os\ncurrent_module_path = os.path.abspath(__file__)",
        "detail": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "documentation": {}
    },
    {
        "label": "ALLOW_TRIG_FUNCTIONS_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "description": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "peekOfCode": "ALLOW_TRIG_FUNCTIONS_DEFAULT = True\nSIZE_DEFAULT = 35\nSHOW_HELP_TEXT_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = \"0\"\nPLACEHOLDER_DEFAULT = \"symbolic expression\"\nSHOW_SCORE_DEFAULT = True\nimport os\ncurrent_module_path = os.path.abspath(__file__)\nprint(current_module_path)",
        "detail": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "documentation": {}
    },
    {
        "label": "SIZE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "description": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "peekOfCode": "SIZE_DEFAULT = 35\nSHOW_HELP_TEXT_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = \"0\"\nPLACEHOLDER_DEFAULT = \"symbolic expression\"\nSHOW_SCORE_DEFAULT = True\nimport os\ncurrent_module_path = os.path.abspath(__file__)\nprint(current_module_path)\nSYMBOLIC_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_path,\"..\",\"pl-symbolic-input.mustache\")",
        "detail": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "documentation": {}
    },
    {
        "label": "SHOW_HELP_TEXT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "description": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "peekOfCode": "SHOW_HELP_TEXT_DEFAULT = True\nALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = \"0\"\nPLACEHOLDER_DEFAULT = \"symbolic expression\"\nSHOW_SCORE_DEFAULT = True\nimport os\ncurrent_module_path = os.path.abspath(__file__)\nprint(current_module_path)\nSYMBOLIC_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_path,\"..\",\"pl-symbolic-input.mustache\")\ndef prepare(element_html: str, data: pl.QuestionData) -> None:",
        "detail": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "documentation": {}
    },
    {
        "label": "ALLOW_BLANK_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "description": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "peekOfCode": "ALLOW_BLANK_DEFAULT = False\nBLANK_VALUE_DEFAULT = \"0\"\nPLACEHOLDER_DEFAULT = \"symbolic expression\"\nSHOW_SCORE_DEFAULT = True\nimport os\ncurrent_module_path = os.path.abspath(__file__)\nprint(current_module_path)\nSYMBOLIC_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_path,\"..\",\"pl-symbolic-input.mustache\")\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)",
        "detail": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "documentation": {}
    },
    {
        "label": "BLANK_VALUE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "description": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "peekOfCode": "BLANK_VALUE_DEFAULT = \"0\"\nPLACEHOLDER_DEFAULT = \"symbolic expression\"\nSHOW_SCORE_DEFAULT = True\nimport os\ncurrent_module_path = os.path.abspath(__file__)\nprint(current_module_path)\nSYMBOLIC_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_path,\"..\",\"pl-symbolic-input.mustache\")\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]",
        "detail": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "documentation": {}
    },
    {
        "label": "PLACEHOLDER_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "description": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "peekOfCode": "PLACEHOLDER_DEFAULT = \"symbolic expression\"\nSHOW_SCORE_DEFAULT = True\nimport os\ncurrent_module_path = os.path.abspath(__file__)\nprint(current_module_path)\nSYMBOLIC_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_path,\"..\",\"pl-symbolic-input.mustache\")\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [",
        "detail": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "documentation": {}
    },
    {
        "label": "SHOW_SCORE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "description": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "peekOfCode": "SHOW_SCORE_DEFAULT = True\nimport os\ncurrent_module_path = os.path.abspath(__file__)\nprint(current_module_path)\nSYMBOLIC_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_path,\"..\",\"pl-symbolic-input.mustache\")\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",",
        "detail": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "documentation": {}
    },
    {
        "label": "current_module_path",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "description": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "peekOfCode": "current_module_path = os.path.abspath(__file__)\nprint(current_module_path)\nSYMBOLIC_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_path,\"..\",\"pl-symbolic-input.mustache\")\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",\n        \"correct-answer\",\n        \"variables\",",
        "detail": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "documentation": {}
    },
    {
        "label": "SYMBOLIC_INPUT_MUSTACHE_TEMPLATE_NAME",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "description": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "peekOfCode": "SYMBOLIC_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_path,\"..\",\"pl-symbolic-input.mustache\")\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",\n        \"correct-answer\",\n        \"variables\",\n        \"label\",\n        \"display\",",
        "detail": "src.prairielearn.elements.pl-symbolic-input.pl-symbolic-input",
        "documentation": {}
    },
    {
        "label": "check_tags",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-template.pl-template",
        "description": "src.prairielearn.elements.pl-template.pl-template",
        "peekOfCode": "def check_tags(element_html: str) -> None:\n    element_list = cast(list, lxml.html.fragments_fromstring(element_html))\n    # First element can be a string, remove since there's nothing to check.\n    if isinstance(element_list[0], str):\n        element_list.pop(0)\n    for e in chain.from_iterable(element.iter() for element in element_list):\n        if e.tag is not lxml.etree.Comment:\n            is_tag_invald = (\n                e.tag.startswith(\"pl-\") and e.tag not in ALLOWED_PL_TAGS\n            ) or e.tag == \"markdown\"",
        "detail": "src.prairielearn.elements.pl-template.pl-template",
        "documentation": {}
    },
    {
        "label": "get_file_path",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-template.pl-template",
        "description": "src.prairielearn.elements.pl-template.pl-template",
        "peekOfCode": "def get_file_path(element: lxml.html.HtmlElement, data: pl.QuestionData) -> str:\n    parent_dir_dict = {\n        \"question\": \"question_path\",\n        \"clientFilesQuestion\": \"client_files_question_path\",\n        \"clientFilesCourse\": \"client_files_course_path\",\n        \"serverFilesCourse\": \"server_files_course_path\",\n        \"courseExtensions\": \"course_extensions_path\",\n    }\n    dir_choice = pl.get_string_attrib(\n        element,",
        "detail": "src.prairielearn.elements.pl-template.pl-template",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-template.pl-template",
        "description": "src.prairielearn.elements.pl-template.pl-template",
        "peekOfCode": "def render(element_html: str, data: pl.QuestionData) -> str:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"file-name\"]\n    optional_attribs = [\n        \"directory\",\n        \"log-variable-warnings\",\n        \"log-tag-warnings\",\n    ]\n    pl.check_attribs(element, required_attribs, optional_attribs)\n    # Load in entries from data dict and add uuid.",
        "detail": "src.prairielearn.elements.pl-template.pl-template",
        "documentation": {}
    },
    {
        "label": "LOG_VARIABLE_WARNINGS_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-template.pl-template",
        "description": "src.prairielearn.elements.pl-template.pl-template",
        "peekOfCode": "LOG_VARIABLE_WARNINGS_DEFAULT = False\nTRIM_WHITESPACE_DEFAULT = True\nDIRECTORY_CHOICE_DEFAULT = \"serverFilesCourse\"\nLOG_TAG_WARNINGS_DEFAULT = True\n# These elements should be display only\nALLOWED_PL_TAGS = frozenset(\n    (\n        \"pl-template\",\n        \"pl-variable\",\n        \"pl-code\",",
        "detail": "src.prairielearn.elements.pl-template.pl-template",
        "documentation": {}
    },
    {
        "label": "TRIM_WHITESPACE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-template.pl-template",
        "description": "src.prairielearn.elements.pl-template.pl-template",
        "peekOfCode": "TRIM_WHITESPACE_DEFAULT = True\nDIRECTORY_CHOICE_DEFAULT = \"serverFilesCourse\"\nLOG_TAG_WARNINGS_DEFAULT = True\n# These elements should be display only\nALLOWED_PL_TAGS = frozenset(\n    (\n        \"pl-template\",\n        \"pl-variable\",\n        \"pl-code\",\n        \"pl-card\",",
        "detail": "src.prairielearn.elements.pl-template.pl-template",
        "documentation": {}
    },
    {
        "label": "DIRECTORY_CHOICE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-template.pl-template",
        "description": "src.prairielearn.elements.pl-template.pl-template",
        "peekOfCode": "DIRECTORY_CHOICE_DEFAULT = \"serverFilesCourse\"\nLOG_TAG_WARNINGS_DEFAULT = True\n# These elements should be display only\nALLOWED_PL_TAGS = frozenset(\n    (\n        \"pl-template\",\n        \"pl-variable\",\n        \"pl-code\",\n        \"pl-card\",\n        \"pl-figure\",",
        "detail": "src.prairielearn.elements.pl-template.pl-template",
        "documentation": {}
    },
    {
        "label": "LOG_TAG_WARNINGS_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-template.pl-template",
        "description": "src.prairielearn.elements.pl-template.pl-template",
        "peekOfCode": "LOG_TAG_WARNINGS_DEFAULT = True\n# These elements should be display only\nALLOWED_PL_TAGS = frozenset(\n    (\n        \"pl-template\",\n        \"pl-variable\",\n        \"pl-code\",\n        \"pl-card\",\n        \"pl-figure\",\n        \"pl-file-download\",",
        "detail": "src.prairielearn.elements.pl-template.pl-template",
        "documentation": {}
    },
    {
        "label": "ALLOWED_PL_TAGS",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-template.pl-template",
        "description": "src.prairielearn.elements.pl-template.pl-template",
        "peekOfCode": "ALLOWED_PL_TAGS = frozenset(\n    (\n        \"pl-template\",\n        \"pl-variable\",\n        \"pl-code\",\n        \"pl-card\",\n        \"pl-figure\",\n        \"pl-file-download\",\n        \"pl-matrix-latex\",\n    )",
        "detail": "src.prairielearn.elements.pl-template.pl-template",
        "documentation": {}
    },
    {
        "label": "DATA_ENTRIES_TO_COPY",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-template.pl-template",
        "description": "src.prairielearn.elements.pl-template.pl-template",
        "peekOfCode": "DATA_ENTRIES_TO_COPY = (\"params\",)\ndef check_tags(element_html: str) -> None:\n    element_list = cast(list, lxml.html.fragments_fromstring(element_html))\n    # First element can be a string, remove since there's nothing to check.\n    if isinstance(element_list[0], str):\n        element_list.pop(0)\n    for e in chain.from_iterable(element.iter() for element in element_list):\n        if e.tag is not lxml.etree.Comment:\n            is_tag_invald = (\n                e.tag.startswith(\"pl-\") and e.tag not in ALLOWED_PL_TAGS",
        "detail": "src.prairielearn.elements.pl-template.pl-template",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "description": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "peekOfCode": "def prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\n        \"answer-name\",  # key for 'submitted_answers' and 'true_answers'\n    ]\n    optional_attribs = [\n        \"body-position\",  # [x, y, z]\n        \"body-orientation\",  # [x, y, z, w] or [roll, pitch, yaw] or rotation matrix (3x3 ndarray) or exponential coordinates [wx, wy, wz]\n        \"camera-position\",  # [x, y, z] - camera is z up and points at origin of space frame\n        \"body-cantranslate\",  # true (default) or false",
        "detail": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "documentation": {}
    },
    {
        "label": "get_objects",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "description": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "peekOfCode": "def get_objects(element, data):\n    obj_list = []\n    for child in element:\n        is_stl = child.tag in [\"pl-threejs-stl\", \"pl_threejs_stl\"]\n        is_txt = child.tag in [\"pl-threejs-txt\", \"pl_threejs_txt\"]\n        if not (is_stl or is_txt):\n            continue\n        # Type-specific check and get (stl)\n        if is_stl:\n            # Attributes",
        "detail": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "description": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "peekOfCode": "def render(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    answer_name = pl.get_string_attrib(element, \"answer-name\")\n    uuid = pl.get_uuid()\n    body_position = get_position(\n        element, \"body-position\", default=BODY_POSITION_DEFAULT\n    )\n    body_orientation = get_orientation(\n        element, \"body-orientation\", BODY_ORIENTATION_DEFAULT\n    )",
        "detail": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "description": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "peekOfCode": "def parse(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answer-name\")\n    # Get submitted answer or return parse_error if it does not exist\n    a_sub = data[\"submitted_answers\"].get(name, None)\n    if a_sub is None:\n        data[\"format_errors\"][name] = \"No submitted answer.\"\n        data[\"submitted_answers\"][name] = None\n        return\n    # Convert from json to dict or return parse error on failure (if there is",
        "detail": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "documentation": {}
    },
    {
        "label": "grade",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "description": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "peekOfCode": "def grade(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    answer_name = pl.get_string_attrib(element, \"answer-name\")\n    # Check if this element is intended to produce a grade\n    will_be_graded = pl.get_boolean_attrib(element, \"grade\", GRADE_DEFAULT)\n    if not will_be_graded:\n        return\n    # Get weight\n    weight = pl.get_integer_attrib(element, \"weight\", 1)\n    # Get submitted answer (the \"state\")",
        "detail": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "documentation": {}
    },
    {
        "label": "parse_correct_answer",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "description": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "peekOfCode": "def parse_correct_answer(f, a):\n    if f == \"homogeneous\":\n        try:\n            T = np.array(a, dtype=np.float64)\n            if T.shape == (4, 4):\n                R = T[0:3, 0:3]\n                p = T[0:3, 3:4]\n                return np.reshape(p, (3,)), pyquaternion.Quaternion(matrix=R)\n            else:\n                raise ValueError()",
        "detail": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "documentation": {}
    },
    {
        "label": "dict_to_b64",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "description": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "peekOfCode": "def dict_to_b64(d):\n    return base64.b64encode(json.dumps(d, allow_nan=False).encode(\"utf-8\")).decode()\ndef b64_to_dict(b64):\n    return json.loads(base64.b64decode(b64).decode())\ndef get_file_url(element, data):\n    # Get file name or raise exception if one does not exist\n    file_name = pl.get_string_attrib(element, \"file-name\")\n    # Get directory (default is clientFilesQuestion)\n    file_directory = pl.get_string_attrib(\n        element, \"file-directory\", \"clientFilesQuestion\"",
        "detail": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "documentation": {}
    },
    {
        "label": "b64_to_dict",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "description": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "peekOfCode": "def b64_to_dict(b64):\n    return json.loads(base64.b64decode(b64).decode())\ndef get_file_url(element, data):\n    # Get file name or raise exception if one does not exist\n    file_name = pl.get_string_attrib(element, \"file-name\")\n    # Get directory (default is clientFilesQuestion)\n    file_directory = pl.get_string_attrib(\n        element, \"file-directory\", \"clientFilesQuestion\"\n    )\n    # Get base url, which depends on the directory",
        "detail": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "documentation": {}
    },
    {
        "label": "get_file_url",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "description": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "peekOfCode": "def get_file_url(element, data):\n    # Get file name or raise exception if one does not exist\n    file_name = pl.get_string_attrib(element, \"file-name\")\n    # Get directory (default is clientFilesQuestion)\n    file_directory = pl.get_string_attrib(\n        element, \"file-directory\", \"clientFilesQuestion\"\n    )\n    # Get base url, which depends on the directory\n    if file_directory == \"clientFilesQuestion\":\n        base_url = data[\"options\"][\"client_files_question_url\"]",
        "detail": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "documentation": {}
    },
    {
        "label": "get_orientation",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "description": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "peekOfCode": "def get_orientation(element, name_orientation, name_format):\n    s = pl.get_string_attrib(element, name_orientation, None)\n    if s is None:\n        return [0, 0, 0, 1]\n    f = pl.get_string_attrib(element, name_format, \"rpy\")\n    if f == \"rpy\":\n        try:\n            rpy = np.array(json.loads(s), dtype=np.float64)\n            if rpy.shape == (3,):\n                qx = pyquaternion.Quaternion(axis=[1, 0, 0], degrees=rpy[0])",
        "detail": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "documentation": {}
    },
    {
        "label": "get_position",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "description": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "peekOfCode": "def get_position(element, name_position, default=[0, 0, 0], must_be_nonzero=False):\n    s = pl.get_string_attrib(element, name_position, None)\n    if s is None:\n        return default\n    try:\n        p = np.array(json.loads(s), dtype=np.float64)\n        if p.shape == (3,):\n            if must_be_nonzero and np.allclose(p, np.array([0, 0, 0])):\n                raise ValueError(\n                    'attribute \"{:s}\" must be non-zero'.format(name_position)",
        "detail": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "documentation": {}
    },
    {
        "label": "BODY_POSITION_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "description": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "peekOfCode": "BODY_POSITION_DEFAULT = [0, 0, 0]\nBODY_ORIENTATION_DEFAULT = \"body-pose-format\"\nCAMERA_POSITION_DEFAULT = [5, 2, 2]\nBODY_CANTRANSLATE_DEFAULT = True\nBODY_CANROTATE_DEFAULT = True\nCAMERA_CANMOVE_DEFAULT = True\nANSWER_POSE_FORMAT_DEFAULT = \"rpy\"\nTEXT_POSE_FORMAT_DEFAULT = \"matrix\"\nSHOW_POSE_IN_QUESTION_DEFAULT = True\nSHOW_POSE_IN_CORRECT_ANSWER_DEFAULT = True",
        "detail": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "documentation": {}
    },
    {
        "label": "BODY_ORIENTATION_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "description": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "peekOfCode": "BODY_ORIENTATION_DEFAULT = \"body-pose-format\"\nCAMERA_POSITION_DEFAULT = [5, 2, 2]\nBODY_CANTRANSLATE_DEFAULT = True\nBODY_CANROTATE_DEFAULT = True\nCAMERA_CANMOVE_DEFAULT = True\nANSWER_POSE_FORMAT_DEFAULT = \"rpy\"\nTEXT_POSE_FORMAT_DEFAULT = \"matrix\"\nSHOW_POSE_IN_QUESTION_DEFAULT = True\nSHOW_POSE_IN_CORRECT_ANSWER_DEFAULT = True\nSHOW_POSE_IN_SUBMITTED_ANSWER_DEFAULT = True",
        "detail": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "documentation": {}
    },
    {
        "label": "CAMERA_POSITION_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "description": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "peekOfCode": "CAMERA_POSITION_DEFAULT = [5, 2, 2]\nBODY_CANTRANSLATE_DEFAULT = True\nBODY_CANROTATE_DEFAULT = True\nCAMERA_CANMOVE_DEFAULT = True\nANSWER_POSE_FORMAT_DEFAULT = \"rpy\"\nTEXT_POSE_FORMAT_DEFAULT = \"matrix\"\nSHOW_POSE_IN_QUESTION_DEFAULT = True\nSHOW_POSE_IN_CORRECT_ANSWER_DEFAULT = True\nSHOW_POSE_IN_SUBMITTED_ANSWER_DEFAULT = True\nTOL_TRANSLATION_DEFAULT = 0.5",
        "detail": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "documentation": {}
    },
    {
        "label": "BODY_CANTRANSLATE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "description": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "peekOfCode": "BODY_CANTRANSLATE_DEFAULT = True\nBODY_CANROTATE_DEFAULT = True\nCAMERA_CANMOVE_DEFAULT = True\nANSWER_POSE_FORMAT_DEFAULT = \"rpy\"\nTEXT_POSE_FORMAT_DEFAULT = \"matrix\"\nSHOW_POSE_IN_QUESTION_DEFAULT = True\nSHOW_POSE_IN_CORRECT_ANSWER_DEFAULT = True\nSHOW_POSE_IN_SUBMITTED_ANSWER_DEFAULT = True\nTOL_TRANSLATION_DEFAULT = 0.5\nTOL_ROTATION_DEFAULT = 5",
        "detail": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "documentation": {}
    },
    {
        "label": "BODY_CANROTATE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "description": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "peekOfCode": "BODY_CANROTATE_DEFAULT = True\nCAMERA_CANMOVE_DEFAULT = True\nANSWER_POSE_FORMAT_DEFAULT = \"rpy\"\nTEXT_POSE_FORMAT_DEFAULT = \"matrix\"\nSHOW_POSE_IN_QUESTION_DEFAULT = True\nSHOW_POSE_IN_CORRECT_ANSWER_DEFAULT = True\nSHOW_POSE_IN_SUBMITTED_ANSWER_DEFAULT = True\nTOL_TRANSLATION_DEFAULT = 0.5\nTOL_ROTATION_DEFAULT = 5\nGRADE_DEFAULT = True",
        "detail": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "documentation": {}
    },
    {
        "label": "CAMERA_CANMOVE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "description": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "peekOfCode": "CAMERA_CANMOVE_DEFAULT = True\nANSWER_POSE_FORMAT_DEFAULT = \"rpy\"\nTEXT_POSE_FORMAT_DEFAULT = \"matrix\"\nSHOW_POSE_IN_QUESTION_DEFAULT = True\nSHOW_POSE_IN_CORRECT_ANSWER_DEFAULT = True\nSHOW_POSE_IN_SUBMITTED_ANSWER_DEFAULT = True\nTOL_TRANSLATION_DEFAULT = 0.5\nTOL_ROTATION_DEFAULT = 5\nGRADE_DEFAULT = True\ndef prepare(element_html, data):",
        "detail": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "documentation": {}
    },
    {
        "label": "ANSWER_POSE_FORMAT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "description": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "peekOfCode": "ANSWER_POSE_FORMAT_DEFAULT = \"rpy\"\nTEXT_POSE_FORMAT_DEFAULT = \"matrix\"\nSHOW_POSE_IN_QUESTION_DEFAULT = True\nSHOW_POSE_IN_CORRECT_ANSWER_DEFAULT = True\nSHOW_POSE_IN_SUBMITTED_ANSWER_DEFAULT = True\nTOL_TRANSLATION_DEFAULT = 0.5\nTOL_ROTATION_DEFAULT = 5\nGRADE_DEFAULT = True\ndef prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)",
        "detail": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "documentation": {}
    },
    {
        "label": "TEXT_POSE_FORMAT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "description": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "peekOfCode": "TEXT_POSE_FORMAT_DEFAULT = \"matrix\"\nSHOW_POSE_IN_QUESTION_DEFAULT = True\nSHOW_POSE_IN_CORRECT_ANSWER_DEFAULT = True\nSHOW_POSE_IN_SUBMITTED_ANSWER_DEFAULT = True\nTOL_TRANSLATION_DEFAULT = 0.5\nTOL_ROTATION_DEFAULT = 5\nGRADE_DEFAULT = True\ndef prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [",
        "detail": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "documentation": {}
    },
    {
        "label": "SHOW_POSE_IN_QUESTION_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "description": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "peekOfCode": "SHOW_POSE_IN_QUESTION_DEFAULT = True\nSHOW_POSE_IN_CORRECT_ANSWER_DEFAULT = True\nSHOW_POSE_IN_SUBMITTED_ANSWER_DEFAULT = True\nTOL_TRANSLATION_DEFAULT = 0.5\nTOL_ROTATION_DEFAULT = 5\nGRADE_DEFAULT = True\ndef prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\n        \"answer-name\",  # key for 'submitted_answers' and 'true_answers'",
        "detail": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "documentation": {}
    },
    {
        "label": "SHOW_POSE_IN_CORRECT_ANSWER_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "description": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "peekOfCode": "SHOW_POSE_IN_CORRECT_ANSWER_DEFAULT = True\nSHOW_POSE_IN_SUBMITTED_ANSWER_DEFAULT = True\nTOL_TRANSLATION_DEFAULT = 0.5\nTOL_ROTATION_DEFAULT = 5\nGRADE_DEFAULT = True\ndef prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\n        \"answer-name\",  # key for 'submitted_answers' and 'true_answers'\n    ]",
        "detail": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "documentation": {}
    },
    {
        "label": "SHOW_POSE_IN_SUBMITTED_ANSWER_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "description": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "peekOfCode": "SHOW_POSE_IN_SUBMITTED_ANSWER_DEFAULT = True\nTOL_TRANSLATION_DEFAULT = 0.5\nTOL_ROTATION_DEFAULT = 5\nGRADE_DEFAULT = True\ndef prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\n        \"answer-name\",  # key for 'submitted_answers' and 'true_answers'\n    ]\n    optional_attribs = [",
        "detail": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "documentation": {}
    },
    {
        "label": "TOL_TRANSLATION_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "description": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "peekOfCode": "TOL_TRANSLATION_DEFAULT = 0.5\nTOL_ROTATION_DEFAULT = 5\nGRADE_DEFAULT = True\ndef prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\n        \"answer-name\",  # key for 'submitted_answers' and 'true_answers'\n    ]\n    optional_attribs = [\n        \"body-position\",  # [x, y, z]",
        "detail": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "documentation": {}
    },
    {
        "label": "TOL_ROTATION_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "description": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "peekOfCode": "TOL_ROTATION_DEFAULT = 5\nGRADE_DEFAULT = True\ndef prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\n        \"answer-name\",  # key for 'submitted_answers' and 'true_answers'\n    ]\n    optional_attribs = [\n        \"body-position\",  # [x, y, z]\n        \"body-orientation\",  # [x, y, z, w] or [roll, pitch, yaw] or rotation matrix (3x3 ndarray) or exponential coordinates [wx, wy, wz]",
        "detail": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "documentation": {}
    },
    {
        "label": "GRADE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "description": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "peekOfCode": "GRADE_DEFAULT = True\ndef prepare(element_html, data):\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\n        \"answer-name\",  # key for 'submitted_answers' and 'true_answers'\n    ]\n    optional_attribs = [\n        \"body-position\",  # [x, y, z]\n        \"body-orientation\",  # [x, y, z, w] or [roll, pitch, yaw] or rotation matrix (3x3 ndarray) or exponential coordinates [wx, wy, wz]\n        \"camera-position\",  # [x, y, z] - camera is z up and points at origin of space frame",
        "detail": "src.prairielearn.elements.pl-threejs.pl-threejs",
        "documentation": {}
    },
    {
        "label": "DisplayType",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "description": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "peekOfCode": "class DisplayType(Enum):\n    INLINE = \"inline\"\n    BLOCK = \"block\"\nclass GradingMode(Enum):\n    ONLY_UNITS = 1\n    EXACT_UNITS = 2\n    WITH_UNITS = 3\nGRADING_MODE_DEFAULT = GradingMode.WITH_UNITS\nWEIGHT_DEFAULT = 1\nCORRECT_ANSWER_DEFAULT = None",
        "detail": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "documentation": {}
    },
    {
        "label": "GradingMode",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "description": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "peekOfCode": "class GradingMode(Enum):\n    ONLY_UNITS = 1\n    EXACT_UNITS = 2\n    WITH_UNITS = 3\nGRADING_MODE_DEFAULT = GradingMode.WITH_UNITS\nWEIGHT_DEFAULT = 1\nCORRECT_ANSWER_DEFAULT = None\nLABEL_DEFAULT = None\nSUFFIX_DEFAULT = None\nDISPLAY_DEFAULT = DisplayType.INLINE",
        "detail": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "documentation": {}
    },
    {
        "label": "get_with_units_atol",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "description": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "peekOfCode": "def get_with_units_atol(\n    element: lxml.html.HtmlElement, data: pl.QuestionData, ureg: UnitRegistry\n) -> str:\n    \"\"\"Returns the atol string for use in the \"with-units\" grading mode.\"\"\"\n    if pl.has_attrib(element, \"atol\"):\n        return pl.get_string_attrib(element, \"atol\")\n    name = pl.get_string_attrib(element, \"answers-name\")\n    correct_answer = data[\"correct_answers\"].get(name)\n    correct_answer_units = str(ureg.Quantity(correct_answer).units)\n    return f\"{ATOL_DEFAULT} {correct_answer_units}\"",
        "detail": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "description": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "peekOfCode": "def prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = [\"answers-name\"]\n    optional_attribs = [\n        \"weight\",\n        \"correct-answer\",\n        \"custom-format\",\n        \"label\",\n        \"suffix\",\n        \"display\",",
        "detail": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "description": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "peekOfCode": "def render(element_html: str, data: pl.QuestionData) -> str:\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    label = pl.get_string_attrib(element, \"label\", LABEL_DEFAULT)\n    suffix = pl.get_string_attrib(element, \"suffix\", SUFFIX_DEFAULT)\n    display = pl.get_enum_attrib(element, \"display\", DisplayType, DISPLAY_DEFAULT)\n    size = pl.get_integer_attrib(element, \"size\", SIZE_DEFAULT)\n    comparison = pl.get_enum_attrib(\n        element, \"comparison\", uu.ComparisonType, COMPARISON_DEFAULT\n    )",
        "detail": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "description": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "peekOfCode": "def parse(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    allow_blank = pl.get_boolean_attrib(element, \"allow-blank\", ALLOW_BLANK_DEFAULT)\n    only_units = (\n        pl.get_enum_attrib(element, \"grading-mode\", GradingMode, GRADING_MODE_DEFAULT)\n        is GradingMode.ONLY_UNITS\n    )\n    # retrieves submitted answer\n    a_sub = data[\"submitted_answers\"].get(name, None)",
        "detail": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "documentation": {}
    },
    {
        "label": "grade",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "description": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "peekOfCode": "def grade(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    weight = pl.get_integer_attrib(element, \"weight\", WEIGHT_DEFAULT)\n    grading_mode = pl.get_enum_attrib(\n        element, \"grading-mode\", GradingMode, GRADING_MODE_DEFAULT\n    )\n    a_tru = data[\"correct_answers\"].get(name, None)\n    if a_tru is None:\n        return",
        "detail": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "description": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "peekOfCode": "def test(element_html: str, data: pl.ElementTestData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    weight = pl.get_integer_attrib(element, \"weight\", WEIGHT_DEFAULT)\n    a_tru = data[\"correct_answers\"][name]\n    grading_mode = pl.get_enum_attrib(\n        element, \"grading-mode\", GradingMode, GRADING_MODE_DEFAULT\n    )\n    ureg = pl.get_unit_registry()\n    result = data[\"test_type\"]",
        "detail": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "documentation": {}
    },
    {
        "label": "prepare_display_string",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "description": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "peekOfCode": "def prepare_display_string(\n    quantity: Any, custom_format: Optional[str], grading_mode: GradingMode\n) -> str:\n    if grading_mode is GradingMode.ONLY_UNITS:\n        return str(quantity.units)\n    elif custom_format is None:\n        return str(quantity)\n    # Display reference solution with the given custom format\n    return f\"{quantity:{custom_format}}\"",
        "detail": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "documentation": {}
    },
    {
        "label": "pl_order_blocks_path",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "description": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "peekOfCode": "pl_order_blocks_path = os.path.join(os.getcwd(), 'src','prairielearn', 'elements', 'pl-units-input')\nprint(pl_order_blocks_path)\nsys.path.append(pl_order_blocks_path)\nimport chevron\nimport lxml.html\nfrom prairielearn.python import prairielearn as pl\nimport unit_utils as uu\nfrom pint import UnitRegistry, errors\nfrom typing_extensions import assert_never\nimport os",
        "detail": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "documentation": {}
    },
    {
        "label": "current_module_path",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "description": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "peekOfCode": "current_module_path = os.path.abspath(__file__)\n# Get the directory of the current module\ncurrent_module_dir = os.path.dirname(current_module_path)\nUNITS_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir,\"pl-units-input.mustache\")\nclass DisplayType(Enum):\n    INLINE = \"inline\"\n    BLOCK = \"block\"\nclass GradingMode(Enum):\n    ONLY_UNITS = 1\n    EXACT_UNITS = 2",
        "detail": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "documentation": {}
    },
    {
        "label": "current_module_dir",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "description": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "peekOfCode": "current_module_dir = os.path.dirname(current_module_path)\nUNITS_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir,\"pl-units-input.mustache\")\nclass DisplayType(Enum):\n    INLINE = \"inline\"\n    BLOCK = \"block\"\nclass GradingMode(Enum):\n    ONLY_UNITS = 1\n    EXACT_UNITS = 2\n    WITH_UNITS = 3\nGRADING_MODE_DEFAULT = GradingMode.WITH_UNITS",
        "detail": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "documentation": {}
    },
    {
        "label": "UNITS_INPUT_MUSTACHE_TEMPLATE_NAME",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "description": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "peekOfCode": "UNITS_INPUT_MUSTACHE_TEMPLATE_NAME = os.path.join(current_module_dir,\"pl-units-input.mustache\")\nclass DisplayType(Enum):\n    INLINE = \"inline\"\n    BLOCK = \"block\"\nclass GradingMode(Enum):\n    ONLY_UNITS = 1\n    EXACT_UNITS = 2\n    WITH_UNITS = 3\nGRADING_MODE_DEFAULT = GradingMode.WITH_UNITS\nWEIGHT_DEFAULT = 1",
        "detail": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "documentation": {}
    },
    {
        "label": "GRADING_MODE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "description": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "peekOfCode": "GRADING_MODE_DEFAULT = GradingMode.WITH_UNITS\nWEIGHT_DEFAULT = 1\nCORRECT_ANSWER_DEFAULT = None\nLABEL_DEFAULT = None\nSUFFIX_DEFAULT = None\nDISPLAY_DEFAULT = DisplayType.INLINE\nALLOW_BLANK_DEFAULT = False\nCOMPARISON_DEFAULT = uu.ComparisonType.RELABS\nRTOL_DEFAULT = 1e-2\nATOL_DEFAULT = \"1e-8\"",
        "detail": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "documentation": {}
    },
    {
        "label": "WEIGHT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "description": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "peekOfCode": "WEIGHT_DEFAULT = 1\nCORRECT_ANSWER_DEFAULT = None\nLABEL_DEFAULT = None\nSUFFIX_DEFAULT = None\nDISPLAY_DEFAULT = DisplayType.INLINE\nALLOW_BLANK_DEFAULT = False\nCOMPARISON_DEFAULT = uu.ComparisonType.RELABS\nRTOL_DEFAULT = 1e-2\nATOL_DEFAULT = \"1e-8\"\nDIGITS_DEFAULT = 2",
        "detail": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "documentation": {}
    },
    {
        "label": "CORRECT_ANSWER_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "description": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "peekOfCode": "CORRECT_ANSWER_DEFAULT = None\nLABEL_DEFAULT = None\nSUFFIX_DEFAULT = None\nDISPLAY_DEFAULT = DisplayType.INLINE\nALLOW_BLANK_DEFAULT = False\nCOMPARISON_DEFAULT = uu.ComparisonType.RELABS\nRTOL_DEFAULT = 1e-2\nATOL_DEFAULT = \"1e-8\"\nDIGITS_DEFAULT = 2\nSIZE_DEFAULT = 35",
        "detail": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "documentation": {}
    },
    {
        "label": "LABEL_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "description": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "peekOfCode": "LABEL_DEFAULT = None\nSUFFIX_DEFAULT = None\nDISPLAY_DEFAULT = DisplayType.INLINE\nALLOW_BLANK_DEFAULT = False\nCOMPARISON_DEFAULT = uu.ComparisonType.RELABS\nRTOL_DEFAULT = 1e-2\nATOL_DEFAULT = \"1e-8\"\nDIGITS_DEFAULT = 2\nSIZE_DEFAULT = 35\nSHOW_HELP_TEXT_DEFAULT = True",
        "detail": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "documentation": {}
    },
    {
        "label": "SUFFIX_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "description": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "peekOfCode": "SUFFIX_DEFAULT = None\nDISPLAY_DEFAULT = DisplayType.INLINE\nALLOW_BLANK_DEFAULT = False\nCOMPARISON_DEFAULT = uu.ComparisonType.RELABS\nRTOL_DEFAULT = 1e-2\nATOL_DEFAULT = \"1e-8\"\nDIGITS_DEFAULT = 2\nSIZE_DEFAULT = 35\nSHOW_HELP_TEXT_DEFAULT = True\nMAGNITUDE_PARTIAL_CREDIT_DEFAULT = None",
        "detail": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "documentation": {}
    },
    {
        "label": "DISPLAY_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "description": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "peekOfCode": "DISPLAY_DEFAULT = DisplayType.INLINE\nALLOW_BLANK_DEFAULT = False\nCOMPARISON_DEFAULT = uu.ComparisonType.RELABS\nRTOL_DEFAULT = 1e-2\nATOL_DEFAULT = \"1e-8\"\nDIGITS_DEFAULT = 2\nSIZE_DEFAULT = 35\nSHOW_HELP_TEXT_DEFAULT = True\nMAGNITUDE_PARTIAL_CREDIT_DEFAULT = None\nALLOW_FEEDBACK_DEFAULT = True",
        "detail": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "documentation": {}
    },
    {
        "label": "ALLOW_BLANK_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "description": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "peekOfCode": "ALLOW_BLANK_DEFAULT = False\nCOMPARISON_DEFAULT = uu.ComparisonType.RELABS\nRTOL_DEFAULT = 1e-2\nATOL_DEFAULT = \"1e-8\"\nDIGITS_DEFAULT = 2\nSIZE_DEFAULT = 35\nSHOW_HELP_TEXT_DEFAULT = True\nMAGNITUDE_PARTIAL_CREDIT_DEFAULT = None\nALLOW_FEEDBACK_DEFAULT = True\nCUSTOM_FORMAT_DEFAULT = None",
        "detail": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "documentation": {}
    },
    {
        "label": "COMPARISON_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "description": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "peekOfCode": "COMPARISON_DEFAULT = uu.ComparisonType.RELABS\nRTOL_DEFAULT = 1e-2\nATOL_DEFAULT = \"1e-8\"\nDIGITS_DEFAULT = 2\nSIZE_DEFAULT = 35\nSHOW_HELP_TEXT_DEFAULT = True\nMAGNITUDE_PARTIAL_CREDIT_DEFAULT = None\nALLOW_FEEDBACK_DEFAULT = True\nCUSTOM_FORMAT_DEFAULT = None\nSHOW_SCORE_DEFAULT = True",
        "detail": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "documentation": {}
    },
    {
        "label": "RTOL_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "description": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "peekOfCode": "RTOL_DEFAULT = 1e-2\nATOL_DEFAULT = \"1e-8\"\nDIGITS_DEFAULT = 2\nSIZE_DEFAULT = 35\nSHOW_HELP_TEXT_DEFAULT = True\nMAGNITUDE_PARTIAL_CREDIT_DEFAULT = None\nALLOW_FEEDBACK_DEFAULT = True\nCUSTOM_FORMAT_DEFAULT = None\nSHOW_SCORE_DEFAULT = True\ndef get_with_units_atol(",
        "detail": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "documentation": {}
    },
    {
        "label": "ATOL_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "description": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "peekOfCode": "ATOL_DEFAULT = \"1e-8\"\nDIGITS_DEFAULT = 2\nSIZE_DEFAULT = 35\nSHOW_HELP_TEXT_DEFAULT = True\nMAGNITUDE_PARTIAL_CREDIT_DEFAULT = None\nALLOW_FEEDBACK_DEFAULT = True\nCUSTOM_FORMAT_DEFAULT = None\nSHOW_SCORE_DEFAULT = True\ndef get_with_units_atol(\n    element: lxml.html.HtmlElement, data: pl.QuestionData, ureg: UnitRegistry",
        "detail": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "documentation": {}
    },
    {
        "label": "DIGITS_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "description": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "peekOfCode": "DIGITS_DEFAULT = 2\nSIZE_DEFAULT = 35\nSHOW_HELP_TEXT_DEFAULT = True\nMAGNITUDE_PARTIAL_CREDIT_DEFAULT = None\nALLOW_FEEDBACK_DEFAULT = True\nCUSTOM_FORMAT_DEFAULT = None\nSHOW_SCORE_DEFAULT = True\ndef get_with_units_atol(\n    element: lxml.html.HtmlElement, data: pl.QuestionData, ureg: UnitRegistry\n) -> str:",
        "detail": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "documentation": {}
    },
    {
        "label": "SIZE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "description": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "peekOfCode": "SIZE_DEFAULT = 35\nSHOW_HELP_TEXT_DEFAULT = True\nMAGNITUDE_PARTIAL_CREDIT_DEFAULT = None\nALLOW_FEEDBACK_DEFAULT = True\nCUSTOM_FORMAT_DEFAULT = None\nSHOW_SCORE_DEFAULT = True\ndef get_with_units_atol(\n    element: lxml.html.HtmlElement, data: pl.QuestionData, ureg: UnitRegistry\n) -> str:\n    \"\"\"Returns the atol string for use in the \"with-units\" grading mode.\"\"\"",
        "detail": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "documentation": {}
    },
    {
        "label": "SHOW_HELP_TEXT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "description": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "peekOfCode": "SHOW_HELP_TEXT_DEFAULT = True\nMAGNITUDE_PARTIAL_CREDIT_DEFAULT = None\nALLOW_FEEDBACK_DEFAULT = True\nCUSTOM_FORMAT_DEFAULT = None\nSHOW_SCORE_DEFAULT = True\ndef get_with_units_atol(\n    element: lxml.html.HtmlElement, data: pl.QuestionData, ureg: UnitRegistry\n) -> str:\n    \"\"\"Returns the atol string for use in the \"with-units\" grading mode.\"\"\"\n    if pl.has_attrib(element, \"atol\"):",
        "detail": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "documentation": {}
    },
    {
        "label": "MAGNITUDE_PARTIAL_CREDIT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "description": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "peekOfCode": "MAGNITUDE_PARTIAL_CREDIT_DEFAULT = None\nALLOW_FEEDBACK_DEFAULT = True\nCUSTOM_FORMAT_DEFAULT = None\nSHOW_SCORE_DEFAULT = True\ndef get_with_units_atol(\n    element: lxml.html.HtmlElement, data: pl.QuestionData, ureg: UnitRegistry\n) -> str:\n    \"\"\"Returns the atol string for use in the \"with-units\" grading mode.\"\"\"\n    if pl.has_attrib(element, \"atol\"):\n        return pl.get_string_attrib(element, \"atol\")",
        "detail": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "documentation": {}
    },
    {
        "label": "ALLOW_FEEDBACK_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "description": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "peekOfCode": "ALLOW_FEEDBACK_DEFAULT = True\nCUSTOM_FORMAT_DEFAULT = None\nSHOW_SCORE_DEFAULT = True\ndef get_with_units_atol(\n    element: lxml.html.HtmlElement, data: pl.QuestionData, ureg: UnitRegistry\n) -> str:\n    \"\"\"Returns the atol string for use in the \"with-units\" grading mode.\"\"\"\n    if pl.has_attrib(element, \"atol\"):\n        return pl.get_string_attrib(element, \"atol\")\n    name = pl.get_string_attrib(element, \"answers-name\")",
        "detail": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "documentation": {}
    },
    {
        "label": "CUSTOM_FORMAT_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "description": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "peekOfCode": "CUSTOM_FORMAT_DEFAULT = None\nSHOW_SCORE_DEFAULT = True\ndef get_with_units_atol(\n    element: lxml.html.HtmlElement, data: pl.QuestionData, ureg: UnitRegistry\n) -> str:\n    \"\"\"Returns the atol string for use in the \"with-units\" grading mode.\"\"\"\n    if pl.has_attrib(element, \"atol\"):\n        return pl.get_string_attrib(element, \"atol\")\n    name = pl.get_string_attrib(element, \"answers-name\")\n    correct_answer = data[\"correct_answers\"].get(name)",
        "detail": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "documentation": {}
    },
    {
        "label": "SHOW_SCORE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "description": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "peekOfCode": "SHOW_SCORE_DEFAULT = True\ndef get_with_units_atol(\n    element: lxml.html.HtmlElement, data: pl.QuestionData, ureg: UnitRegistry\n) -> str:\n    \"\"\"Returns the atol string for use in the \"with-units\" grading mode.\"\"\"\n    if pl.has_attrib(element, \"atol\"):\n        return pl.get_string_attrib(element, \"atol\")\n    name = pl.get_string_attrib(element, \"answers-name\")\n    correct_answer = data[\"correct_answers\"].get(name)\n    correct_answer_units = str(ureg.Quantity(correct_answer).units)",
        "detail": "src.prairielearn.elements.pl-units-input.pl-units-input",
        "documentation": {}
    },
    {
        "label": "ureg",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-units-input.units_utils_test",
        "description": "src.prairielearn.elements.pl-units-input.units_utils_test",
        "peekOfCode": "def ureg() -> UnitRegistry:\n    return UnitRegistry()\n@pytest.mark.parametrize(\n    \"a_true, a_sub, expected_grade\",\n    [\n        (\"m\", \"m\", True),\n        (\"m\", \"meter\", True),\n        (\"m\", \"meters\", True),\n        (\"ft\", \"foot\", True),\n        (\"ft\", \"feet\", True),",
        "detail": "src.prairielearn.elements.pl-units-input.units_utils_test",
        "documentation": {}
    },
    {
        "label": "test_only_units_grading_fn",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-units-input.units_utils_test",
        "description": "src.prairielearn.elements.pl-units-input.units_utils_test",
        "peekOfCode": "def test_only_units_grading_fn(\n    ureg: UnitRegistry, a_true: str, a_sub: str, expected_grade: bool\n) -> None:\n    grading_fn = uu.get_only_units_grading_fn(ureg=ureg, correct_ans=a_true)\n    score, _ = grading_fn(a_sub)\n    assert score == expected_grade\n@pytest.mark.parametrize(\n    \"a_true, a_sub, rtol, atol, expected_grade\",\n    [\n        (\"1m\", \"1 meter\", 0.0, \"1cm\", True),",
        "detail": "src.prairielearn.elements.pl-units-input.units_utils_test",
        "documentation": {}
    },
    {
        "label": "test_with_units_grading_fn",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-units-input.units_utils_test",
        "description": "src.prairielearn.elements.pl-units-input.units_utils_test",
        "peekOfCode": "def test_with_units_grading_fn(\n    ureg: UnitRegistry,\n    a_true: str,\n    a_sub: str,\n    rtol: float,\n    atol: str,\n    expected_grade: bool,\n) -> None:\n    grading_fn = uu.get_with_units_grading_fn(\n        ureg=ureg, correct_ans=a_true, rtol=rtol, atol=atol",
        "detail": "src.prairielearn.elements.pl-units-input.units_utils_test",
        "documentation": {}
    },
    {
        "label": "test_exact_units_grading_fn",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-units-input.units_utils_test",
        "description": "src.prairielearn.elements.pl-units-input.units_utils_test",
        "peekOfCode": "def test_exact_units_grading_fn(\n    ureg: UnitRegistry,\n    a_true: str,\n    partial_credit: Optional[float],\n    a_sub: str,\n    expected_grade: float,\n) -> None:\n    grading_fn = uu.get_exact_units_grading_fn(\n        ureg=ureg,\n        correct_ans=a_true,",
        "detail": "src.prairielearn.elements.pl-units-input.units_utils_test",
        "documentation": {}
    },
    {
        "label": "test_is_numberless",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-units-input.units_utils_test",
        "description": "src.prairielearn.elements.pl-units-input.units_utils_test",
        "peekOfCode": "def test_is_numberless(ureg: UnitRegistry, a_sub: str, expected_result: bool) -> None:\n    assert expected_result == uu.is_numberless(a_sub, ureg.Quantity(a_sub))",
        "detail": "src.prairielearn.elements.pl-units-input.units_utils_test",
        "documentation": {}
    },
    {
        "label": "ComparisonType",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-units-input.unit_utils",
        "description": "src.prairielearn.elements.pl-units-input.unit_utils",
        "peekOfCode": "class ComparisonType(Enum):\n    RELABS = \"relabs\"\n    SIGFIG = \"sigfig\"\n    EXACT = \"exact\"\n    DECDIG = \"decdig\"\ndef get_only_units_grading_fn(\n    *, ureg: UnitRegistry, correct_ans: str\n) -> Callable[[str], Tuple[bool, Optional[str]]]:\n    \"\"\"Returns the grading function used for units only grading mode.\"\"\"\n    parsed_correct_ans = ureg.Quantity(correct_ans)",
        "detail": "src.prairielearn.elements.pl-units-input.unit_utils",
        "documentation": {}
    },
    {
        "label": "get_only_units_grading_fn",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-units-input.unit_utils",
        "description": "src.prairielearn.elements.pl-units-input.unit_utils",
        "peekOfCode": "def get_only_units_grading_fn(\n    *, ureg: UnitRegistry, correct_ans: str\n) -> Callable[[str], Tuple[bool, Optional[str]]]:\n    \"\"\"Returns the grading function used for units only grading mode.\"\"\"\n    parsed_correct_ans = ureg.Quantity(correct_ans)\n    def grade_only_units(submitted_ans: str) -> Tuple[bool, Optional[str]]:\n        parsed_submission = ureg.Quantity(submitted_ans)\n        if parsed_correct_ans.units == parsed_submission.units:\n            return True, None\n        return False, INCORRECT_FEEDBACK",
        "detail": "src.prairielearn.elements.pl-units-input.unit_utils",
        "documentation": {}
    },
    {
        "label": "get_exact_units_grading_fn",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-units-input.unit_utils",
        "description": "src.prairielearn.elements.pl-units-input.unit_utils",
        "peekOfCode": "def get_exact_units_grading_fn(\n    *,\n    ureg: UnitRegistry,\n    correct_ans: str,\n    comparison: ComparisonType,\n    magnitude_partial_credit: Optional[float],\n    digits: int,\n    rtol: float,\n    atol: str,\n) -> Callable[[str], Tuple[float, Optional[str]]]:",
        "detail": "src.prairielearn.elements.pl-units-input.unit_utils",
        "documentation": {}
    },
    {
        "label": "get_with_units_grading_fn",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-units-input.unit_utils",
        "description": "src.prairielearn.elements.pl-units-input.unit_utils",
        "peekOfCode": "def get_with_units_grading_fn(\n    *, ureg: UnitRegistry, correct_ans: str, rtol: float, atol: str\n) -> Callable[[str], Tuple[bool, Optional[str]]]:\n    # Assume atol and correct answer have same dimensionality, checked in prepare method\n    correct_ans_base_unit = ureg.Quantity(correct_ans).to_base_units()\n    parsed_atol = ureg.Quantity(atol).to_base_units()\n    def grade_with_units(submitted_ans: str) -> Tuple[bool, Optional[str]]:\n        # will return no error, assuming parse() catches all of them\n        parsed_sub_base_unit = ureg.Quantity(submitted_ans).to_base_units()\n        if not correct_ans_base_unit.check(parsed_sub_base_unit.dimensionality):",
        "detail": "src.prairielearn.elements.pl-units-input.unit_utils",
        "documentation": {}
    },
    {
        "label": "is_numberless",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-units-input.unit_utils",
        "description": "src.prairielearn.elements.pl-units-input.unit_utils",
        "peekOfCode": "def is_numberless(a_sub: str, a_sub_parsed: Any) -> bool:\n    return \"1\" not in a_sub and a_sub_parsed.magnitude == 1",
        "detail": "src.prairielearn.elements.pl-units-input.unit_utils",
        "documentation": {}
    },
    {
        "label": "CORRECT_UNITS_INCORRECT_MAGNITUDE_FEEDBACK",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-units-input.unit_utils",
        "description": "src.prairielearn.elements.pl-units-input.unit_utils",
        "peekOfCode": "CORRECT_UNITS_INCORRECT_MAGNITUDE_FEEDBACK = (\n    \"Your answer has correct units, but incorrect magnitude.\"\n)\nINCORRECT_UNITS_CORRECT_MAGNITUDE_FEEDBACK = (\n    \"Your answer has correct magnitude, but incorrect units.\"\n)\nINCORRECT_UNITS_AND_MAGNITUDE_FEEDBACK = (\n    \"Your answer has incorrect units and magnitude.\"\n)\nINCORRECT_FEEDBACK = \"Your answer is incorrect.\"",
        "detail": "src.prairielearn.elements.pl-units-input.unit_utils",
        "documentation": {}
    },
    {
        "label": "INCORRECT_UNITS_CORRECT_MAGNITUDE_FEEDBACK",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-units-input.unit_utils",
        "description": "src.prairielearn.elements.pl-units-input.unit_utils",
        "peekOfCode": "INCORRECT_UNITS_CORRECT_MAGNITUDE_FEEDBACK = (\n    \"Your answer has correct magnitude, but incorrect units.\"\n)\nINCORRECT_UNITS_AND_MAGNITUDE_FEEDBACK = (\n    \"Your answer has incorrect units and magnitude.\"\n)\nINCORRECT_FEEDBACK = \"Your answer is incorrect.\"\nclass ComparisonType(Enum):\n    RELABS = \"relabs\"\n    SIGFIG = \"sigfig\"",
        "detail": "src.prairielearn.elements.pl-units-input.unit_utils",
        "documentation": {}
    },
    {
        "label": "INCORRECT_UNITS_AND_MAGNITUDE_FEEDBACK",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-units-input.unit_utils",
        "description": "src.prairielearn.elements.pl-units-input.unit_utils",
        "peekOfCode": "INCORRECT_UNITS_AND_MAGNITUDE_FEEDBACK = (\n    \"Your answer has incorrect units and magnitude.\"\n)\nINCORRECT_FEEDBACK = \"Your answer is incorrect.\"\nclass ComparisonType(Enum):\n    RELABS = \"relabs\"\n    SIGFIG = \"sigfig\"\n    EXACT = \"exact\"\n    DECDIG = \"decdig\"\ndef get_only_units_grading_fn(",
        "detail": "src.prairielearn.elements.pl-units-input.unit_utils",
        "documentation": {}
    },
    {
        "label": "INCORRECT_FEEDBACK",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-units-input.unit_utils",
        "description": "src.prairielearn.elements.pl-units-input.unit_utils",
        "peekOfCode": "INCORRECT_FEEDBACK = \"Your answer is incorrect.\"\nclass ComparisonType(Enum):\n    RELABS = \"relabs\"\n    SIGFIG = \"sigfig\"\n    EXACT = \"exact\"\n    DECDIG = \"decdig\"\ndef get_only_units_grading_fn(\n    *, ureg: UnitRegistry, correct_ans: str\n) -> Callable[[str], Tuple[bool, Optional[str]]]:\n    \"\"\"Returns the grading function used for units only grading mode.\"\"\"",
        "detail": "src.prairielearn.elements.pl-units-input.unit_utils",
        "documentation": {}
    },
    {
        "label": "TabType",
        "kind": 6,
        "importPath": "src.prairielearn.elements.pl-variable-output.pl-variable-output",
        "description": "src.prairielearn.elements.pl-variable-output.pl-variable-output",
        "peekOfCode": "class TabType(Enum):\n    MATLAB = 1\n    MATHEMATICA = 2\n    PYTHON = 3\n    R = 4\n    SYMPY = 5\nDIGITS_DEFAULT = 2\nSHOW_MATLAB_DEFAULT = True\nSHOW_MATHEMATICA_DEFAULT = True\nSHOW_PYTHON_DEFAULT = True",
        "detail": "src.prairielearn.elements.pl-variable-output.pl-variable-output",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-variable-output.pl-variable-output",
        "description": "src.prairielearn.elements.pl-variable-output.pl-variable-output",
        "peekOfCode": "def prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = []\n    optional_attribs = [\n        \"digits\",\n        \"default-tab\",\n        \"show-matlab\",\n        \"show-mathematica\",\n        \"show-python\",\n        \"show-r\",",
        "detail": "src.prairielearn.elements.pl-variable-output.pl-variable-output",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-variable-output.pl-variable-output",
        "description": "src.prairielearn.elements.pl-variable-output.pl-variable-output",
        "peekOfCode": "def render(element_html: str, data: pl.QuestionData) -> str:\n    element = lxml.html.fragment_fromstring(element_html)\n    digits = pl.get_integer_attrib(element, \"digits\", DIGITS_DEFAULT)\n    show_matlab = pl.get_boolean_attrib(element, \"show-matlab\", SHOW_MATLAB_DEFAULT)\n    show_mathematica = pl.get_boolean_attrib(\n        element, \"show-mathematica\", SHOW_MATHEMATICA_DEFAULT\n    )\n    show_python = pl.get_boolean_attrib(element, \"show-python\", SHOW_PYTHON_DEFAULT)\n    show_r = pl.get_boolean_attrib(element, \"show-r\", SHOW_R_DEFAULT)\n    show_sympy = pl.get_boolean_attrib(element, \"show-sympy\", SHOW_SYMPY_DEFAULT)",
        "detail": "src.prairielearn.elements.pl-variable-output.pl-variable-output",
        "documentation": {}
    },
    {
        "label": "DIGITS_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-variable-output.pl-variable-output",
        "description": "src.prairielearn.elements.pl-variable-output.pl-variable-output",
        "peekOfCode": "DIGITS_DEFAULT = 2\nSHOW_MATLAB_DEFAULT = True\nSHOW_MATHEMATICA_DEFAULT = True\nSHOW_PYTHON_DEFAULT = True\nSHOW_R_DEFAULT = True\nSHOW_SYMPY_DEFAULT = True\nDEFAULT_TAB_DEFAULT = TabType.MATLAB\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = []",
        "detail": "src.prairielearn.elements.pl-variable-output.pl-variable-output",
        "documentation": {}
    },
    {
        "label": "SHOW_MATLAB_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-variable-output.pl-variable-output",
        "description": "src.prairielearn.elements.pl-variable-output.pl-variable-output",
        "peekOfCode": "SHOW_MATLAB_DEFAULT = True\nSHOW_MATHEMATICA_DEFAULT = True\nSHOW_PYTHON_DEFAULT = True\nSHOW_R_DEFAULT = True\nSHOW_SYMPY_DEFAULT = True\nDEFAULT_TAB_DEFAULT = TabType.MATLAB\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = []\n    optional_attribs = [",
        "detail": "src.prairielearn.elements.pl-variable-output.pl-variable-output",
        "documentation": {}
    },
    {
        "label": "SHOW_MATHEMATICA_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-variable-output.pl-variable-output",
        "description": "src.prairielearn.elements.pl-variable-output.pl-variable-output",
        "peekOfCode": "SHOW_MATHEMATICA_DEFAULT = True\nSHOW_PYTHON_DEFAULT = True\nSHOW_R_DEFAULT = True\nSHOW_SYMPY_DEFAULT = True\nDEFAULT_TAB_DEFAULT = TabType.MATLAB\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = []\n    optional_attribs = [\n        \"digits\",",
        "detail": "src.prairielearn.elements.pl-variable-output.pl-variable-output",
        "documentation": {}
    },
    {
        "label": "SHOW_PYTHON_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-variable-output.pl-variable-output",
        "description": "src.prairielearn.elements.pl-variable-output.pl-variable-output",
        "peekOfCode": "SHOW_PYTHON_DEFAULT = True\nSHOW_R_DEFAULT = True\nSHOW_SYMPY_DEFAULT = True\nDEFAULT_TAB_DEFAULT = TabType.MATLAB\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = []\n    optional_attribs = [\n        \"digits\",\n        \"default-tab\",",
        "detail": "src.prairielearn.elements.pl-variable-output.pl-variable-output",
        "documentation": {}
    },
    {
        "label": "SHOW_R_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-variable-output.pl-variable-output",
        "description": "src.prairielearn.elements.pl-variable-output.pl-variable-output",
        "peekOfCode": "SHOW_R_DEFAULT = True\nSHOW_SYMPY_DEFAULT = True\nDEFAULT_TAB_DEFAULT = TabType.MATLAB\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = []\n    optional_attribs = [\n        \"digits\",\n        \"default-tab\",\n        \"show-matlab\",",
        "detail": "src.prairielearn.elements.pl-variable-output.pl-variable-output",
        "documentation": {}
    },
    {
        "label": "SHOW_SYMPY_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-variable-output.pl-variable-output",
        "description": "src.prairielearn.elements.pl-variable-output.pl-variable-output",
        "peekOfCode": "SHOW_SYMPY_DEFAULT = True\nDEFAULT_TAB_DEFAULT = TabType.MATLAB\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = []\n    optional_attribs = [\n        \"digits\",\n        \"default-tab\",\n        \"show-matlab\",\n        \"show-mathematica\",",
        "detail": "src.prairielearn.elements.pl-variable-output.pl-variable-output",
        "documentation": {}
    },
    {
        "label": "DEFAULT_TAB_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-variable-output.pl-variable-output",
        "description": "src.prairielearn.elements.pl-variable-output.pl-variable-output",
        "peekOfCode": "DEFAULT_TAB_DEFAULT = TabType.MATLAB\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = []\n    optional_attribs = [\n        \"digits\",\n        \"default-tab\",\n        \"show-matlab\",\n        \"show-mathematica\",\n        \"show-python\",",
        "detail": "src.prairielearn.elements.pl-variable-output.pl-variable-output",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-variable-score.pl-variable-score",
        "description": "src.prairielearn.elements.pl-variable-score.pl-variable-score",
        "peekOfCode": "def prepare(element_html, data):\n    if not use_pl_variable_score:\n        return\n    element = lxml.html.fragment_fromstring(element_html)\n    pl.check_attribs(element, required_attribs=[\"answers-name\"], optional_attribs=[])\ndef render(element_html, data):\n    if not use_pl_variable_score:\n        return \"\"\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")",
        "detail": "src.prairielearn.elements.pl-variable-score.pl-variable-score",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-variable-score.pl-variable-score",
        "description": "src.prairielearn.elements.pl-variable-score.pl-variable-score",
        "peekOfCode": "def render(element_html, data):\n    if not use_pl_variable_score:\n        return \"\"\n    element = lxml.html.fragment_fromstring(element_html)\n    name = pl.get_string_attrib(element, \"answers-name\")\n    if data[\"panel\"] == \"answer\":\n        return \"\"\n    partial_score = data[\"partial_scores\"].get(name, {\"score\": None, \"feedback\": None})\n    score = partial_score.get(\"score\", None)\n    feedback = partial_score.get(\"feedback\", None)",
        "detail": "src.prairielearn.elements.pl-variable-score.pl-variable-score",
        "documentation": {}
    },
    {
        "label": "use_pl_variable_score",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-variable-score.pl-variable-score",
        "description": "src.prairielearn.elements.pl-variable-score.pl-variable-score",
        "peekOfCode": "use_pl_variable_score = False\ndef prepare(element_html, data):\n    if not use_pl_variable_score:\n        return\n    element = lxml.html.fragment_fromstring(element_html)\n    pl.check_attribs(element, required_attribs=[\"answers-name\"], optional_attribs=[])\ndef render(element_html, data):\n    if not use_pl_variable_score:\n        return \"\"\n    element = lxml.html.fragment_fromstring(element_html)",
        "detail": "src.prairielearn.elements.pl-variable-score.pl-variable-score",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-workspace.pl-workspace",
        "description": "src.prairielearn.elements.pl-workspace.pl-workspace",
        "peekOfCode": "def render(element_html: str, data: pl.QuestionData) -> str:\n    if data[\"panel\"] != \"question\":\n        return \"\"\n    # Get workspace url\n    workspace_url = data[\"options\"].get(\"workspace_url\")\n    if workspace_url is None:\n        raise ValueError(\n            \"Workspace URL not found. Did you remember to set the workspace options?\"\n        )\n    # Create and return html",
        "detail": "src.prairielearn.elements.pl-workspace.pl-workspace",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-workspace.pl-workspace",
        "description": "src.prairielearn.elements.pl-workspace.pl-workspace",
        "peekOfCode": "def parse(element_html: str, data: pl.QuestionData) -> None:\n    workspace_required_file_names = data[\"params\"].get(\n        \"_workspace_required_file_names\", []\n    )\n    submitted_file_names = [\n        f.get(\"name\", \"\") for f in data[\"submitted_answers\"].get(\"_files\", [])\n    ]\n    missing_files = [\n        r for r in workspace_required_file_names if r not in submitted_file_names\n    ]",
        "detail": "src.prairielearn.elements.pl-workspace.pl-workspace",
        "documentation": {}
    },
    {
        "label": "prepare",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-xss-safe.pl-xss-safe",
        "description": "src.prairielearn.elements.pl-xss-safe.pl-xss-safe",
        "peekOfCode": "def prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = []\n    optional_attribs = [\n        \"source-file-name\",\n        \"submitted-file-name\",\n        \"contents\",\n        \"language\",\n    ]\n    pl.check_attribs(element, required_attribs, optional_attribs)",
        "detail": "src.prairielearn.elements.pl-xss-safe.pl-xss-safe",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "src.prairielearn.elements.pl-xss-safe.pl-xss-safe",
        "description": "src.prairielearn.elements.pl-xss-safe.pl-xss-safe",
        "peekOfCode": "def render(element_html: str, data: pl.QuestionData) -> str:\n    element = lxml.html.fragment_fromstring(element_html)\n    source_file_name = pl.get_string_attrib(\n        element, \"source-file-name\", SOURCE_FILE_NAME_DEFAULT\n    )\n    submitted_file_name = pl.get_string_attrib(\n        element, \"submitted-file-name\", SUBMITTED_FILE_NAME_DEFAULT\n    )\n    contents = pl.get_string_attrib(element, \"contents\", CONTENTS_DEFAULT)\n    if source_file_name is not None:",
        "detail": "src.prairielearn.elements.pl-xss-safe.pl-xss-safe",
        "documentation": {}
    },
    {
        "label": "SOURCE_FILE_NAME_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-xss-safe.pl-xss-safe",
        "description": "src.prairielearn.elements.pl-xss-safe.pl-xss-safe",
        "peekOfCode": "SOURCE_FILE_NAME_DEFAULT = None\nSUBMITTED_FILE_NAME_DEFAULT = None\nCONTENTS_DEFAULT = None\nLANGUAGE_DEFAULT = \"html\"\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = []\n    optional_attribs = [\n        \"source-file-name\",\n        \"submitted-file-name\",",
        "detail": "src.prairielearn.elements.pl-xss-safe.pl-xss-safe",
        "documentation": {}
    },
    {
        "label": "SUBMITTED_FILE_NAME_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-xss-safe.pl-xss-safe",
        "description": "src.prairielearn.elements.pl-xss-safe.pl-xss-safe",
        "peekOfCode": "SUBMITTED_FILE_NAME_DEFAULT = None\nCONTENTS_DEFAULT = None\nLANGUAGE_DEFAULT = \"html\"\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = []\n    optional_attribs = [\n        \"source-file-name\",\n        \"submitted-file-name\",\n        \"contents\",",
        "detail": "src.prairielearn.elements.pl-xss-safe.pl-xss-safe",
        "documentation": {}
    },
    {
        "label": "CONTENTS_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-xss-safe.pl-xss-safe",
        "description": "src.prairielearn.elements.pl-xss-safe.pl-xss-safe",
        "peekOfCode": "CONTENTS_DEFAULT = None\nLANGUAGE_DEFAULT = \"html\"\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = []\n    optional_attribs = [\n        \"source-file-name\",\n        \"submitted-file-name\",\n        \"contents\",\n        \"language\",",
        "detail": "src.prairielearn.elements.pl-xss-safe.pl-xss-safe",
        "documentation": {}
    },
    {
        "label": "LANGUAGE_DEFAULT",
        "kind": 5,
        "importPath": "src.prairielearn.elements.pl-xss-safe.pl-xss-safe",
        "description": "src.prairielearn.elements.pl-xss-safe.pl-xss-safe",
        "peekOfCode": "LANGUAGE_DEFAULT = \"html\"\ndef prepare(element_html: str, data: pl.QuestionData) -> None:\n    element = lxml.html.fragment_fromstring(element_html)\n    required_attribs = []\n    optional_attribs = [\n        \"source-file-name\",\n        \"submitted-file-name\",\n        \"contents\",\n        \"language\",\n    ]",
        "detail": "src.prairielearn.elements.pl-xss-safe.pl-xss-safe",
        "documentation": {}
    },
    {
        "label": "PropInfo",
        "kind": 6,
        "importPath": "src.prairielearn.python.check_data",
        "description": "src.prairielearn.python.check_data",
        "peekOfCode": "class PropInfo(TypedDict):\n    type: ValueType\n    present_phases: frozenset[Phase]\n    edit_phases: frozenset[Phase]\nPROPS: dict[str, PropInfo] = {\n    \"params\": {\n        \"type\": \"object\",\n        \"present_phases\": all_phases,\n        \"edit_phases\": frozenset({\"generate\", \"prepare\", \"grade\"}),\n    },",
        "detail": "src.prairielearn.python.check_data",
        "documentation": {}
    },
    {
        "label": "check_prop",
        "kind": 2,
        "importPath": "src.prairielearn.python.check_data",
        "description": "src.prairielearn.python.check_data",
        "peekOfCode": "def check_prop(\n    prop: str,\n    old_value: Any,\n    new_value: Any,\n    value_type: ValueType,\n    present_phases: frozenset[Phase],\n    edit_phases: frozenset[Phase],\n    phase: Phase,\n) -> None:\n    # Short-circuit if we don't care about this prop in this phase.",
        "detail": "src.prairielearn.python.check_data",
        "documentation": {}
    },
    {
        "label": "check_data",
        "kind": 2,
        "importPath": "src.prairielearn.python.check_data",
        "description": "src.prairielearn.python.check_data",
        "peekOfCode": "def check_data(old_data: dict, new_data: dict, phase: Phase) -> None:\n    # First, check for extra keys on `new_data`.\n    extra_keys = set(new_data.keys()) - set(PROPS.keys())\n    if extra_keys:\n        extra_keys_str = \", \".join(map(str, extra_keys))\n        raise ValueError(f\"data contains extra keys: {extra_keys_str}\")\n    # Then, check for missing keys on `new_data`.\n    missing_keys = set(old_data.keys()) - set(new_data.keys())\n    if missing_keys:\n        missing_keys_str = \", \".join(map(str, missing_keys))",
        "detail": "src.prairielearn.python.check_data",
        "documentation": {}
    },
    {
        "label": "Phase",
        "kind": 5,
        "importPath": "src.prairielearn.python.check_data",
        "description": "src.prairielearn.python.check_data",
        "peekOfCode": "Phase = Literal[\"generate\", \"prepare\", \"render\", \"parse\", \"grade\", \"test\", \"file\"]\nValueType = Literal[\"boolean\", \"integer\", \"number\", \"string\", \"object\"]\nall_phases: frozenset[Phase] = frozenset(\n    {\n        \"generate\",\n        \"prepare\",\n        \"render\",\n        \"parse\",\n        \"grade\",\n        \"test\",",
        "detail": "src.prairielearn.python.check_data",
        "documentation": {}
    },
    {
        "label": "ValueType",
        "kind": 5,
        "importPath": "src.prairielearn.python.check_data",
        "description": "src.prairielearn.python.check_data",
        "peekOfCode": "ValueType = Literal[\"boolean\", \"integer\", \"number\", \"string\", \"object\"]\nall_phases: frozenset[Phase] = frozenset(\n    {\n        \"generate\",\n        \"prepare\",\n        \"render\",\n        \"parse\",\n        \"grade\",\n        \"test\",\n        \"file\",",
        "detail": "src.prairielearn.python.check_data",
        "documentation": {}
    },
    {
        "label": "test_check_data_extra_props",
        "kind": 2,
        "importPath": "src.prairielearn.python.check_data_test",
        "description": "src.prairielearn.python.check_data_test",
        "peekOfCode": "def test_check_data_extra_props() -> None:\n    with pytest.raises(ValueError, match=\"data contains extra keys: bad_key\"):\n        check_data(\n            {\"panel\": \"question\"}, {\"panel\": \"question\", \"bad_key\": {}}, \"render\"\n        )\ndef test_check_data_missing_props() -> None:\n    with pytest.raises(ValueError, match=\"data is missing keys: panel\"):\n        check_data({\"panel\": \"question\"}, {}, \"render\")\ndef test_check_data_invalid_type() -> None:\n    with pytest.raises(ValueError, match=r'Expected data\\[\"score\"\\] to be a number'):",
        "detail": "src.prairielearn.python.check_data_test",
        "documentation": {}
    },
    {
        "label": "test_check_data_missing_props",
        "kind": 2,
        "importPath": "src.prairielearn.python.check_data_test",
        "description": "src.prairielearn.python.check_data_test",
        "peekOfCode": "def test_check_data_missing_props() -> None:\n    with pytest.raises(ValueError, match=\"data is missing keys: panel\"):\n        check_data({\"panel\": \"question\"}, {}, \"render\")\ndef test_check_data_invalid_type() -> None:\n    with pytest.raises(ValueError, match=r'Expected data\\[\"score\"\\] to be a number'):\n        check_data({\"score\": 1}, {\"score\": \"string\"}, \"render\")\ndef test_check_data_invalid_modification() -> None:\n    with pytest.raises(\n        ValueError, match=r'data\\[\"panel\"\\] has been illegally modified'\n    ):",
        "detail": "src.prairielearn.python.check_data_test",
        "documentation": {}
    },
    {
        "label": "test_check_data_invalid_type",
        "kind": 2,
        "importPath": "src.prairielearn.python.check_data_test",
        "description": "src.prairielearn.python.check_data_test",
        "peekOfCode": "def test_check_data_invalid_type() -> None:\n    with pytest.raises(ValueError, match=r'Expected data\\[\"score\"\\] to be a number'):\n        check_data({\"score\": 1}, {\"score\": \"string\"}, \"render\")\ndef test_check_data_invalid_modification() -> None:\n    with pytest.raises(\n        ValueError, match=r'data\\[\"panel\"\\] has been illegally modified'\n    ):\n        check_data({\"panel\": \"question\"}, {\"panel\": \"submission\"}, \"render\")\ndef test_check_data_invalid_modification_nested() -> None:\n    with pytest.raises(",
        "detail": "src.prairielearn.python.check_data_test",
        "documentation": {}
    },
    {
        "label": "test_check_data_invalid_modification",
        "kind": 2,
        "importPath": "src.prairielearn.python.check_data_test",
        "description": "src.prairielearn.python.check_data_test",
        "peekOfCode": "def test_check_data_invalid_modification() -> None:\n    with pytest.raises(\n        ValueError, match=r'data\\[\"panel\"\\] has been illegally modified'\n    ):\n        check_data({\"panel\": \"question\"}, {\"panel\": \"submission\"}, \"render\")\ndef test_check_data_invalid_modification_nested() -> None:\n    with pytest.raises(\n        ValueError, match=r'data\\[\"params\"\\] has been illegally modified'\n    ):\n        check_data({\"params\": {\"foo\": \"bar\"}}, {\"params\": {\"foo\": \"baz\"}}, \"test\")",
        "detail": "src.prairielearn.python.check_data_test",
        "documentation": {}
    },
    {
        "label": "test_check_data_invalid_modification_nested",
        "kind": 2,
        "importPath": "src.prairielearn.python.check_data_test",
        "description": "src.prairielearn.python.check_data_test",
        "peekOfCode": "def test_check_data_invalid_modification_nested() -> None:\n    with pytest.raises(\n        ValueError, match=r'data\\[\"params\"\\] has been illegally modified'\n    ):\n        check_data({\"params\": {\"foo\": \"bar\"}}, {\"params\": {\"foo\": \"baz\"}}, \"test\")\ndef test_check_data_number_keys() -> None:\n    with pytest.raises(ValueError, match=\"data contains extra keys: 1, 2\"):\n        check_data(\n            {\"panel\": \"question\"},\n            {\"panel\": \"question\", 1: \"data\", 2: \"more data\"},",
        "detail": "src.prairielearn.python.check_data_test",
        "documentation": {}
    },
    {
        "label": "test_check_data_number_keys",
        "kind": 2,
        "importPath": "src.prairielearn.python.check_data_test",
        "description": "src.prairielearn.python.check_data_test",
        "peekOfCode": "def test_check_data_number_keys() -> None:\n    with pytest.raises(ValueError, match=\"data contains extra keys: 1, 2\"):\n        check_data(\n            {\"panel\": \"question\"},\n            {\"panel\": \"question\", 1: \"data\", 2: \"more data\"},\n            \"render\",\n        )",
        "detail": "src.prairielearn.python.check_data_test",
        "documentation": {}
    },
    {
        "label": "PrairieLearnColor",
        "kind": 6,
        "importPath": "src.prairielearn.python.colors",
        "description": "src.prairielearn.python.colors",
        "peekOfCode": "class PrairieLearnColor(sRGB):\n    \"\"\"Custom sRGB class to handle custom PrairieLearn colors, via Coloraide.\"\"\"\n    def match(\n        self, string: str, start: int = 0, fullmatch: bool = True\n    ) -> tuple[tuple[Vector, float], int] | None:\n        \"\"\"\n        Match a color string, first trying PrairieLearn.\n        If no match is found, defaults to sRGB class' implementation.\n        \"\"\"\n        # Match the string using fullmatch if requested",
        "detail": "src.prairielearn.python.colors",
        "documentation": {}
    },
    {
        "label": "get_css_color",
        "kind": 2,
        "importPath": "src.prairielearn.python.colors",
        "description": "src.prairielearn.python.colors",
        "peekOfCode": "def get_css_color(name: str) -> str | None:\n    \"\"\"\n    Tries to look up a hex code value from a named css color, otherwise will\n    return None if not a valid color.\n    \"\"\"\n    name = name.lower()\n    if PLColor.match(name):\n        return PLColor(name).to_string(hex=True)\n    return None",
        "detail": "src.prairielearn.python.colors",
        "documentation": {}
    },
    {
        "label": "ColorTuple",
        "kind": 5,
        "importPath": "src.prairielearn.python.colors",
        "description": "src.prairielearn.python.colors",
        "peekOfCode": "ColorTuple = tuple[float, float, float, float]\n# Match the pattern of a PL color name;\n# only accepts numbers, lowercase letters, and a single underscore\nRE_PL_COLORS = re.compile(r\"(?i)\\b([0-9a-z][0-9a-z_]{2,})\\b\")\n# Colors used in /public/stylesheets/colors.css\n# includes additional aliases (e.g, \"red3\" also known as \"incorrect_red\")\nPL_COLORS_NAME_MAP: dict[str, ColorTuple] = {\n    \"blue1\": (57, 213, 255, 255),\n    \"blue2\": (18, 151, 224, 255),\n    \"blue3\": (0, 87, 160, 255),",
        "detail": "src.prairielearn.python.colors",
        "documentation": {}
    },
    {
        "label": "RE_PL_COLORS",
        "kind": 5,
        "importPath": "src.prairielearn.python.colors",
        "description": "src.prairielearn.python.colors",
        "peekOfCode": "RE_PL_COLORS = re.compile(r\"(?i)\\b([0-9a-z][0-9a-z_]{2,})\\b\")\n# Colors used in /public/stylesheets/colors.css\n# includes additional aliases (e.g, \"red3\" also known as \"incorrect_red\")\nPL_COLORS_NAME_MAP: dict[str, ColorTuple] = {\n    \"blue1\": (57, 213, 255, 255),\n    \"blue2\": (18, 151, 224, 255),\n    \"blue3\": (0, 87, 160, 255),\n    \"brown\": (142, 92, 59, 255),\n    \"brown1\": (246, 196, 163, 255),\n    \"brown2\": (206, 156, 123, 255),",
        "detail": "src.prairielearn.python.colors",
        "documentation": {}
    },
    {
        "label": "test_get_css_color",
        "kind": 2,
        "importPath": "src.prairielearn.python.colors_test",
        "description": "src.prairielearn.python.colors_test",
        "peekOfCode": "def test_get_css_color(color: str, expected: str | None) -> None:\n    \"\"\"\n    Assert the get_css_color method returns hex strings if given valid input.\n    Note that the new color constructor `PLColor(...)` is preferred.\n    \"\"\"\n    assert get_css_color(color) == expected\n@pytest.mark.parametrize(\n    \"color, expected\",\n    [(\"red\", Base(\"srgb\", [1, 0, 0], 1)), (\"RED\", Base(\"srgb\", [1, 0, 0], 1))],\n)",
        "detail": "src.prairielearn.python.colors_test",
        "documentation": {}
    },
    {
        "label": "test_color_constructor",
        "kind": 2,
        "importPath": "src.prairielearn.python.colors_test",
        "description": "src.prairielearn.python.colors_test",
        "peekOfCode": "def test_color_constructor(color: str, expected: str) -> None:\n    \"\"\"Assert the color constructor returns a color object if given valid input.\"\"\"\n    assert PLColor(color) == expected\ndef test_color_constructor_custom() -> None:\n    \"\"\"Assert the color constructor can handle custom colors.\"\"\"\n    assert PLColor(\"correct_green\") == PLColor(\"green3\")\ndef test_color_constructor_error() -> None:\n    \"\"\"Assert the color constructor raises a ValueError if given invalid input.\"\"\"\n    with pytest.raises(ValueError):\n        PLColor(\"none\")",
        "detail": "src.prairielearn.python.colors_test",
        "documentation": {}
    },
    {
        "label": "test_color_constructor_custom",
        "kind": 2,
        "importPath": "src.prairielearn.python.colors_test",
        "description": "src.prairielearn.python.colors_test",
        "peekOfCode": "def test_color_constructor_custom() -> None:\n    \"\"\"Assert the color constructor can handle custom colors.\"\"\"\n    assert PLColor(\"correct_green\") == PLColor(\"green3\")\ndef test_color_constructor_error() -> None:\n    \"\"\"Assert the color constructor raises a ValueError if given invalid input.\"\"\"\n    with pytest.raises(ValueError):\n        PLColor(\"none\")\n@pytest.mark.parametrize(\n    \"color\",\n    [",
        "detail": "src.prairielearn.python.colors_test",
        "documentation": {}
    },
    {
        "label": "test_color_constructor_error",
        "kind": 2,
        "importPath": "src.prairielearn.python.colors_test",
        "description": "src.prairielearn.python.colors_test",
        "peekOfCode": "def test_color_constructor_error() -> None:\n    \"\"\"Assert the color constructor raises a ValueError if given invalid input.\"\"\"\n    with pytest.raises(ValueError):\n        PLColor(\"none\")\n@pytest.mark.parametrize(\n    \"color\",\n    [\n        \"red\",\n        \"RED\",\n        \"correct_green\",",
        "detail": "src.prairielearn.python.colors_test",
        "documentation": {}
    },
    {
        "label": "test_color_match_is_not_none",
        "kind": 2,
        "importPath": "src.prairielearn.python.colors_test",
        "description": "src.prairielearn.python.colors_test",
        "peekOfCode": "def test_color_match_is_not_none(color: str) -> None:\n    \"\"\"\n    Assert the custom color match method returns a color object\n    \"\"\"\n    assert PLColor.match(color) is not None\n@pytest.mark.parametrize(\n    \"invalid_color\",\n    [\n        \"none\",\n        \"another_random_color\",",
        "detail": "src.prairielearn.python.colors_test",
        "documentation": {}
    },
    {
        "label": "test_color_match",
        "kind": 2,
        "importPath": "src.prairielearn.python.colors_test",
        "description": "src.prairielearn.python.colors_test",
        "peekOfCode": "def test_color_match(invalid_color: str) -> None:\n    \"\"\"\n    Assert the custom color match method returns None for invalid colors.\n    \"\"\"\n    assert PLColor.match(invalid_color) is None",
        "detail": "src.prairielearn.python.colors_test",
        "documentation": {}
    },
    {
        "label": "question_data",
        "kind": 2,
        "importPath": "src.prairielearn.python.conftest",
        "description": "src.prairielearn.python.conftest",
        "peekOfCode": "def question_data() -> QuestionData:\n    return {\n        \"params\": dict(),\n        \"correct_answers\": dict(),\n        \"submitted_answers\": dict(),\n        \"format_errors\": dict(),\n        \"partial_scores\": dict(),\n        \"score\": 0.0,\n        \"feedback\": dict(),\n        \"variant_seed\": \"\",",
        "detail": "src.prairielearn.python.conftest",
        "documentation": {}
    },
    {
        "label": "PartialScore",
        "kind": 6,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "class PartialScore(TypedDict):\n    \"A class with type signatures for the partial scores dict\"\n    score: float | None\n    weight: NotRequired[int]\n    feedback: NotRequired[str]\n# TODO: This type definition should not yet be seen as authoritative, it may\n# need to be modified as we expand type checking to cover more of the element code.\n# The fields below containing 'Any' in the types are ones which are used\n# in different ways by different question elements. Ideally we would have\n# QuestionData be a generic type so that question elements could declare types",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "QuestionData",
        "kind": 6,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "class QuestionData(TypedDict):\n    \"A class with type signatures for the data dictionary\"\n    params: dict[str, Any]\n    correct_answers: dict[str, Any]\n    submitted_answers: dict[str, Any]\n    format_errors: dict[str, Any]\n    partial_scores: dict[str, PartialScore]\n    score: float\n    feedback: dict[str, Any]\n    variant_seed: str",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "ElementTestData",
        "kind": 6,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "class ElementTestData(QuestionData):\n    test_type: Literal[\"correct\", \"incorrect\", \"invalid\"]\ndef check_answers_names(data: QuestionData, name: str) -> None:\n    \"\"\"Checks that answers names are distinct using property in data dict.\"\"\"\n    if name in data[\"answers_names\"]:\n        raise KeyError(f'Duplicate \"answers-name\" attribute: \"{name}\"')\n    else:\n        data[\"answers_names\"][name] = True\ndef get_unit_registry() -> UnitRegistry:\n    \"\"\"Get a unit registry using cache folder valid on production machines.\"\"\"",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "check_answers_names",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def check_answers_names(data: QuestionData, name: str) -> None:\n    \"\"\"Checks that answers names are distinct using property in data dict.\"\"\"\n    if name in data[\"answers_names\"]:\n        raise KeyError(f'Duplicate \"answers-name\" attribute: \"{name}\"')\n    else:\n        data[\"answers_names\"][name] = True\ndef get_unit_registry() -> UnitRegistry:\n    \"\"\"Get a unit registry using cache folder valid on production machines.\"\"\"\n    pid = os.getpid()\n    cache_dir = f\"/tmp/pint_{pid}\"",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "get_unit_registry",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def get_unit_registry() -> UnitRegistry:\n    \"\"\"Get a unit registry using cache folder valid on production machines.\"\"\"\n    pid = os.getpid()\n    cache_dir = f\"/tmp/pint_{pid}\"\n    return UnitRegistry(cache_folder=cache_dir)\ndef grade_answer_parameterized(\n    data: QuestionData,\n    question_name: str,\n    grade_function: Callable[[Any], tuple[bool | float, str | None]],\n    weight: int = 1,",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "grade_answer_parameterized",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def grade_answer_parameterized(\n    data: QuestionData,\n    question_name: str,\n    grade_function: Callable[[Any], tuple[bool | float, str | None]],\n    weight: int = 1,\n) -> None:\n    \"\"\"\n    Grade question question_name. grade_function should take in a single parameter\n    (which will be the submitted answer) and return a 2-tuple:\n        - The first element of the 2-tuple should either be:",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "determine_score_params",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def determine_score_params(\n    score: float,\n) -> tuple[Literal[\"correct\", \"partial\", \"incorrect\"], bool | float]:\n    \"\"\"\n    Determine appropriate key and value for display on the frontend given the\n    score for a particular question. For elements following PrairieLearn\n    conventions, the return value can be used as a key/value pair in the\n    dictionary passed to an element's Mustache template to display a score badge.\n    \"\"\"\n    if score >= 1:",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "get_enum_attrib",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def get_enum_attrib(\n    element: lxml.html.HtmlElement,\n    name: str,\n    enum_type: Type[EnumT],\n    default: EnumT | None = None,\n) -> EnumT:\n    \"\"\"\n    Returns the named attribute for the element parsed as an enum,\n    or the (optional) default value. If the default value is not provided\n    and the attribute is missing then an exception is thrown. An exception",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "set_weighted_score_data",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def set_weighted_score_data(data: QuestionData, weight_default: int = 1) -> None:\n    \"\"\"\n    Sets overall question score to be weighted average of all partial scores. Uses\n    weight_default to fill in a default weight for a score if one is missing.\n    \"\"\"\n    weight_total = 0\n    score_total = 0.0\n    for part in data[\"partial_scores\"].values():\n        score = part[\"score\"]\n        weight = part.get(\"weight\", weight_default)",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "set_all_or_nothing_score_data",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def set_all_or_nothing_score_data(data: QuestionData) -> None:\n    \"\"\"Gives points to main question score if all partial scores are correct.\"\"\"\n    data[\"score\"] = 1.0 if all_partial_scores_correct(data) else 0.0\ndef all_partial_scores_correct(data: QuestionData) -> bool:\n    \"\"\"Return true if all questions are correct in partial scores and it's nonempty.\"\"\"\n    partial_scores = data[\"partial_scores\"]\n    if len(partial_scores) == 0:\n        return False\n    return all(\n        part[\"score\"] is not None and math.isclose(part[\"score\"], 1.0)",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "all_partial_scores_correct",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def all_partial_scores_correct(data: QuestionData) -> bool:\n    \"\"\"Return true if all questions are correct in partial scores and it's nonempty.\"\"\"\n    partial_scores = data[\"partial_scores\"]\n    if len(partial_scores) == 0:\n        return False\n    return all(\n        part[\"score\"] is not None and math.isclose(part[\"score\"], 1.0)\n        for part in partial_scores.values()\n    )\ndef to_json(v, *, df_encoding_version=1, np_encoding_version=1):",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "to_json",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def to_json(v, *, df_encoding_version=1, np_encoding_version=1):\n    \"\"\"to_json(v)\n    If v has a standard type that cannot be json serialized, it is replaced with\n    a {'_type':..., '_value':...} pair that can be json serialized:\n        If np_encoding_version is set to 2, will serialize numpy scalars as follows:\n        numpy scalar -> '_type': 'np_scalar'\n        If df_encoding_version is set to 2, will serialize pandas DataFrames as follows:\n        pandas.DataFrame -> '_type': 'dataframe_v2'\n        Otherwise, the following mappings are used:\n        any complex scalar (including numpy) -> '_type': 'complex'",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "from_json",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def from_json(v):\n    \"\"\"from_json(v)\n    If v has the format {'_type':..., '_value':...} as would have been created\n    using to_json(...), then it is replaced:\n        '_type': 'complex' -> complex\n        '_type': 'np_scalar' -> numpy scalar defined by '_concrete_type'\n        '_type': 'ndarray' -> non-complex ndarray\n        '_type': 'complex_ndarray' -> complex ndarray\n        '_type': 'sympy' -> sympy.Expr\n        '_type': 'sympy_matrix' -> sympy.Matrix",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "inner_html",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def inner_html(element: lxml.html.HtmlElement) -> str:\n    inner = element.text\n    if inner is None:\n        inner = \"\"\n    inner = html.escape(str(inner))\n    for child in element:\n        inner += lxml.html.tostring(child, method=\"html\").decode(\"utf-8\")\n    return inner\ndef compat_get(object, attrib, default):\n    if attrib in object:",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "compat_get",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def compat_get(object, attrib, default):\n    if attrib in object:\n        return object[attrib]\n    old_attrib = attrib.replace(\"-\", \"_\")\n    return old_attrib in object\ndef compat_array(arr: list[str]) -> list[str]:\n    new_arr = []\n    for i in arr:\n        new_arr.append(i)\n        new_arr.append(i.replace(\"-\", \"_\"))",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "compat_array",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def compat_array(arr: list[str]) -> list[str]:\n    new_arr = []\n    for i in arr:\n        new_arr.append(i)\n        new_arr.append(i.replace(\"-\", \"_\"))\n    return new_arr\ndef check_attribs(\n    element: lxml.html.HtmlElement,\n    required_attribs: list[str],\n    optional_attribs: list[str],",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "check_attribs",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def check_attribs(\n    element: lxml.html.HtmlElement,\n    required_attribs: list[str],\n    optional_attribs: list[str],\n) -> None:\n    for name in required_attribs:\n        if not has_attrib(element, name):\n            print('Required attribute \"%s\" missing' % name)\n            raise Exception('Required attribute \"%s\" missing' % name)\n    extra_attribs = list(",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "has_attrib",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def has_attrib(element: lxml.html.HtmlElement, name: str) -> bool:\n    \"\"\"value = has_attrib(element, name)\n    Returns true if the element has an attribute of that name,\n    false otherwise.\n    \"\"\"\n    old_name = name.replace(\"-\", \"_\")\n    return name in element.attrib or old_name in element.attrib\n# Order here matters, as we want to override the case where the args is omitted\n@overload\ndef get_string_attrib(element: lxml.html.HtmlElement, name: str) -> str: ...",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "get_string_attrib",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def get_string_attrib(element: lxml.html.HtmlElement, name: str) -> str: ...\n@overload\ndef get_string_attrib(element: lxml.html.HtmlElement, name: str, *args: str) -> str: ...\n@overload\ndef get_string_attrib(\n    element: lxml.html.HtmlElement, name: str, *args: None\n) -> str | None: ...\ndef get_string_attrib(element, name, *args):\n    \"\"\"value = get_string_attrib(element, name, default)\n    Returns the named attribute for the element, or the (optional)",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "get_string_attrib",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def get_string_attrib(element: lxml.html.HtmlElement, name: str, *args: str) -> str: ...\n@overload\ndef get_string_attrib(\n    element: lxml.html.HtmlElement, name: str, *args: None\n) -> str | None: ...\ndef get_string_attrib(element, name, *args):\n    \"\"\"value = get_string_attrib(element, name, default)\n    Returns the named attribute for the element, or the (optional)\n    default value. If the default value is not provided and the\n    attribute is missing then an exception is thrown.",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "get_string_attrib",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def get_string_attrib(\n    element: lxml.html.HtmlElement, name: str, *args: None\n) -> str | None: ...\ndef get_string_attrib(element, name, *args):\n    \"\"\"value = get_string_attrib(element, name, default)\n    Returns the named attribute for the element, or the (optional)\n    default value. If the default value is not provided and the\n    attribute is missing then an exception is thrown.\n    \"\"\"\n    (str_val, is_default) = _get_attrib(element, name, *args)",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "get_string_attrib",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def get_string_attrib(element, name, *args):\n    \"\"\"value = get_string_attrib(element, name, default)\n    Returns the named attribute for the element, or the (optional)\n    default value. If the default value is not provided and the\n    attribute is missing then an exception is thrown.\n    \"\"\"\n    (str_val, is_default) = _get_attrib(element, name, *args)\n    return str_val\n# Order here matters, as we want to override the case where the args is omitted\n@overload",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "get_boolean_attrib",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def get_boolean_attrib(element: lxml.html.HtmlElement, name: str) -> bool: ...\n@overload\ndef get_boolean_attrib(\n    element: lxml.html.HtmlElement, name: str, *args: bool\n) -> bool: ...\n@overload\ndef get_boolean_attrib(\n    element: lxml.html.HtmlElement, name: str, *args: None\n) -> bool | None: ...\ndef get_boolean_attrib(element, name, *args):",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "get_boolean_attrib",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def get_boolean_attrib(\n    element: lxml.html.HtmlElement, name: str, *args: bool\n) -> bool: ...\n@overload\ndef get_boolean_attrib(\n    element: lxml.html.HtmlElement, name: str, *args: None\n) -> bool | None: ...\ndef get_boolean_attrib(element, name, *args):\n    \"\"\"value = get_boolean_attrib(element, name, default)\n    Returns the named attribute for the element, or the (optional)",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "get_boolean_attrib",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def get_boolean_attrib(\n    element: lxml.html.HtmlElement, name: str, *args: None\n) -> bool | None: ...\ndef get_boolean_attrib(element, name, *args):\n    \"\"\"value = get_boolean_attrib(element, name, default)\n    Returns the named attribute for the element, or the (optional)\n    default value. If the default value is not provided and the\n    attribute is missing then an exception is thrown. If the attribute\n    is not a valid boolean then an exception is thrown.\n    \"\"\"",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "get_boolean_attrib",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def get_boolean_attrib(element, name, *args):\n    \"\"\"value = get_boolean_attrib(element, name, default)\n    Returns the named attribute for the element, or the (optional)\n    default value. If the default value is not provided and the\n    attribute is missing then an exception is thrown. If the attribute\n    is not a valid boolean then an exception is thrown.\n    \"\"\"\n    (val, is_default) = _get_attrib(element, name, *args)\n    if is_default:\n        return val",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "get_integer_attrib",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def get_integer_attrib(element: lxml.html.HtmlElement, name: str) -> int: ...\n@overload\ndef get_integer_attrib(\n    element: lxml.html.HtmlElement, name: str, *args: int\n) -> int: ...\n@overload\ndef get_integer_attrib(\n    element: lxml.html.HtmlElement, name: str, *args: None\n) -> int | None: ...\ndef get_integer_attrib(element, name, *args):",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "get_integer_attrib",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def get_integer_attrib(\n    element: lxml.html.HtmlElement, name: str, *args: int\n) -> int: ...\n@overload\ndef get_integer_attrib(\n    element: lxml.html.HtmlElement, name: str, *args: None\n) -> int | None: ...\ndef get_integer_attrib(element, name, *args):\n    \"\"\"value = get_integer_attrib(element, name, default)\n    Returns the named attribute for the element, or the (optional)",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "get_integer_attrib",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def get_integer_attrib(\n    element: lxml.html.HtmlElement, name: str, *args: None\n) -> int | None: ...\ndef get_integer_attrib(element, name, *args):\n    \"\"\"value = get_integer_attrib(element, name, default)\n    Returns the named attribute for the element, or the (optional)\n    default value. If the default value is not provided and the\n    attribute is missing then an exception is thrown. If the attribute\n    is not a valid integer then an exception is thrown.\n    \"\"\"",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "get_integer_attrib",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def get_integer_attrib(element, name, *args):\n    \"\"\"value = get_integer_attrib(element, name, default)\n    Returns the named attribute for the element, or the (optional)\n    default value. If the default value is not provided and the\n    attribute is missing then an exception is thrown. If the attribute\n    is not a valid integer then an exception is thrown.\n    \"\"\"\n    (val, is_default) = _get_attrib(element, name, *args)\n    if is_default:\n        return val",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "get_float_attrib",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def get_float_attrib(element, name, *args):\n    \"\"\"value = get_float_attrib(element, name, default)\n    Returns the named attribute for the element, or the (optional)\n    default value. If the default value is not provided and the\n    attribute is missing then an exception is thrown. If the attribute\n    is not a valid floating-point number then an exception is thrown.\n    \"\"\"\n    (val, is_default) = _get_attrib(element, name, *args)\n    if is_default:\n        return val",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "get_color_attrib",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def get_color_attrib(element: lxml.html.HtmlElement, name: str, *args: str) -> str: ...\n@overload\ndef get_color_attrib(\n    element: lxml.html.HtmlElement, name: str, *args: None\n) -> str | None: ...\ndef get_color_attrib(element, name, *args):\n    \"\"\"value = get_color_attrib(element, name, default)\n    Returns a 3-digit or 6-digit hex RGB string in CSS format (e.g., '#123'\n    or '#1a2b3c'), or the (optional) default value. If the default value is\n    not provided and the attribute is missing then an exception is thrown. If",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "get_color_attrib",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def get_color_attrib(\n    element: lxml.html.HtmlElement, name: str, *args: None\n) -> str | None: ...\ndef get_color_attrib(element, name, *args):\n    \"\"\"value = get_color_attrib(element, name, default)\n    Returns a 3-digit or 6-digit hex RGB string in CSS format (e.g., '#123'\n    or '#1a2b3c'), or the (optional) default value. If the default value is\n    not provided and the attribute is missing then an exception is thrown. If\n    the attribute is not a valid RGB string then it will be checked against various\n    named colors.  If the attribute is still not valid an exception is thrown.",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "get_color_attrib",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def get_color_attrib(element, name, *args):\n    \"\"\"value = get_color_attrib(element, name, default)\n    Returns a 3-digit or 6-digit hex RGB string in CSS format (e.g., '#123'\n    or '#1a2b3c'), or the (optional) default value. If the default value is\n    not provided and the attribute is missing then an exception is thrown. If\n    the attribute is not a valid RGB string then it will be checked against various\n    named colors.  If the attribute is still not valid an exception is thrown.\n    \"\"\"\n    (val, is_default) = _get_attrib(element, name, *args)\n    if is_default:",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "numpy_to_matlab",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def numpy_to_matlab(A, ndigits=2, wtype=\"f\"):\n    \"\"\"numpy_to_matlab(A, ndigits=2, wtype='f')\n    This function assumes that A is one of these things:\n        - a number (float or complex)\n        - a 2D ndarray (float or complex)\n    It returns A as a MATLAB-formatted string in which each number has \"ndigits\"\n    digits after the decimal and is formatted as \"wtype\" (e.g., 'f', 'g', etc.).\n    \"\"\"\n    if np.isscalar(A):\n        A_str = \"{:.{indigits}{iwtype}}\".format(A, indigits=ndigits, iwtype=wtype)",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "string_from_numpy",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def string_from_numpy(A, language=\"python\", presentation_type=\"f\", digits=2):\n    \"\"\"string_from_numpy(A)\n    This function assumes that A is one of these things:\n        - a number (float or complex)\n        - a 1D ndarray (float or complex)\n        - a 2D ndarray (float or complex)\n    It returns A as a string.\n    If language is 'python' and A is a 2D ndarray, the string looks like this:\n        [[ ..., ... ], [ ..., ... ]]\n    If A is a 1D ndarray, the string looks like this:",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "string_from_2darray",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def string_from_2darray(A, language=\"python\", presentation_type=\"f\", digits=2):\n    result = string_from_numpy(A, language, presentation_type, digits)\n    return result\ndef string_from_number_sigfig(a, digits=2):\n    \"\"\"_string_from_complex_sigfig(a, digits=2)\n    This function assumes that \"a\" is of type float or complex. It returns \"a\"\n    as a string in which the number, or both the real and imaginary parts of the\n    number, have digits significant digits.\n    \"\"\"\n    if np.iscomplexobj(a):",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "string_from_number_sigfig",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def string_from_number_sigfig(a, digits=2):\n    \"\"\"_string_from_complex_sigfig(a, digits=2)\n    This function assumes that \"a\" is of type float or complex. It returns \"a\"\n    as a string in which the number, or both the real and imaginary parts of the\n    number, have digits significant digits.\n    \"\"\"\n    if np.iscomplexobj(a):\n        return _string_from_complex_sigfig(a, digits=digits)\n    else:\n        return to_precision.to_precision(a, digits)",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "numpy_to_matlab_sf",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def numpy_to_matlab_sf(A, ndigits=2):\n    \"\"\"numpy_to_matlab(A, ndigits=2)\n    This function assumes that A is one of these things:\n        - a number (float or complex)\n        - a 2D ndarray (float or complex)\n    It returns A as a MATLAB-formatted string in which each number has\n    ndigits significant digits.\n    \"\"\"\n    if np.isscalar(A):\n        if np.iscomplexobj(A):",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "string_partition_first_interval",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def string_partition_first_interval(s, left=\"[\", right=\"]\"):\n    # Split at first left delimiter\n    (s_before_left, s_left, s) = s.partition(left)\n    # Split at first right delimiter\n    (s, s_right, s_after_right) = s.partition(right)\n    # Return results\n    return s_before_left, s, s_after_right\ndef string_partition_outer_interval(s, left=\"[\", right=\"]\"):\n    # Split at first left delimiter\n    (s_before_left, s_left, s) = s.partition(left)",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "string_partition_outer_interval",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def string_partition_outer_interval(s, left=\"[\", right=\"]\"):\n    # Split at first left delimiter\n    (s_before_left, s_left, s) = s.partition(left)\n    # Split at last right delimiter\n    (s, s_right, s_after_right) = s.rpartition(right)\n    # Return results\n    return s_before_left, s, s_after_right\ndef string_to_integer(s: str, base: int = 10) -> int | None:\n    \"\"\"string_to_integer(s, base=10)\n    Parses a string that is an integer.",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "string_to_integer",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def string_to_integer(s: str, base: int = 10) -> int | None:\n    \"\"\"string_to_integer(s, base=10)\n    Parses a string that is an integer.\n    Returns a number with type int, or None on parse error.\n    \"\"\"\n    if s is None:\n        return None\n    # Do unidecode before parsing\n    s = full_unidecode(s).strip()\n    # Try to parse as int",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "string_to_number",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def string_to_number(s, allow_complex=True):\n    \"\"\"string_to_number(s, allow_complex=True)\n    Parses a string that can be interpreted either as float or (optionally) complex.\n    Returns a number with type np.float64 or np.complex128, or None on parse error.\n    \"\"\"\n    # Replace unicode minus with hyphen minus wherever it occurs\n    s = s.replace(\"\\u2212\", \"-\")\n    # If complex numbers are allowed...\n    if allow_complex:\n        # Replace \"i\" with \"j\" wherever it occurs",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "string_fraction_to_number",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def string_fraction_to_number(a_sub, allow_fractions=True, allow_complex=True):\n    \"\"\"string_fraction_to_number(a_sub, allow_fractions=True, allow_complex=True)\n    Parses a string containing a decimal number with support for answers expressing\n    as a fraction.\n    Returns a tuple with the parsed value in the first entry and a dictionary with\n    the intended value of \"data\" in the second entry.\n    On successful parsing, \"data\" will contain a 'submitted_answers' key that is the\n    JSON encoded parsed answer.\n    If parsing failed, the first entry will be 'None' and the \"data\" entry will\n    contain a 'format_errors' key.",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "string_to_2darray",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def string_to_2darray(s, allow_complex=True):\n    \"\"\"string_to_2darray(s)\n    Parses a string that is either a scalar or a 2D array in matlab or python\n    format. Each number must be interpretable as type float or complex.\n    \"\"\"\n    # Replace unicode minus with hyphen minus wherever it occurs\n    s = s.replace(\"\\u2212\", \"-\")\n    # If complex numbers are allowed...\n    if allow_complex:\n        # Replace \"i\" with \"j\" wherever it occurs",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "latex_from_2darray",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def latex_from_2darray(\n    A: numbers.Number | np.ndarray,\n    presentation_type: str = \"f\",\n    digits: int = 2,\n) -> str:\n    r\"\"\"latex_from_2darray\n    This function assumes that A is one of these things:\n            - a number (float or complex)\n            - a 2D ndarray (float or complex)\n    If A is a scalar, the string is a single number, not wrapped in brackets.",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "is_correct_ndarray2D_dd",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def is_correct_ndarray2D_dd(a_sub, a_tru, digits=2):\n    # Check if each element is correct\n    m = a_sub.shape[0]\n    n = a_sub.shape[1]\n    for i in range(0, m):\n        for j in range(0, n):\n            if not is_correct_scalar_dd(a_sub[i, j], a_tru[i, j], digits):\n                return False\n    # All elements were close\n    return True",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "is_correct_ndarray2D_sf",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def is_correct_ndarray2D_sf(a_sub, a_tru, digits=2):\n    # Check if each element is correct\n    m = a_sub.shape[0]\n    n = a_sub.shape[1]\n    for i in range(0, m):\n        for j in range(0, n):\n            if not is_correct_scalar_sf(a_sub[i, j], a_tru[i, j], digits):\n                return False\n    # All elements were close\n    return True",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "is_correct_ndarray2D_ra",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def is_correct_ndarray2D_ra(a_sub, a_tru, rtol=1e-5, atol=1e-8):\n    # Check if each element is correct\n    return np.allclose(a_sub, a_tru, rtol, atol)\ndef is_correct_scalar_ra(\n    a_sub: ArrayLike, a_tru: ArrayLike, rtol: float = 1e-5, atol: float = 1e-8\n) -> bool:\n    \"\"\"Compare a_sub and a_tru using relative tolerance rtol and absolute tolerance atol.\"\"\"\n    return bool(np.allclose(a_sub, a_tru, rtol, atol))\ndef is_correct_scalar_dd(a_sub: ArrayLike, a_tru: ArrayLike, digits: int = 2) -> bool:\n    \"\"\"Compare a_sub and a_tru using digits many digits after the decimal place.\"\"\"",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "is_correct_scalar_ra",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def is_correct_scalar_ra(\n    a_sub: ArrayLike, a_tru: ArrayLike, rtol: float = 1e-5, atol: float = 1e-8\n) -> bool:\n    \"\"\"Compare a_sub and a_tru using relative tolerance rtol and absolute tolerance atol.\"\"\"\n    return bool(np.allclose(a_sub, a_tru, rtol, atol))\ndef is_correct_scalar_dd(a_sub: ArrayLike, a_tru: ArrayLike, digits: int = 2) -> bool:\n    \"\"\"Compare a_sub and a_tru using digits many digits after the decimal place.\"\"\"\n    # If answers are complex, check real and imaginary parts separately\n    if np.iscomplexobj(a_sub) or np.iscomplexobj(a_tru):\n        real_comp = is_correct_scalar_dd(a_sub.real, a_tru.real, digits=digits)  # type: ignore",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "is_correct_scalar_dd",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def is_correct_scalar_dd(a_sub: ArrayLike, a_tru: ArrayLike, digits: int = 2) -> bool:\n    \"\"\"Compare a_sub and a_tru using digits many digits after the decimal place.\"\"\"\n    # If answers are complex, check real and imaginary parts separately\n    if np.iscomplexobj(a_sub) or np.iscomplexobj(a_tru):\n        real_comp = is_correct_scalar_dd(a_sub.real, a_tru.real, digits=digits)  # type: ignore\n        imag_comp = is_correct_scalar_dd(a_sub.imag, a_tru.imag, digits=digits)  # type: ignore\n        return real_comp and imag_comp\n    # Get bounds on submitted answer\n    eps = 0.51 * (10**-digits)\n    lower_bound = a_tru - eps",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "is_correct_scalar_sf",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def is_correct_scalar_sf(a_sub: ArrayLike, a_tru: ArrayLike, digits: int = 2) -> bool:\n    \"\"\"Compare a_sub and a_tru using digits many significant figures.\"\"\"\n    # If answers are complex, check real and imaginary parts separately\n    if np.iscomplexobj(a_sub) or np.iscomplexobj(a_tru):\n        real_comp = is_correct_scalar_sf(a_sub.real, a_tru.real, digits=digits)  # type: ignore\n        imag_comp = is_correct_scalar_sf(a_sub.imag, a_tru.imag, digits=digits)  # type: ignore\n        return real_comp and imag_comp\n    # Get bounds on submitted answer\n    if a_tru == 0:\n        n = digits - 1",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "get_uuid",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def get_uuid() -> str:\n    \"\"\"\n    Returns the string representation of a new random UUID.\n    First character of this uuid is guaranteed to be an alpha\n    (at the expense of a slight loss in randomness).\n    This is done because certain web components need identifiers to\n    start with letters and not numbers.\n    \"\"\"\n    uuid_string = str(uuid.uuid4())\n    random_char = random.choice(\"abcdef\")",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "escape_unicode_string",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def escape_unicode_string(string: str) -> str:\n    \"\"\"\n    escape_unicode_string(string)\n    Combs through any string and replaces invisible/unprintable characters with a\n    text representation of their hex id: <U+xxxx>\n    A character is considered invisible if its category is \"control\" or \"format\", as\n    reported by the 'unicodedata' library.\n    More info on unicode categories:\n    https://en.wikipedia.org/wiki/Unicode_character_property#General_Category\n    \"\"\"",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "escape_invalid_string",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def escape_invalid_string(string):\n    \"\"\"\n    escape_invalid_string(string)\n    Wraps and escapes string in <code> tags.\n    \"\"\"\n    return f'<code class=\"user-output-invalid\">{html.escape(escape_unicode_string(string))}</code>'\ndef clean_identifier_name(name):\n    \"\"\"\n    clean_identifier_name(string)\n    Escapes a string so that it becomes a valid Python identifier.",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "clean_identifier_name",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def clean_identifier_name(name):\n    \"\"\"\n    clean_identifier_name(string)\n    Escapes a string so that it becomes a valid Python identifier.\n    \"\"\"\n    # Strip invalid characters and weird leading characters so we have\n    # a decent python identifier\n    name = re.sub(\"[^a-zA-Z0-9_]\", \"_\", name)\n    name = re.sub(\"^[^a-zA-Z]+\", \"\", name)\n    return name",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "load_extension",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def load_extension(data, extension_name):\n    \"\"\"\n    load_extension(data, extension_name)\n    Loads a single specific extension by name for an element.\n    Returns a dictionary of defined variables and functions.\n    \"\"\"\n    if \"extensions\" not in data:\n        raise Exception(\"load_extension() must be called from an element!\")\n    if extension_name not in data[\"extensions\"]:\n        raise Exception(f\"Could not find extension {extension_name}!\")",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "load_all_extensions",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def load_all_extensions(data):\n    \"\"\"\n    load_all_extensions(data)\n    Loads all available extensions for a given element.\n    Returns an ordered dictionary mapping the extension name to its defined variables and functions\n    \"\"\"\n    if \"extensions\" not in data:\n        raise Exception(\"load_all_extensions() must be called from an element!\")\n    if len(data[\"extensions\"]) == 0:\n        return {}",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "load_host_script",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def load_host_script(script_name):\n    \"\"\"\n    load_host_script(script_name)\n    Small convenience function to load a host element script from an extension.\n    \"\"\"\n    # Chop off the file extension because it's unnecessary here\n    if script_name.endswith(\".py\"):\n        script_name = script_name[:-3]\n    return __import__(script_name)\ndef iter_keys() -> Generator[str, None, None]:",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "iter_keys",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def iter_keys() -> Generator[str, None, None]:\n    \"\"\"\n    from:\n    https://stackoverflow.com/questions/29351492/how-to-make-a-continuous-alphabetic-list-python-from-a-z-then-from-aa-ab-ac-e/29351603#29351603\n    \"\"\"\n    ascii_set = string.ascii_lowercase\n    return (\n        \"\".join(s) for size in it.count(1) for s in it.product(ascii_set, repeat=size)\n    )\ndef index2key(i: int) -> str:",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "index2key",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def index2key(i: int) -> str:\n    \"\"\"\n    index2key(i)\n    Used when generating ordered lists of the form ['a', 'b', ..., 'z', 'aa', 'ab', ..., 'zz', 'aaa', 'aab', ...]\n    Returns alphabetic key in the form [a-z]* from a given integer (i = 0, 1, 2, ...).\n    \"\"\"\n    return next(it.islice(iter_keys(), i, None))\ndef is_int_json_serializable(n: int) -> bool:\n    return -((2**53) - 1) <= n <= 2**53 - 1\ndef full_unidecode(input_str: str) -> str:",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "is_int_json_serializable",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def is_int_json_serializable(n: int) -> bool:\n    return -((2**53) - 1) <= n <= 2**53 - 1\ndef full_unidecode(input_str: str) -> str:\n    \"\"\"Does unidecode of input and replaces the unicode minus with the normal one.\"\"\"\n    return unidecode(input_str.replace(\"\\u2212\", \"-\"))\ndef add_files_format_error(data: QuestionData, error: str) -> None:\n    \"\"\"Adds a format error to the data dictionary.\"\"\"\n    if data[\"format_errors\"].get(\"_files\") is None:\n        data[\"format_errors\"][\"_files\"] = []\n    if isinstance(data[\"format_errors\"][\"_files\"], list):",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "full_unidecode",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def full_unidecode(input_str: str) -> str:\n    \"\"\"Does unidecode of input and replaces the unicode minus with the normal one.\"\"\"\n    return unidecode(input_str.replace(\"\\u2212\", \"-\"))\ndef add_files_format_error(data: QuestionData, error: str) -> None:\n    \"\"\"Adds a format error to the data dictionary.\"\"\"\n    if data[\"format_errors\"].get(\"_files\") is None:\n        data[\"format_errors\"][\"_files\"] = []\n    if isinstance(data[\"format_errors\"][\"_files\"], list):\n        data[\"format_errors\"][\"_files\"].append(error)\n    else:",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "add_files_format_error",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def add_files_format_error(data: QuestionData, error: str) -> None:\n    \"\"\"Adds a format error to the data dictionary.\"\"\"\n    if data[\"format_errors\"].get(\"_files\") is None:\n        data[\"format_errors\"][\"_files\"] = []\n    if isinstance(data[\"format_errors\"][\"_files\"], list):\n        data[\"format_errors\"][\"_files\"].append(error)\n    else:\n        data[\"format_errors\"][\"_files\"] = [\n            '\"_files\" was present in \"format_errors\" but was not an array',\n            error,",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "add_submitted_file",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "def add_submitted_file(\n    data: QuestionData,\n    file_name: str,\n    base64_contents: str,\n) -> None:\n    \"\"\"Adds a submitted file to the data dictionary.\"\"\"\n    if data[\"submitted_answers\"].get(\"_files\") is None:\n        data[\"submitted_answers\"][\"_files\"] = []\n    if isinstance(data[\"submitted_answers\"][\"_files\"], list):\n        data[\"submitted_answers\"][\"_files\"].append(",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "EnumT",
        "kind": 5,
        "importPath": "src.prairielearn.python.prairielearn",
        "description": "src.prairielearn.python.prairielearn",
        "peekOfCode": "EnumT = TypeVar(\"EnumT\", bound=Enum)\ndef get_enum_attrib(\n    element: lxml.html.HtmlElement,\n    name: str,\n    enum_type: Type[EnumT],\n    default: EnumT | None = None,\n) -> EnumT:\n    \"\"\"\n    Returns the named attribute for the element parsed as an enum,\n    or the (optional) default value. If the default value is not provided",
        "detail": "src.prairielearn.python.prairielearn",
        "documentation": {}
    },
    {
        "label": "DummyEnum",
        "kind": 6,
        "importPath": "src.prairielearn.python.prairielearn_test",
        "description": "src.prairielearn.python.prairielearn_test",
        "peekOfCode": "class DummyEnum(Enum):\n    DEFAULT = 0\n    DUMMY_CHOICE_1 = 1\n    DUMMY_CHOICE_2 = 2\n    DUMMY_CHOICE_3 = 3\n@pytest.mark.parametrize(\n    \"html_str, expected_result\",\n    [\n        (\"<pl-thing></pl-thing>\", DummyEnum.DEFAULT),\n        ('<pl-thing test-choice=\"default\"></pl-thing>', DummyEnum.DEFAULT),",
        "detail": "src.prairielearn.python.prairielearn_test",
        "documentation": {}
    },
    {
        "label": "city_dataframe",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn_test",
        "description": "src.prairielearn.python.prairielearn_test",
        "peekOfCode": "def city_dataframe() -> pd.DataFrame:\n    x = [\n        {\n            \"city\": \"Champaign\",\n            \"job\": \"Professor\",\n            \"age\": 35,\n            \"time\": pd.to_datetime(\"2022-10-06 12:00\"),\n        },\n        {\n            \"city\": \"Sunnyvale\",",
        "detail": "src.prairielearn.python.prairielearn_test",
        "documentation": {}
    },
    {
        "label": "breast_cancer_dataframe",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn_test",
        "description": "src.prairielearn.python.prairielearn_test",
        "peekOfCode": "def breast_cancer_dataframe() -> pd.DataFrame:\n    pd_dict = {\n        0: {0: 842302, 1: 842517, 2: 84300903, 3: 84348301, 4: 84358402},\n        1: {0: \"M\", 1: \"M\", 2: \"M\", 3: \"M\", 4: \"M\"},\n        2: {0: 17.99, 1: 20.57, 2: 19.69, 3: 11.42, 4: 20.29},\n        3: {0: 10.38, 1: 17.77, 2: 21.25, 3: 20.38, 4: 14.34},\n        4: {0: 122.8, 1: 132.9, 2: 130.0, 3: 77.58, 4: 135.1},\n        5: {0: 1001.0, 1: 1326.0, 2: 1203.0, 3: 386.1, 4: 1297.0},\n        6: {0: 0.1184, 1: 0.08474, 2: 0.1096, 3: 0.1425, 4: 0.1003},\n        7: {0: 0.2776, 1: 0.07864, 2: 0.1599, 3: 0.2839, 4: 0.1328},",
        "detail": "src.prairielearn.python.prairielearn_test",
        "documentation": {}
    },
    {
        "label": "r_types_dataframe",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn_test",
        "description": "src.prairielearn.python.prairielearn_test",
        "peekOfCode": "def r_types_dataframe() -> pd.DataFrame:\n    return pd.DataFrame(\n        {\n            # Scalars\n            \"integer\": 1,\n            \"numeric\": 3.14,\n            \"logical\": False,\n            \"character\": \"foo\",\n            # TODO adding in complex numbers won't deserialize correctly, fix this (somehow?)\n            # \"complex\": complex(1, 2),",
        "detail": "src.prairielearn.python.prairielearn_test",
        "documentation": {}
    },
    {
        "label": "test_encoding_pandas",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn_test",
        "description": "src.prairielearn.python.prairielearn_test",
        "peekOfCode": "def test_encoding_pandas(df: pd.DataFrame) -> None:\n    \"\"\"Test that new json encoding works\"\"\"\n    # Test encoding as json doesn't throw exceptions\n    json_df = pl.to_json(df, df_encoding_version=2)\n    json_str = json.dumps(json_df)\n    assert isinstance(json_str, str)\n    # Deserialize and check equality\n    loaded_str = json.loads(json_str)\n    deserialized_df = cast(pd.DataFrame, pl.from_json(loaded_str))\n    # Column types get erased, need to account for this in testing",
        "detail": "src.prairielearn.python.prairielearn_test",
        "documentation": {}
    },
    {
        "label": "test_encoding_legacy",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn_test",
        "description": "src.prairielearn.python.prairielearn_test",
        "peekOfCode": "def test_encoding_legacy(df: pd.DataFrame) -> None:\n    \"\"\"Add compatibility test for legacy encoding\"\"\"\n    reserialized_dataframe = cast(pd.DataFrame, pl.from_json(pl.to_json(df)))\n    pd.testing.assert_frame_equal(df, reserialized_dataframe)\n@pytest.mark.parametrize(\n    \"networkx_graph\",\n    [\n        nx.cycle_graph(20),\n        nx.ladder_graph(20),\n        nx.lollipop_graph(20, 20),",
        "detail": "src.prairielearn.python.prairielearn_test",
        "documentation": {}
    },
    {
        "label": "test_networkx_serialization",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn_test",
        "description": "src.prairielearn.python.prairielearn_test",
        "peekOfCode": "def test_networkx_serialization(networkx_graph: Any) -> None:\n    \"\"\"Test equality after conversion of various numpy objects.\"\"\"\n    networkx_graph.graph[\"rankdir\"] = \"TB\"\n    # Add some data to test that it's retained\n    for i, (in_node, out_node, edge_data) in enumerate(networkx_graph.edges(data=True)):\n        edge_data[\"weight\"] = i\n        edge_data[\"label\"] = chr(ord(\"a\") + i)\n    json_object = json.dumps(pl.to_json(networkx_graph), allow_nan=False)\n    decoded_json_object = pl.from_json(json.loads(json_object))\n    assert type(networkx_graph) == type(decoded_json_object)  # noqa: E721",
        "detail": "src.prairielearn.python.prairielearn_test",
        "documentation": {}
    },
    {
        "label": "test_inner_html",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn_test",
        "description": "src.prairielearn.python.prairielearn_test",
        "peekOfCode": "def test_inner_html(inner_html_string: str) -> None:\n    e = lxml.html.fragment_fromstring(f\"<div>{inner_html_string}</div>\")\n    assert pl.inner_html(e) == inner_html_string\n@pytest.mark.parametrize(\n    \"weight_set_function, score_1, score_2, score_3, expected_score\",\n    [\n        # Check set weighted score data\n        (pl.set_weighted_score_data, 0.0, 0.0, 0.0, 0.0),\n        (pl.set_weighted_score_data, 0.0, 0.5, 0.0, 2.0 / 7.0),\n        (pl.set_weighted_score_data, 0.0, 0.75, 1.0, 4.0 / 7.0),",
        "detail": "src.prairielearn.python.prairielearn_test",
        "documentation": {}
    },
    {
        "label": "test_set_score_data",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn_test",
        "description": "src.prairielearn.python.prairielearn_test",
        "peekOfCode": "def test_set_score_data(\n    question_data: pl.QuestionData,\n    weight_set_function: Callable[[pl.QuestionData], None],\n    score_1: float,\n    score_2: float,\n    score_3: float,\n    expected_score: float,\n) -> None:\n    question_data[\"partial_scores\"] = {\n        \"p1\": {\"score\": score_1, \"weight\": 2},",
        "detail": "src.prairielearn.python.prairielearn_test",
        "documentation": {}
    },
    {
        "label": "test_numpy_serialization",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn_test",
        "description": "src.prairielearn.python.prairielearn_test",
        "peekOfCode": "def test_numpy_serialization(numpy_object: Any) -> None:\n    \"\"\"Test equality after conversion of various numpy objects.\"\"\"\n    json_object = json.dumps(\n        pl.to_json(numpy_object, np_encoding_version=2), allow_nan=False\n    )\n    decoded_json_object = pl.from_json(json.loads(json_object))\n    assert type(numpy_object) == type(decoded_json_object)  # noqa: E721\n    np.testing.assert_array_equal(numpy_object, decoded_json_object, strict=True)\n@pytest.mark.parametrize(\n    \"object_to_encode, expected_result\",",
        "detail": "src.prairielearn.python.prairielearn_test",
        "documentation": {}
    },
    {
        "label": "test_legacy_serialization",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn_test",
        "description": "src.prairielearn.python.prairielearn_test",
        "peekOfCode": "def test_legacy_serialization(object_to_encode: Any, expected_result: Any) -> None:\n    \"\"\"Test that nothing happens under the old encoding for numpy scalars.\"\"\"\n    json_object = json.dumps(pl.to_json(object_to_encode), allow_nan=False)\n    decoded_json_object = pl.from_json(json.loads(json_object))\n    assert decoded_json_object == expected_result\nclass DummyEnum(Enum):\n    DEFAULT = 0\n    DUMMY_CHOICE_1 = 1\n    DUMMY_CHOICE_2 = 2\n    DUMMY_CHOICE_3 = 3",
        "detail": "src.prairielearn.python.prairielearn_test",
        "documentation": {}
    },
    {
        "label": "test_get_enum_attrib",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn_test",
        "description": "src.prairielearn.python.prairielearn_test",
        "peekOfCode": "def test_get_enum_attrib(html_str: str, expected_result: DummyEnum) -> None:\n    element = lxml.html.fragment_fromstring(html_str)\n    result = pl.get_enum_attrib(element, \"test-choice\", DummyEnum, DummyEnum.DEFAULT)\n    assert result is expected_result\n@pytest.mark.parametrize(\n    \"html_str\",\n    [\n        \"<pl-thing></pl-thing>\",\n        '<pl-thing test-choice=\"DEFAULT\"></pl-thing>',\n        '<pl-thing test-choice=\"Default\"></pl-thing>',",
        "detail": "src.prairielearn.python.prairielearn_test",
        "documentation": {}
    },
    {
        "label": "test_get_enum_attrib_exceptions",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn_test",
        "description": "src.prairielearn.python.prairielearn_test",
        "peekOfCode": "def test_get_enum_attrib_exceptions(html_str: str) -> None:\n    element = lxml.html.fragment_fromstring(html_str)\n    with pytest.raises(Exception):\n        pl.get_enum_attrib(element, \"test-choice\", DummyEnum)\n@pytest.mark.parametrize(\n    \"question_name, student_answer, weight, expected_grade\",\n    [\n        (\"base\", \"a\", 1, True),\n        (\"base\", \"a, b\", 1, False),\n        (\"base\", \"\", 2, False),",
        "detail": "src.prairielearn.python.prairielearn_test",
        "documentation": {}
    },
    {
        "label": "test_grade_answer_parametrized_correct",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn_test",
        "description": "src.prairielearn.python.prairielearn_test",
        "peekOfCode": "def test_grade_answer_parametrized_correct(\n    question_data: pl.QuestionData,\n    question_name: str,\n    student_answer: str,\n    weight: int,\n    expected_grade: bool,\n) -> None:\n    question_data[\"submitted_answers\"] = {question_name: student_answer}\n    good_feedback = \"you did good\"\n    bad_feedback = \"that's terrible\"",
        "detail": "src.prairielearn.python.prairielearn_test",
        "documentation": {}
    },
    {
        "label": "test_grade_answer_parametrized_bad_grade_function",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn_test",
        "description": "src.prairielearn.python.prairielearn_test",
        "peekOfCode": "def test_grade_answer_parametrized_bad_grade_function(\n    question_data: pl.QuestionData,\n) -> None:\n    question_name = \"name\"\n    question_data[\"submitted_answers\"] = {question_name: \"True\"}\n    def grading_function(ans: str) -> Any:\n        return \"True\", f\"The answer {ans} is right\"\n    with pytest.raises(AssertionError):\n        pl.grade_answer_parameterized(question_data, question_name, grading_function)\ndef test_grade_answer_parametrized_key_error_blank(",
        "detail": "src.prairielearn.python.prairielearn_test",
        "documentation": {}
    },
    {
        "label": "test_grade_answer_parametrized_key_error_blank",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn_test",
        "description": "src.prairielearn.python.prairielearn_test",
        "peekOfCode": "def test_grade_answer_parametrized_key_error_blank(\n    question_data: pl.QuestionData,\n) -> None:\n    question_name = \"name\"\n    question_data[\"submitted_answers\"] = {question_name: \"True\"}\n    def grading_function(_: str) -> tuple[bool, str | None]:\n        decoy_dict: dict[str, str] = dict()\n        decoy_dict[\"junk\"]  # This is to throw a key error\n        return (True, None)\n    with pytest.raises(KeyError):",
        "detail": "src.prairielearn.python.prairielearn_test",
        "documentation": {}
    },
    {
        "label": "test_get_uuid",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn_test",
        "description": "src.prairielearn.python.prairielearn_test",
        "peekOfCode": "def test_get_uuid() -> None:\n    \"\"\"Test basic properties of the pl.get_uuid() function.\"\"\"\n    pl_uuid = pl.get_uuid()\n    clauses = pl_uuid.split(\"-\")\n    # Assert clauses have standard structure.\n    assert len(clauses) == 5\n    assert [8, 4, 4, 4, 12] == list(map(len, clauses))\n    # Assert that all characters are valid.\n    seen_characters = set().union(*(clause for clause in clauses))\n    allowed_hex_characters = set(string.hexdigits[:16])",
        "detail": "src.prairielearn.python.prairielearn_test",
        "documentation": {}
    },
    {
        "label": "test_iter_keys",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn_test",
        "description": "src.prairielearn.python.prairielearn_test",
        "peekOfCode": "def test_iter_keys(length: int, expected_output: list[str]) -> None:\n    assert list(it.islice(pl.iter_keys(), length)) == expected_output\n@pytest.mark.parametrize(\n    \"idx, expected_output\",\n    [(0, \"a\"), (1, \"b\"), (3, \"d\"), (26, \"aa\"), (27, \"ab\")],\n)\ndef test_index2key(idx: int, expected_output: str) -> None:\n    assert pl.index2key(idx) == expected_output",
        "detail": "src.prairielearn.python.prairielearn_test",
        "documentation": {}
    },
    {
        "label": "test_index2key",
        "kind": 2,
        "importPath": "src.prairielearn.python.prairielearn_test",
        "description": "src.prairielearn.python.prairielearn_test",
        "peekOfCode": "def test_index2key(idx: int, expected_output: str) -> None:\n    assert pl.index2key(idx) == expected_output",
        "detail": "src.prairielearn.python.prairielearn_test",
        "documentation": {}
    },
    {
        "label": "SympyJson",
        "kind": 6,
        "importPath": "src.prairielearn.python.python_helper_sympy",
        "description": "src.prairielearn.python.python_helper_sympy",
        "peekOfCode": "class SympyJson(TypedDict):\n    \"\"\"A class with type signatures for the sympy json dict\"\"\"\n    _type: Literal[\"sympy\"]\n    _value: str\n    _variables: list[str]\n    _assumptions: NotRequired[AssumptionsDictT]\n    _custom_functions: NotRequired[list[str]]\nclass LocalsForEval(TypedDict):\n    \"\"\"A class with type signatures for the locals_for_eval dict\"\"\"\n    functions: SympyMapT",
        "detail": "src.prairielearn.python.python_helper_sympy",
        "documentation": {}
    },
    {
        "label": "LocalsForEval",
        "kind": 6,
        "importPath": "src.prairielearn.python.python_helper_sympy",
        "description": "src.prairielearn.python.python_helper_sympy",
        "peekOfCode": "class LocalsForEval(TypedDict):\n    \"\"\"A class with type signatures for the locals_for_eval dict\"\"\"\n    functions: SympyMapT\n    variables: SympyMapT\n    helpers: SympyMapT\n# Create a new instance of this class to access the member dictionaries. This\n# is to avoid accidentally modifying these dictionaries.\nclass _Constants:\n    helpers: SympyMapT\n    variables: SympyMapT",
        "detail": "src.prairielearn.python.python_helper_sympy",
        "documentation": {}
    },
    {
        "label": "_Constants",
        "kind": 6,
        "importPath": "src.prairielearn.python.python_helper_sympy",
        "description": "src.prairielearn.python.python_helper_sympy",
        "peekOfCode": "class _Constants:\n    helpers: SympyMapT\n    variables: SympyMapT\n    hidden_variables: SympyMapT\n    complex_variables: SympyMapT\n    hidden_complex_variables: SympyMapT\n    functions: SympyMapT\n    trig_functions: SympyMapT\n    def __init__(self) -> None:\n        self.helpers = {",
        "detail": "src.prairielearn.python.python_helper_sympy",
        "documentation": {}
    },
    {
        "label": "BaseSympyError",
        "kind": 6,
        "importPath": "src.prairielearn.python.python_helper_sympy",
        "description": "src.prairielearn.python.python_helper_sympy",
        "peekOfCode": "class BaseSympyError(Exception):\n    \"\"\"Exception base class for sympy parsing errors\"\"\"\n    pass\nclass HasConflictingVariable(BaseSympyError):\n    pass\nclass HasConflictingFunction(BaseSympyError):\n    pass\nclass HasInvalidAssumption(BaseSympyError):\n    pass\n@dataclass",
        "detail": "src.prairielearn.python.python_helper_sympy",
        "documentation": {}
    },
    {
        "label": "HasConflictingVariable",
        "kind": 6,
        "importPath": "src.prairielearn.python.python_helper_sympy",
        "description": "src.prairielearn.python.python_helper_sympy",
        "peekOfCode": "class HasConflictingVariable(BaseSympyError):\n    pass\nclass HasConflictingFunction(BaseSympyError):\n    pass\nclass HasInvalidAssumption(BaseSympyError):\n    pass\n@dataclass\nclass HasFloatError(BaseSympyError):\n    n: float\nclass HasComplexError(BaseSympyError):",
        "detail": "src.prairielearn.python.python_helper_sympy",
        "documentation": {}
    },
    {
        "label": "HasConflictingFunction",
        "kind": 6,
        "importPath": "src.prairielearn.python.python_helper_sympy",
        "description": "src.prairielearn.python.python_helper_sympy",
        "peekOfCode": "class HasConflictingFunction(BaseSympyError):\n    pass\nclass HasInvalidAssumption(BaseSympyError):\n    pass\n@dataclass\nclass HasFloatError(BaseSympyError):\n    n: float\nclass HasComplexError(BaseSympyError):\n    pass\n@dataclass",
        "detail": "src.prairielearn.python.python_helper_sympy",
        "documentation": {}
    },
    {
        "label": "HasInvalidAssumption",
        "kind": 6,
        "importPath": "src.prairielearn.python.python_helper_sympy",
        "description": "src.prairielearn.python.python_helper_sympy",
        "peekOfCode": "class HasInvalidAssumption(BaseSympyError):\n    pass\n@dataclass\nclass HasFloatError(BaseSympyError):\n    n: float\nclass HasComplexError(BaseSympyError):\n    pass\n@dataclass\nclass HasInvalidExpressionError(BaseSympyError):\n    offset: int",
        "detail": "src.prairielearn.python.python_helper_sympy",
        "documentation": {}
    },
    {
        "label": "HasFloatError",
        "kind": 6,
        "importPath": "src.prairielearn.python.python_helper_sympy",
        "description": "src.prairielearn.python.python_helper_sympy",
        "peekOfCode": "class HasFloatError(BaseSympyError):\n    n: float\nclass HasComplexError(BaseSympyError):\n    pass\n@dataclass\nclass HasInvalidExpressionError(BaseSympyError):\n    offset: int\n@dataclass\nclass HasInvalidFunctionError(BaseSympyError):\n    offset: int",
        "detail": "src.prairielearn.python.python_helper_sympy",
        "documentation": {}
    },
    {
        "label": "HasComplexError",
        "kind": 6,
        "importPath": "src.prairielearn.python.python_helper_sympy",
        "description": "src.prairielearn.python.python_helper_sympy",
        "peekOfCode": "class HasComplexError(BaseSympyError):\n    pass\n@dataclass\nclass HasInvalidExpressionError(BaseSympyError):\n    offset: int\n@dataclass\nclass HasInvalidFunctionError(BaseSympyError):\n    offset: int\n    text: str\n@dataclass",
        "detail": "src.prairielearn.python.python_helper_sympy",
        "documentation": {}
    },
    {
        "label": "HasInvalidExpressionError",
        "kind": 6,
        "importPath": "src.prairielearn.python.python_helper_sympy",
        "description": "src.prairielearn.python.python_helper_sympy",
        "peekOfCode": "class HasInvalidExpressionError(BaseSympyError):\n    offset: int\n@dataclass\nclass HasInvalidFunctionError(BaseSympyError):\n    offset: int\n    text: str\n@dataclass\nclass HasInvalidVariableError(BaseSympyError):\n    offset: int\n    text: str",
        "detail": "src.prairielearn.python.python_helper_sympy",
        "documentation": {}
    },
    {
        "label": "HasInvalidFunctionError",
        "kind": 6,
        "importPath": "src.prairielearn.python.python_helper_sympy",
        "description": "src.prairielearn.python.python_helper_sympy",
        "peekOfCode": "class HasInvalidFunctionError(BaseSympyError):\n    offset: int\n    text: str\n@dataclass\nclass HasInvalidVariableError(BaseSympyError):\n    offset: int\n    text: str\n@dataclass\nclass FunctionNameWithoutArgumentsError(BaseSympyError):\n    offset: int",
        "detail": "src.prairielearn.python.python_helper_sympy",
        "documentation": {}
    },
    {
        "label": "HasInvalidVariableError",
        "kind": 6,
        "importPath": "src.prairielearn.python.python_helper_sympy",
        "description": "src.prairielearn.python.python_helper_sympy",
        "peekOfCode": "class HasInvalidVariableError(BaseSympyError):\n    offset: int\n    text: str\n@dataclass\nclass FunctionNameWithoutArgumentsError(BaseSympyError):\n    offset: int\n    text: str\n@dataclass\nclass HasParseError(BaseSympyError):\n    offset: int",
        "detail": "src.prairielearn.python.python_helper_sympy",
        "documentation": {}
    },
    {
        "label": "FunctionNameWithoutArgumentsError",
        "kind": 6,
        "importPath": "src.prairielearn.python.python_helper_sympy",
        "description": "src.prairielearn.python.python_helper_sympy",
        "peekOfCode": "class FunctionNameWithoutArgumentsError(BaseSympyError):\n    offset: int\n    text: str\n@dataclass\nclass HasParseError(BaseSympyError):\n    offset: int\n@dataclass\nclass HasEscapeError(BaseSympyError):\n    offset: int\n@dataclass",
        "detail": "src.prairielearn.python.python_helper_sympy",
        "documentation": {}
    },
    {
        "label": "HasParseError",
        "kind": 6,
        "importPath": "src.prairielearn.python.python_helper_sympy",
        "description": "src.prairielearn.python.python_helper_sympy",
        "peekOfCode": "class HasParseError(BaseSympyError):\n    offset: int\n@dataclass\nclass HasEscapeError(BaseSympyError):\n    offset: int\n@dataclass\nclass HasCommentError(BaseSympyError):\n    offset: int\n@dataclass\nclass HasInvalidSymbolError(BaseSympyError):",
        "detail": "src.prairielearn.python.python_helper_sympy",
        "documentation": {}
    },
    {
        "label": "HasEscapeError",
        "kind": 6,
        "importPath": "src.prairielearn.python.python_helper_sympy",
        "description": "src.prairielearn.python.python_helper_sympy",
        "peekOfCode": "class HasEscapeError(BaseSympyError):\n    offset: int\n@dataclass\nclass HasCommentError(BaseSympyError):\n    offset: int\n@dataclass\nclass HasInvalidSymbolError(BaseSympyError):\n    symbol: str\nclass CheckAST(ast.NodeVisitor):\n    whitelist: ASTWhiteListT",
        "detail": "src.prairielearn.python.python_helper_sympy",
        "documentation": {}
    },
    {
        "label": "HasCommentError",
        "kind": 6,
        "importPath": "src.prairielearn.python.python_helper_sympy",
        "description": "src.prairielearn.python.python_helper_sympy",
        "peekOfCode": "class HasCommentError(BaseSympyError):\n    offset: int\n@dataclass\nclass HasInvalidSymbolError(BaseSympyError):\n    symbol: str\nclass CheckAST(ast.NodeVisitor):\n    whitelist: ASTWhiteListT\n    variables: SympyMapT\n    functions: SympyMapT\n    __parents: dict[int, ast.AST]",
        "detail": "src.prairielearn.python.python_helper_sympy",
        "documentation": {}
    },
    {
        "label": "HasInvalidSymbolError",
        "kind": 6,
        "importPath": "src.prairielearn.python.python_helper_sympy",
        "description": "src.prairielearn.python.python_helper_sympy",
        "peekOfCode": "class HasInvalidSymbolError(BaseSympyError):\n    symbol: str\nclass CheckAST(ast.NodeVisitor):\n    whitelist: ASTWhiteListT\n    variables: SympyMapT\n    functions: SympyMapT\n    __parents: dict[int, ast.AST]\n    def __init__(\n        self, whitelist: ASTWhiteListT, variables: SympyMapT, functions: SympyMapT\n    ) -> None:",
        "detail": "src.prairielearn.python.python_helper_sympy",
        "documentation": {}
    },
    {
        "label": "CheckAST",
        "kind": 6,
        "importPath": "src.prairielearn.python.python_helper_sympy",
        "description": "src.prairielearn.python.python_helper_sympy",
        "peekOfCode": "class CheckAST(ast.NodeVisitor):\n    whitelist: ASTWhiteListT\n    variables: SympyMapT\n    functions: SympyMapT\n    __parents: dict[int, ast.AST]\n    def __init__(\n        self, whitelist: ASTWhiteListT, variables: SympyMapT, functions: SympyMapT\n    ) -> None:\n        self.whitelist = whitelist\n        self.variables = variables",
        "detail": "src.prairielearn.python.python_helper_sympy",
        "documentation": {}
    },
    {
        "label": "ast_check_str",
        "kind": 2,
        "importPath": "src.prairielearn.python.python_helper_sympy",
        "description": "src.prairielearn.python.python_helper_sympy",
        "peekOfCode": "def ast_check_str(expr: str, locals_for_eval: LocalsForEval) -> None:\n    # Disallow escape character\n    ind = expr.find(\"\\\\\")\n    if ind != -1:\n        raise HasEscapeError(ind)\n    # Disallow comment character\n    ind = expr.find(\"#\")\n    if ind != -1:\n        raise HasCommentError(ind)\n    # Disallow AST nodes that are not in whitelist",
        "detail": "src.prairielearn.python.python_helper_sympy",
        "documentation": {}
    },
    {
        "label": "sympy_check",
        "kind": 2,
        "importPath": "src.prairielearn.python.python_helper_sympy",
        "description": "src.prairielearn.python.python_helper_sympy",
        "peekOfCode": "def sympy_check(\n    expr: sympy.Expr, locals_for_eval: LocalsForEval, allow_complex: bool\n) -> None:\n    valid_symbols = set().union(\n        *(cast(SympyMapT, inner_dict).keys() for inner_dict in locals_for_eval.values())\n    )\n    work_stack: deque[sympy.Basic] = deque([expr])\n    while work_stack:\n        item = work_stack.pop()\n        str_item = str(item)",
        "detail": "src.prairielearn.python.python_helper_sympy",
        "documentation": {}
    },
    {
        "label": "evaluate",
        "kind": 2,
        "importPath": "src.prairielearn.python.python_helper_sympy",
        "description": "src.prairielearn.python.python_helper_sympy",
        "peekOfCode": "def evaluate(\n    expr: str, locals_for_eval: LocalsForEval, *, allow_complex=False\n) -> sympy.Expr:\n    return evaluate_with_source(expr, locals_for_eval, allow_complex=allow_complex)[0]\ndef evaluate_with_source(\n    expr: str, locals_for_eval: LocalsForEval, *, allow_complex=False\n) -> tuple[sympy.Expr, str]:\n    # Replace '^' with '**' wherever it appears. In MATLAB, either can be used\n    # for exponentiation. In Python, only the latter can be used.\n    expr = pl.full_unidecode(greek_unicode_transform(expr)).replace(\"^\", \"**\")",
        "detail": "src.prairielearn.python.python_helper_sympy",
        "documentation": {}
    },
    {
        "label": "evaluate_with_source",
        "kind": 2,
        "importPath": "src.prairielearn.python.python_helper_sympy",
        "description": "src.prairielearn.python.python_helper_sympy",
        "peekOfCode": "def evaluate_with_source(\n    expr: str, locals_for_eval: LocalsForEval, *, allow_complex=False\n) -> tuple[sympy.Expr, str]:\n    # Replace '^' with '**' wherever it appears. In MATLAB, either can be used\n    # for exponentiation. In Python, only the latter can be used.\n    expr = pl.full_unidecode(greek_unicode_transform(expr)).replace(\"^\", \"**\")\n    local_dict = {\n        k: v\n        for inner_dict in locals_for_eval.values()\n        for k, v in cast(SympyMapT, inner_dict).items()",
        "detail": "src.prairielearn.python.python_helper_sympy",
        "documentation": {}
    },
    {
        "label": "convert_string_to_sympy",
        "kind": 2,
        "importPath": "src.prairielearn.python.python_helper_sympy",
        "description": "src.prairielearn.python.python_helper_sympy",
        "peekOfCode": "def convert_string_to_sympy(\n    expr: str,\n    variables: None | list[str] = None,\n    *,\n    allow_hidden: bool = False,\n    allow_complex: bool = False,\n    allow_trig_functions: bool = True,\n    custom_functions: None | list[str] = None,\n    assumptions: None | AssumptionsDictT = None,\n) -> sympy.Expr:",
        "detail": "src.prairielearn.python.python_helper_sympy",
        "documentation": {}
    },
    {
        "label": "convert_string_to_sympy_with_source",
        "kind": 2,
        "importPath": "src.prairielearn.python.python_helper_sympy",
        "description": "src.prairielearn.python.python_helper_sympy",
        "peekOfCode": "def convert_string_to_sympy_with_source(\n    expr: str,\n    variables: None | list[str] = None,\n    *,\n    allow_hidden: bool = False,\n    allow_complex: bool = False,\n    allow_trig_functions: bool = True,\n    custom_functions: None | list[str] = None,\n    assumptions: None | AssumptionsDictT = None,\n) -> tuple[sympy.Expr, str]:",
        "detail": "src.prairielearn.python.python_helper_sympy",
        "documentation": {}
    },
    {
        "label": "point_to_error",
        "kind": 2,
        "importPath": "src.prairielearn.python.python_helper_sympy",
        "description": "src.prairielearn.python.python_helper_sympy",
        "peekOfCode": "def point_to_error(expr: str, ind: int, w: int = 5) -> str:\n    \"\"\"Generate a string with a pointer to error in expr with index ind\"\"\"\n    w_left: str = \" \" * (ind - max(0, ind - w))\n    w_right: str = \" \" * (min(ind + w, len(expr)) - ind)\n    initial: str = html.escape(expr[ind - len(w_left) : ind + len(w_right)])\n    return f\"{initial}\\n{w_left}^{w_right}\"\ndef sympy_to_json(\n    a: sympy.Expr, *, allow_complex: bool = True, allow_trig_functions: bool = True\n) -> SympyJson:\n    const = _Constants()",
        "detail": "src.prairielearn.python.python_helper_sympy",
        "documentation": {}
    },
    {
        "label": "sympy_to_json",
        "kind": 2,
        "importPath": "src.prairielearn.python.python_helper_sympy",
        "description": "src.prairielearn.python.python_helper_sympy",
        "peekOfCode": "def sympy_to_json(\n    a: sympy.Expr, *, allow_complex: bool = True, allow_trig_functions: bool = True\n) -> SympyJson:\n    const = _Constants()\n    # Get list of variables in the sympy expression\n    variables = list(map(str, a.free_symbols))\n    # Get reserved variables for custom function parsing\n    reserved = (\n        const.helpers.keys()\n        | const.variables.keys()",
        "detail": "src.prairielearn.python.python_helper_sympy",
        "documentation": {}
    },
    {
        "label": "json_to_sympy",
        "kind": 2,
        "importPath": "src.prairielearn.python.python_helper_sympy",
        "description": "src.prairielearn.python.python_helper_sympy",
        "peekOfCode": "def json_to_sympy(\n    sympy_expr_dict: SympyJson,\n    *,\n    allow_complex: bool = True,\n    allow_trig_functions: bool = True,\n) -> sympy.Expr:\n    if \"_type\" not in sympy_expr_dict:\n        raise ValueError(\"json must have key _type for conversion to sympy\")\n    if sympy_expr_dict[\"_type\"] != \"sympy\":\n        raise ValueError('json must have _type == \"sympy\" for conversion to sympy')",
        "detail": "src.prairielearn.python.python_helper_sympy",
        "documentation": {}
    },
    {
        "label": "validate_string_as_sympy",
        "kind": 2,
        "importPath": "src.prairielearn.python.python_helper_sympy",
        "description": "src.prairielearn.python.python_helper_sympy",
        "peekOfCode": "def validate_string_as_sympy(\n    expr: str,\n    variables: None | list[str],\n    *,\n    allow_hidden: bool = False,\n    allow_complex: bool = False,\n    allow_trig_functions: bool = True,\n    custom_functions: None | list[str] = None,\n    imaginary_unit: None | str = None,\n) -> None | str:",
        "detail": "src.prairielearn.python.python_helper_sympy",
        "documentation": {}
    },
    {
        "label": "get_items_list",
        "kind": 2,
        "importPath": "src.prairielearn.python.python_helper_sympy",
        "description": "src.prairielearn.python.python_helper_sympy",
        "peekOfCode": "def get_items_list(items_string: None | str) -> list[str]:\n    if items_string is None:\n        return []\n    return list(map(str.strip, items_string.split(\",\")))\ndef greek_unicode_transform(input_str: str) -> str:\n    \"\"\"\n    Return input_str where all unicode greek letters are replaced\n    by their spelled-out english names.\n    \"\"\"\n    # From https://gist.github.com/beniwohli/765262",
        "detail": "src.prairielearn.python.python_helper_sympy",
        "documentation": {}
    },
    {
        "label": "greek_unicode_transform",
        "kind": 2,
        "importPath": "src.prairielearn.python.python_helper_sympy",
        "description": "src.prairielearn.python.python_helper_sympy",
        "peekOfCode": "def greek_unicode_transform(input_str: str) -> str:\n    \"\"\"\n    Return input_str where all unicode greek letters are replaced\n    by their spelled-out english names.\n    \"\"\"\n    # From https://gist.github.com/beniwohli/765262\n    greek_alphabet = {\n        \"\\u0391\": \"Alpha\",\n        \"\\u0392\": \"Beta\",\n        \"\\u0393\": \"Gamma\",",
        "detail": "src.prairielearn.python.python_helper_sympy",
        "documentation": {}
    },
    {
        "label": "STANDARD_OPERATORS",
        "kind": 5,
        "importPath": "src.prairielearn.python.python_helper_sympy",
        "description": "src.prairielearn.python.python_helper_sympy",
        "peekOfCode": "STANDARD_OPERATORS = (\"( )\", \"+\", \"-\", \"*\", \"/\", \"^\", \"**\", \"!\")\nSympyMapT = dict[str, Callable | sympy.Basic]\nASTWhiteListT = tuple[Type[ast.AST], ...]\nAssumptionsDictT = dict[str, dict[str, Any]]\nclass SympyJson(TypedDict):\n    \"\"\"A class with type signatures for the sympy json dict\"\"\"\n    _type: Literal[\"sympy\"]\n    _value: str\n    _variables: list[str]\n    _assumptions: NotRequired[AssumptionsDictT]",
        "detail": "src.prairielearn.python.python_helper_sympy",
        "documentation": {}
    },
    {
        "label": "SympyMapT",
        "kind": 5,
        "importPath": "src.prairielearn.python.python_helper_sympy",
        "description": "src.prairielearn.python.python_helper_sympy",
        "peekOfCode": "SympyMapT = dict[str, Callable | sympy.Basic]\nASTWhiteListT = tuple[Type[ast.AST], ...]\nAssumptionsDictT = dict[str, dict[str, Any]]\nclass SympyJson(TypedDict):\n    \"\"\"A class with type signatures for the sympy json dict\"\"\"\n    _type: Literal[\"sympy\"]\n    _value: str\n    _variables: list[str]\n    _assumptions: NotRequired[AssumptionsDictT]\n    _custom_functions: NotRequired[list[str]]",
        "detail": "src.prairielearn.python.python_helper_sympy",
        "documentation": {}
    },
    {
        "label": "ASTWhiteListT",
        "kind": 5,
        "importPath": "src.prairielearn.python.python_helper_sympy",
        "description": "src.prairielearn.python.python_helper_sympy",
        "peekOfCode": "ASTWhiteListT = tuple[Type[ast.AST], ...]\nAssumptionsDictT = dict[str, dict[str, Any]]\nclass SympyJson(TypedDict):\n    \"\"\"A class with type signatures for the sympy json dict\"\"\"\n    _type: Literal[\"sympy\"]\n    _value: str\n    _variables: list[str]\n    _assumptions: NotRequired[AssumptionsDictT]\n    _custom_functions: NotRequired[list[str]]\nclass LocalsForEval(TypedDict):",
        "detail": "src.prairielearn.python.python_helper_sympy",
        "documentation": {}
    },
    {
        "label": "AssumptionsDictT",
        "kind": 5,
        "importPath": "src.prairielearn.python.python_helper_sympy",
        "description": "src.prairielearn.python.python_helper_sympy",
        "peekOfCode": "AssumptionsDictT = dict[str, dict[str, Any]]\nclass SympyJson(TypedDict):\n    \"\"\"A class with type signatures for the sympy json dict\"\"\"\n    _type: Literal[\"sympy\"]\n    _value: str\n    _variables: list[str]\n    _assumptions: NotRequired[AssumptionsDictT]\n    _custom_functions: NotRequired[list[str]]\nclass LocalsForEval(TypedDict):\n    \"\"\"A class with type signatures for the locals_for_eval dict\"\"\"",
        "detail": "src.prairielearn.python.python_helper_sympy",
        "documentation": {}
    },
    {
        "label": "TestSympy",
        "kind": 6,
        "importPath": "src.prairielearn.python.python_helper_sympy_test",
        "description": "src.prairielearn.python.python_helper_sympy_test",
        "peekOfCode": "class TestSympy:\n    SYMBOL_NAMES = [\"n\", \"m\", \"alpha\", \"\\u03bc0\"]\n    M, N, ALPHA, MU0 = sympy.symbols(\"m n alpha mu0\")\n    FUNCTION_NAMES = [\"f\", \"g\", \"beef\", \"\\u03c6\"]\n    # Any annotations here to ignore annoying typechecking complaining\n    F: Any = sympy.Function(\"f\")\n    G: Any = sympy.Function(\"g\")\n    BEEF: Any = sympy.Function(\"beef\")\n    PHI: Any = sympy.Function(\"phi\")\n    CUSTOM_FUNCTION_PAIRS = [",
        "detail": "src.prairielearn.python.python_helper_sympy_test",
        "documentation": {}
    },
    {
        "label": "TestExceptions",
        "kind": 6,
        "importPath": "src.prairielearn.python.python_helper_sympy_test",
        "description": "src.prairielearn.python.python_helper_sympy_test",
        "peekOfCode": "class TestExceptions:\n    VARIABLES = [\"n\"]\n    COMPLEX_CASES = [\"i\", \"5 * i\", \"j\", \"I\"]\n    NO_FLOATS_CASES = [\"3.5\", \"4.2n\", \"3.5*n\", \"3.14159*n**2\", \"sin(2.3)\"]\n    INVALID_EXPRESSION_CASES = [\"5==5\", \"5!=5\", \"5>5\", \"5<5\", \"5>=5\", \"5<=5\"]\n    INVALID_FUNCTION_CASES = [\"eval(n)\", \"f(n)\", \"g(n)+cos(n)\", \"dir(n)\", \"sin(f(n))\"]\n    INVALID_VARIABLE_CASES = [\"x\", \"exp(y)\", \"z*n\"]\n    FUNCTION_NOT_CALLED_CASES = [\"2+exp\", \"cos*n\"]\n    INVALID_PARSE_CASES = [\"(\", \"n**\", \"n**2+\", \"!\"]\n    INVALID_ESCAPE_CASES = [\"\\\\\", \"n + 2 \\\\\", \"2 \\\\\"]",
        "detail": "src.prairielearn.python.python_helper_sympy_test",
        "documentation": {}
    },
    {
        "label": "test_evaluate",
        "kind": 2,
        "importPath": "src.prairielearn.python.python_helper_sympy_test",
        "description": "src.prairielearn.python.python_helper_sympy_test",
        "peekOfCode": "def test_evaluate() -> None:\n    \"\"\"Test evaluate in the case of custom functions\"\"\"\n    z = sympy.Symbol(\"z\")\n    f = sympy.Function(\"f\")\n    custom_function = sympy.Function(\"custom_function\")\n    locals_for_eval: phs.LocalsForEval = {\n        \"functions\": {str(f): f, str(custom_function): custom_function},\n        \"variables\": {str(z): z},\n        \"helpers\": {},\n    }",
        "detail": "src.prairielearn.python.python_helper_sympy_test",
        "documentation": {}
    },
    {
        "label": "test_greek_unicode_transform",
        "kind": 2,
        "importPath": "src.prairielearn.python.python_helper_sympy_test",
        "description": "src.prairielearn.python.python_helper_sympy_test",
        "peekOfCode": "def test_greek_unicode_transform(input_str: str, expected_output: str) -> None:\n    assert phs.greek_unicode_transform(input_str) == expected_output",
        "detail": "src.prairielearn.python.python_helper_sympy_test",
        "documentation": {}
    },
    {
        "label": "ElementInfo",
        "kind": 6,
        "importPath": "src.prairielearn.python.question_phases",
        "description": "src.prairielearn.python.question_phases",
        "peekOfCode": "class ElementInfo(TypedDict):\n    name: str\n    controller: str\n    type: Literal[\"core\", \"course\"]\nclass RenderContext(TypedDict):\n    html: str\n    \"\"\"A string consisting of `question.html` with Mustache templating applied.\"\"\"\n    elements: dict[str, ElementInfo]\n    \"\"\"A dict mapping an element name to information about them.\"\"\"\n    element_extensions: dict[str, dict[str, dict]]",
        "detail": "src.prairielearn.python.question_phases",
        "documentation": {}
    },
    {
        "label": "RenderContext",
        "kind": 6,
        "importPath": "src.prairielearn.python.question_phases",
        "description": "src.prairielearn.python.question_phases",
        "peekOfCode": "class RenderContext(TypedDict):\n    html: str\n    \"\"\"A string consisting of `question.html` with Mustache templating applied.\"\"\"\n    elements: dict[str, ElementInfo]\n    \"\"\"A dict mapping an element name to information about them.\"\"\"\n    element_extensions: dict[str, dict[str, dict]]\n    \"\"\"A dict mapping an element name to a dict of extensions for that element.\"\"\"\n    course_path: str\n    \"\"\"The path to the course directory.\"\"\"\ndef filelike_to_string(filelike: Any) -> str:",
        "detail": "src.prairielearn.python.question_phases",
        "documentation": {}
    },
    {
        "label": "filelike_to_string",
        "kind": 2,
        "importPath": "src.prairielearn.python.question_phases",
        "description": "src.prairielearn.python.question_phases",
        "peekOfCode": "def filelike_to_string(filelike: Any) -> str:\n    # if val is None, replace it with empty string\n    if filelike is None:\n        filelike = \"\"\n    # if val is a file-like object, read whatever is inside\n    if isinstance(filelike, io.IOBase):\n        filelike.seek(0)\n        filelike = filelike.read()\n    # if val is a string, treat it as utf-8\n    if isinstance(filelike, str):",
        "detail": "src.prairielearn.python.question_phases",
        "documentation": {}
    },
    {
        "label": "process",
        "kind": 2,
        "importPath": "src.prairielearn.python.question_phases",
        "description": "src.prairielearn.python.question_phases",
        "peekOfCode": "def process(\n    phase: Phase, data: dict, context: RenderContext\n) -> Tuple[Optional[str], set[str]]:\n    html = context[\"html\"]\n    elements = context[\"elements\"]\n    course_path = context[\"course_path\"]\n    # This will track which elements have been processed.\n    processed_elements: set[str] = set()\n    # If we're in the `render` phase, we'll eventually capture the HTML here.\n    # If we're in the `file` phase, we'll capture file data here.",
        "detail": "src.prairielearn.python.question_phases",
        "documentation": {}
    },
    {
        "label": "prepare_data",
        "kind": 2,
        "importPath": "src.prairielearn.python.question_phases",
        "description": "src.prairielearn.python.question_phases",
        "peekOfCode": "def prepare_data(\n    phase: Phase, data: dict, context: RenderContext, element: lxml.html.HtmlElement\n) -> None:\n    element_extensions = context[\"element_extensions\"]\n    element_info = context[\"elements\"][element.tag]\n    # Make a deep copy of the data so that question/element code can't\n    # modify the source data.\n    data[\"extensions\"] = copy.deepcopy(element_extensions.get(element.tag, {}))\n    # `*_url` options are only present during the render phase.\n    if phase == \"render\":",
        "detail": "src.prairielearn.python.question_phases",
        "documentation": {}
    },
    {
        "label": "restore_data",
        "kind": 2,
        "importPath": "src.prairielearn.python.question_phases",
        "description": "src.prairielearn.python.question_phases",
        "peekOfCode": "def restore_data(data: dict) -> None:\n    data.pop(\"extensions\", None)\n    data[\"options\"].pop(\"client_files_element_url\", None)\n    data[\"options\"].pop(\"client_files_extensions_url\", None)",
        "detail": "src.prairielearn.python.question_phases",
        "documentation": {}
    },
    {
        "label": "PYTHON_PATH",
        "kind": 5,
        "importPath": "src.prairielearn.python.question_phases",
        "description": "src.prairielearn.python.question_phases",
        "peekOfCode": "PYTHON_PATH = pathlib.Path(__file__).parent.parent.resolve()\nCORE_ELEMENTS_PATH = (PYTHON_PATH / \"elements\").resolve()\nSAVED_PATH = copy.copy(sys.path)\nclass ElementInfo(TypedDict):\n    name: str\n    controller: str\n    type: Literal[\"core\", \"course\"]\nclass RenderContext(TypedDict):\n    html: str\n    \"\"\"A string consisting of `question.html` with Mustache templating applied.\"\"\"",
        "detail": "src.prairielearn.python.question_phases",
        "documentation": {}
    },
    {
        "label": "CORE_ELEMENTS_PATH",
        "kind": 5,
        "importPath": "src.prairielearn.python.question_phases",
        "description": "src.prairielearn.python.question_phases",
        "peekOfCode": "CORE_ELEMENTS_PATH = (PYTHON_PATH / \"elements\").resolve()\nSAVED_PATH = copy.copy(sys.path)\nclass ElementInfo(TypedDict):\n    name: str\n    controller: str\n    type: Literal[\"core\", \"course\"]\nclass RenderContext(TypedDict):\n    html: str\n    \"\"\"A string consisting of `question.html` with Mustache templating applied.\"\"\"\n    elements: dict[str, ElementInfo]",
        "detail": "src.prairielearn.python.question_phases",
        "documentation": {}
    },
    {
        "label": "SAVED_PATH",
        "kind": 5,
        "importPath": "src.prairielearn.python.question_phases",
        "description": "src.prairielearn.python.question_phases",
        "peekOfCode": "SAVED_PATH = copy.copy(sys.path)\nclass ElementInfo(TypedDict):\n    name: str\n    controller: str\n    type: Literal[\"core\", \"course\"]\nclass RenderContext(TypedDict):\n    html: str\n    \"\"\"A string consisting of `question.html` with Mustache templating applied.\"\"\"\n    elements: dict[str, ElementInfo]\n    \"\"\"A dict mapping an element name to information about them.\"\"\"",
        "detail": "src.prairielearn.python.question_phases",
        "documentation": {}
    },
    {
        "label": "to_precision",
        "kind": 2,
        "importPath": "src.prairielearn.python.to_precision",
        "description": "src.prairielearn.python.to_precision",
        "peekOfCode": "def to_precision(value, precision, notation=\"auto\", filler=\"e\"):\n    \"\"\"\n    converts a value to the specified notation and precision\n    value - any type that can be converted to a float\n    predision - integer that is greater than zero\n    notation - string\n        'auto' - selects standard notation when -1000 < value < 1000 else returns scientific notation\n        'sci' or 'scientific' - returns scientific notation\n            ref: https://www.mathsisfun.com/numbers/scientific-notation.html\n        'eng' or 'engineering' - returns engineering notation",
        "detail": "src.prairielearn.python.to_precision",
        "documentation": {}
    },
    {
        "label": "std_notation",
        "kind": 2,
        "importPath": "src.prairielearn.python.to_precision",
        "description": "src.prairielearn.python.to_precision",
        "peekOfCode": "def std_notation(value, precision, extra=None):\n    \"\"\"\n    standard notation (US version)\n    ref: http://www.mathsisfun.com/definitions/standard-notation.html\n    returns a string of value with the proper precision\n    ex:\n        std_notation(5, 2) => 5.0\n        std_notation(5.36, 2) => 5.4\n        std_notation(5360, 2) => 5400\n        std_notation(0.05363, 3) => 0.0536",
        "detail": "src.prairielearn.python.to_precision",
        "documentation": {}
    },
    {
        "label": "sci_notation",
        "kind": 2,
        "importPath": "src.prairielearn.python.to_precision",
        "description": "src.prairielearn.python.to_precision",
        "peekOfCode": "def sci_notation(value, precision, filler):\n    \"\"\"\n    scientific notation\n    ref: https://www.mathsisfun.com/numbers/scientific-notation.html\n    returns a string of value with the proper precision and 10s exponent\n    filler is placed between the decimal value and 10s exponent\n    ex:\n        sci_notation(123, 1, 'E') => 1E2\n        sci_notation(123, 3, 'E') => 1.23E2\n        sci_notation(.126, 2, 'E') => 1.3E-1",
        "detail": "src.prairielearn.python.to_precision",
        "documentation": {}
    },
    {
        "label": "eng_notation",
        "kind": 2,
        "importPath": "src.prairielearn.python.to_precision",
        "description": "src.prairielearn.python.to_precision",
        "peekOfCode": "def eng_notation(value, precision, filler):\n    \"\"\"\n    engineering notation\n    ref: http://www.mathsisfun.com/definitions/engineering-notation.html\n    returns a string of value with the proper precision and 10s exponent that is divisable by 3\n    filler is placed between the decimal value and 10s exponent\n    ex:\n        sci_notation(123, 1, 'E') => 100E0\n        sci_notation(1230, 3, 'E') => 1.23E3\n        sci_notation(.126, 2, 'E') => 120E-3",
        "detail": "src.prairielearn.python.to_precision",
        "documentation": {}
    },
    {
        "label": "__author__",
        "kind": 5,
        "importPath": "src.prairielearn.python.to_precision",
        "description": "src.prairielearn.python.to_precision",
        "peekOfCode": "__author__ = \"William Rusnack github.com/BebeSparkelSparkel linkedin.com/in/williamrusnack williamrusnack@gmail.com\"\nimport math\ndef to_precision(value, precision, notation=\"auto\", filler=\"e\"):\n    \"\"\"\n    converts a value to the specified notation and precision\n    value - any type that can be converted to a float\n    predision - integer that is greater than zero\n    notation - string\n        'auto' - selects standard notation when -1000 < value < 1000 else returns scientific notation\n        'sci' or 'scientific' - returns scientific notation",
        "detail": "src.prairielearn.python.to_precision",
        "documentation": {}
    },
    {
        "label": "traverse_and_execute",
        "kind": 2,
        "importPath": "src.prairielearn.python.traverse",
        "description": "src.prairielearn.python.traverse",
        "peekOfCode": "def traverse_and_execute(\n    html: str, fn: Callable[[lxml.html.HtmlElement], None]\n) -> None:\n    elements = lxml.html.fragments_fromstring(html)\n    for e in chain.from_iterable(\n        element.iter()\n        for element in elements\n        # If there's leading text, the first element of the array will be a string.\n        # We can just discard that.\n        if isinstance(element, lxml.html.HtmlElement)",
        "detail": "src.prairielearn.python.traverse",
        "documentation": {}
    },
    {
        "label": "format_attrib_value",
        "kind": 2,
        "importPath": "src.prairielearn.python.traverse",
        "description": "src.prairielearn.python.traverse",
        "peekOfCode": "def format_attrib_value(v: str) -> str:\n    # https://html.spec.whatwg.org/multipage/parsing.html#escapingString\n    return v.replace(\"&\", \"&amp;\").replace('\"', \"&quot;\").replace(\"\\xa0\", \"&nbsp;\")\ndef get_source_definition(element: lxml.html.HtmlElement) -> str:\n    attributes = (\n        f'''{k}=\"{format_attrib_value(v)}\"''' for k, v in element.attrib.items()\n    )\n    return f\"<{' '.join((element.tag, *attributes))}>\"\ndef traverse_and_replace(\n    html: str, replace: Callable[[lxml.html.HtmlElement], ElementReplacement]",
        "detail": "src.prairielearn.python.traverse",
        "documentation": {}
    },
    {
        "label": "get_source_definition",
        "kind": 2,
        "importPath": "src.prairielearn.python.traverse",
        "description": "src.prairielearn.python.traverse",
        "peekOfCode": "def get_source_definition(element: lxml.html.HtmlElement) -> str:\n    attributes = (\n        f'''{k}=\"{format_attrib_value(v)}\"''' for k, v in element.attrib.items()\n    )\n    return f\"<{' '.join((element.tag, *attributes))}>\"\ndef traverse_and_replace(\n    html: str, replace: Callable[[lxml.html.HtmlElement], ElementReplacement]\n) -> str:\n    \"\"\"\n    Perform traversal and element replacement on HTML with the given replace function.",
        "detail": "src.prairielearn.python.traverse",
        "documentation": {}
    },
    {
        "label": "traverse_and_replace",
        "kind": 2,
        "importPath": "src.prairielearn.python.traverse",
        "description": "src.prairielearn.python.traverse",
        "peekOfCode": "def traverse_and_replace(\n    html: str, replace: Callable[[lxml.html.HtmlElement], ElementReplacement]\n) -> str:\n    \"\"\"\n    Perform traversal and element replacement on HTML with the given replace function.\n    In short, uses stacks to track what has been parsed already and what still needs to be parsed.\n    The count_stack tracks how many children each unclosed tag (contained in the tail_stack) has.\n    The top entry in count_stack is decremented every time something is moved onto result,\n    and when an entry hits zero, the corresponding tag from tail_stack is moved onto result as well.\n    \"\"\"",
        "detail": "src.prairielearn.python.traverse",
        "documentation": {}
    },
    {
        "label": "ElementReplacement",
        "kind": 5,
        "importPath": "src.prairielearn.python.traverse",
        "description": "src.prairielearn.python.traverse",
        "peekOfCode": "ElementReplacement = Optional[\n    Union[str, lxml.html.HtmlElement, List[lxml.html.HtmlElement]]\n]\n# https://developer.mozilla.org/en-US/docs/Glossary/Void_element\nVOID_ELEMENTS = frozenset(\n    {\n        \"area\",\n        \"base\",\n        \"br\",\n        \"col\",",
        "detail": "src.prairielearn.python.traverse",
        "documentation": {}
    },
    {
        "label": "VOID_ELEMENTS",
        "kind": 5,
        "importPath": "src.prairielearn.python.traverse",
        "description": "src.prairielearn.python.traverse",
        "peekOfCode": "VOID_ELEMENTS = frozenset(\n    {\n        \"area\",\n        \"base\",\n        \"br\",\n        \"col\",\n        \"embed\",\n        \"hr\",\n        \"img\",\n        \"input\",",
        "detail": "src.prairielearn.python.traverse",
        "documentation": {}
    },
    {
        "label": "UNESCAPED_ELEMENTS",
        "kind": 5,
        "importPath": "src.prairielearn.python.traverse",
        "description": "src.prairielearn.python.traverse",
        "peekOfCode": "UNESCAPED_ELEMENTS = frozenset({\"script\", \"style\"})\ndef traverse_and_execute(\n    html: str, fn: Callable[[lxml.html.HtmlElement], None]\n) -> None:\n    elements = lxml.html.fragments_fromstring(html)\n    for e in chain.from_iterable(\n        element.iter()\n        for element in elements\n        # If there's leading text, the first element of the array will be a string.\n        # We can just discard that.",
        "detail": "src.prairielearn.python.traverse",
        "documentation": {}
    },
    {
        "label": "test_traverse_and_execute",
        "kind": 2,
        "importPath": "src.prairielearn.python.traverse_test",
        "description": "src.prairielearn.python.traverse_test",
        "peekOfCode": "def test_traverse_and_execute() -> None:\n    text: List[str] = []\n    tags: List[str] = []\n    def capture_element(element) -> None:\n        if element.text:\n            text.append(element.text)\n        tags.append(element.tag)\n    traverse_and_execute(\"<p><i>Hello</i> <strong>world</strong></p>\", capture_element)\n    assert text == [\"Hello\", \"world\"]\n    assert tags == [\"p\", \"i\", \"strong\"]",
        "detail": "src.prairielearn.python.traverse_test",
        "documentation": {}
    },
    {
        "label": "test_traverse_and_replace_text",
        "kind": 2,
        "importPath": "src.prairielearn.python.traverse_test",
        "description": "src.prairielearn.python.traverse_test",
        "peekOfCode": "def test_traverse_and_replace_text() -> None:\n    html = traverse_and_replace(\"Hello\", lambda e: \"Goodbye\")\n    assert html == \"Hello\"\ndef test_traverse_and_replace_none() -> None:\n    html = traverse_and_replace(\"<p>Hello</p>\", lambda e: None)\n    assert html == \"\"\ndef test_traverse_and_replace_comment() -> None:\n    def replace(e) -> ElementReplacement:\n        if e.tag == \"p\":\n            return \"<!-- Goodbye --><i>world</i>\"",
        "detail": "src.prairielearn.python.traverse_test",
        "documentation": {}
    },
    {
        "label": "test_traverse_and_replace_none",
        "kind": 2,
        "importPath": "src.prairielearn.python.traverse_test",
        "description": "src.prairielearn.python.traverse_test",
        "peekOfCode": "def test_traverse_and_replace_none() -> None:\n    html = traverse_and_replace(\"<p>Hello</p>\", lambda e: None)\n    assert html == \"\"\ndef test_traverse_and_replace_comment() -> None:\n    def replace(e) -> ElementReplacement:\n        if e.tag == \"p\":\n            return \"<!-- Goodbye --><i>world</i>\"\n        return e\n    html = traverse_and_replace(\"<p>Hello</p>\", replace)\n    assert html == \"<!-- Goodbye --><i>world</i>\"",
        "detail": "src.prairielearn.python.traverse_test",
        "documentation": {}
    },
    {
        "label": "test_traverse_and_replace_comment",
        "kind": 2,
        "importPath": "src.prairielearn.python.traverse_test",
        "description": "src.prairielearn.python.traverse_test",
        "peekOfCode": "def test_traverse_and_replace_comment() -> None:\n    def replace(e) -> ElementReplacement:\n        if e.tag == \"p\":\n            return \"<!-- Goodbye --><i>world</i>\"\n        return e\n    html = traverse_and_replace(\"<p>Hello</p>\", replace)\n    assert html == \"<!-- Goodbye --><i>world</i>\"\ndef test_traverse_and_replace_comment_nested() -> None:\n    def replace(e) -> ElementReplacement:\n        if e.tag == \"span\":",
        "detail": "src.prairielearn.python.traverse_test",
        "documentation": {}
    },
    {
        "label": "test_traverse_and_replace_comment_nested",
        "kind": 2,
        "importPath": "src.prairielearn.python.traverse_test",
        "description": "src.prairielearn.python.traverse_test",
        "peekOfCode": "def test_traverse_and_replace_comment_nested() -> None:\n    def replace(e) -> ElementReplacement:\n        if e.tag == \"span\":\n            return \"<!-- Goodbye --><strong>world</strong>\"\n        return e\n    html = traverse_and_replace(\"<p><span>Hello</span></p>\", replace)\n    assert html == \"<p><!-- Goodbye --><strong>world</strong></p>\"\ndef test_traverse_and_replace_comment_with_text() -> None:\n    def replace(e) -> ElementReplacement:\n        return e",
        "detail": "src.prairielearn.python.traverse_test",
        "documentation": {}
    },
    {
        "label": "test_traverse_and_replace_comment_with_text",
        "kind": 2,
        "importPath": "src.prairielearn.python.traverse_test",
        "description": "src.prairielearn.python.traverse_test",
        "peekOfCode": "def test_traverse_and_replace_comment_with_text() -> None:\n    def replace(e) -> ElementReplacement:\n        return e\n    html = traverse_and_replace(\"<div><!-- Hello --> world</div>\", replace)\n    assert html == \"<div><!-- Hello --> world</div>\"\ndef test_traverse_and_replace_nested_none() -> None:\n    def replace(e) -> ElementReplacement:\n        if e.tag == \"strong\":\n            return None\n        return e",
        "detail": "src.prairielearn.python.traverse_test",
        "documentation": {}
    },
    {
        "label": "test_traverse_and_replace_nested_none",
        "kind": 2,
        "importPath": "src.prairielearn.python.traverse_test",
        "description": "src.prairielearn.python.traverse_test",
        "peekOfCode": "def test_traverse_and_replace_nested_none() -> None:\n    def replace(e) -> ElementReplacement:\n        if e.tag == \"strong\":\n            return None\n        return e\n    html = traverse_and_replace(\"<p><strong>Hello</strong> world</p>\", replace)\n    # The leading space is consistent with the DOM's behavior if a node is removed.\n    assert html == \"<p> world</p>\"\ndef test_traverse_and_replace_empty() -> None:\n    html = traverse_and_replace(\"<p>Hello</p>\", lambda e: \"\")",
        "detail": "src.prairielearn.python.traverse_test",
        "documentation": {}
    },
    {
        "label": "test_traverse_and_replace_empty",
        "kind": 2,
        "importPath": "src.prairielearn.python.traverse_test",
        "description": "src.prairielearn.python.traverse_test",
        "peekOfCode": "def test_traverse_and_replace_empty() -> None:\n    html = traverse_and_replace(\"<p>Hello</p>\", lambda e: \"\")\n    assert html == \"\"\ndef test_traverse_and_replace_identity() -> None:\n    html = traverse_and_replace(\"<p>Hello</p>\", lambda e: e)\n    assert html == \"<p>Hello</p>\"\ndef test_traverse_and_replace_fragment() -> None:\n    def replace(e) -> ElementReplacement:\n        if e.tag == \"p\":\n            return \"<strong>Goodbye</strong>\"",
        "detail": "src.prairielearn.python.traverse_test",
        "documentation": {}
    },
    {
        "label": "test_traverse_and_replace_identity",
        "kind": 2,
        "importPath": "src.prairielearn.python.traverse_test",
        "description": "src.prairielearn.python.traverse_test",
        "peekOfCode": "def test_traverse_and_replace_identity() -> None:\n    html = traverse_and_replace(\"<p>Hello</p>\", lambda e: e)\n    assert html == \"<p>Hello</p>\"\ndef test_traverse_and_replace_fragment() -> None:\n    def replace(e) -> ElementReplacement:\n        if e.tag == \"p\":\n            return \"<strong>Goodbye</strong>\"\n        return e\n    html = traverse_and_replace(\"<p>Hello</p>\", replace)\n    assert html == \"<strong>Goodbye</strong>\"",
        "detail": "src.prairielearn.python.traverse_test",
        "documentation": {}
    },
    {
        "label": "test_traverse_and_replace_fragment",
        "kind": 2,
        "importPath": "src.prairielearn.python.traverse_test",
        "description": "src.prairielearn.python.traverse_test",
        "peekOfCode": "def test_traverse_and_replace_fragment() -> None:\n    def replace(e) -> ElementReplacement:\n        if e.tag == \"p\":\n            return \"<strong>Goodbye</strong>\"\n        return e\n    html = traverse_and_replace(\"<p>Hello</p>\", replace)\n    assert html == \"<strong>Goodbye</strong>\"\ndef test_traverse_and_replace_fragments() -> None:\n    def replace(e) -> ElementReplacement:\n        if e.tag == \"p\":",
        "detail": "src.prairielearn.python.traverse_test",
        "documentation": {}
    },
    {
        "label": "test_traverse_and_replace_fragments",
        "kind": 2,
        "importPath": "src.prairielearn.python.traverse_test",
        "description": "src.prairielearn.python.traverse_test",
        "peekOfCode": "def test_traverse_and_replace_fragments() -> None:\n    def replace(e) -> ElementReplacement:\n        if e.tag == \"p\":\n            return \"<strong>Goodbye</strong><strong>Goodbye</strong>\"\n        return e\n    html = traverse_and_replace(\"<p>Hello</p>\", replace)\n    assert html == \"<strong>Goodbye</strong><strong>Goodbye</strong>\"\ndef traverse_and_replace_nested() -> None:\n    def replace(e) -> ElementReplacement:\n        if e.tag == \"strong\":",
        "detail": "src.prairielearn.python.traverse_test",
        "documentation": {}
    },
    {
        "label": "traverse_and_replace_nested",
        "kind": 2,
        "importPath": "src.prairielearn.python.traverse_test",
        "description": "src.prairielearn.python.traverse_test",
        "peekOfCode": "def traverse_and_replace_nested() -> None:\n    def replace(e) -> ElementReplacement:\n        if e.tag == \"strong\":\n            return \"<em>Goodbye</em>\"\n        return e\n    html = traverse_and_replace(\"<p><strong>Hello</strong></p>\", replace)\n    assert html == \"<p><em>Goodbye</em></p>\"\ndef test_traverse_and_replace_recursive() -> None:\n    def replace(e) -> ElementReplacement:\n        if e.tag == \"p\":",
        "detail": "src.prairielearn.python.traverse_test",
        "documentation": {}
    },
    {
        "label": "test_traverse_and_replace_recursive",
        "kind": 2,
        "importPath": "src.prairielearn.python.traverse_test",
        "description": "src.prairielearn.python.traverse_test",
        "peekOfCode": "def test_traverse_and_replace_recursive() -> None:\n    def replace(e) -> ElementReplacement:\n        if e.tag == \"p\":\n            return \"<strong>Goodbye</strong>\"\n        elif e.tag == \"strong\":\n            return \"<em>Goodbye</em>\"\n        return e\n    html = traverse_and_replace(\"<p>Hello</p>\", replace)\n    assert html == \"<em>Goodbye</em>\"\ndef test_traverse_and_replace_nested_trailing_text() -> None:",
        "detail": "src.prairielearn.python.traverse_test",
        "documentation": {}
    },
    {
        "label": "test_traverse_and_replace_nested_trailing_text",
        "kind": 2,
        "importPath": "src.prairielearn.python.traverse_test",
        "description": "src.prairielearn.python.traverse_test",
        "peekOfCode": "def test_traverse_and_replace_nested_trailing_text() -> None:\n    def replace(e) -> ElementReplacement:\n        if e.tag == \"strong\":\n            return \"<em>Goodbye</em>\"\n        return e\n    html = traverse_and_replace(\"<p><strong>Hello</strong> world</p>\", replace)\n    assert html == \"<p><em>Goodbye</em> world</p>\"\ndef test_traverse_and_replace_leading_trailing_text() -> None:\n    html = traverse_and_replace(\"Hello <i>cruel</i> world\", lambda e: \"beautiful\")\n    assert html == \"Hello beautiful world\"",
        "detail": "src.prairielearn.python.traverse_test",
        "documentation": {}
    },
    {
        "label": "test_traverse_and_replace_leading_trailing_text",
        "kind": 2,
        "importPath": "src.prairielearn.python.traverse_test",
        "description": "src.prairielearn.python.traverse_test",
        "peekOfCode": "def test_traverse_and_replace_leading_trailing_text() -> None:\n    html = traverse_and_replace(\"Hello <i>cruel</i> world\", lambda e: \"beautiful\")\n    assert html == \"Hello beautiful world\"\ndef test_traverse_and_replace_leading_trailing_recursive() -> None:\n    def replace(e) -> ElementReplacement:\n        if e.tag == \"i\":\n            return \"<em>beautiful</em>\"\n        return e\n    html = traverse_and_replace(\"Hello <i>cruel</i> world\", replace)\n    assert html == \"Hello <em>beautiful</em> world\"",
        "detail": "src.prairielearn.python.traverse_test",
        "documentation": {}
    },
    {
        "label": "test_traverse_and_replace_leading_trailing_recursive",
        "kind": 2,
        "importPath": "src.prairielearn.python.traverse_test",
        "description": "src.prairielearn.python.traverse_test",
        "peekOfCode": "def test_traverse_and_replace_leading_trailing_recursive() -> None:\n    def replace(e) -> ElementReplacement:\n        if e.tag == \"i\":\n            return \"<em>beautiful</em>\"\n        return e\n    html = traverse_and_replace(\"Hello <i>cruel</i> world\", replace)\n    assert html == \"Hello <em>beautiful</em> world\"\ndef test_traverse_and_replace_leading_trailing_recursive_2() -> None:\n    def replace(e) -> ElementReplacement:\n        if e.tag == \"i\":",
        "detail": "src.prairielearn.python.traverse_test",
        "documentation": {}
    },
    {
        "label": "test_traverse_and_replace_leading_trailing_recursive_2",
        "kind": 2,
        "importPath": "src.prairielearn.python.traverse_test",
        "description": "src.prairielearn.python.traverse_test",
        "peekOfCode": "def test_traverse_and_replace_leading_trailing_recursive_2() -> None:\n    def replace(e) -> ElementReplacement:\n        if e.tag == \"i\":\n            return \"<em>beautiful</em>\"\n        if e.tag == \"em\":\n            return \"beautiful\"\n        return e\n    html = traverse_and_replace(\"Hello <i>cruel</i> world\", replace)\n    assert html == \"Hello beautiful world\"\ndef test_traverse_and_replace_leading_trailing_recursive_3() -> None:",
        "detail": "src.prairielearn.python.traverse_test",
        "documentation": {}
    },
    {
        "label": "test_traverse_and_replace_leading_trailing_recursive_3",
        "kind": 2,
        "importPath": "src.prairielearn.python.traverse_test",
        "description": "src.prairielearn.python.traverse_test",
        "peekOfCode": "def test_traverse_and_replace_leading_trailing_recursive_3() -> None:\n    def replace(e) -> ElementReplacement:\n        if e.tag == \"i\":\n            return \"really <em>beautiful</em> green\"\n        if e.tag == \"em\":\n            return \"beautiful\"\n        return e\n    html = traverse_and_replace(\"Hello <i>cruel</i> world\", replace)\n    assert html == \"Hello really beautiful green world\"\ndef test_traverse_and_replace_leading_trailing_recursive_4() -> None:",
        "detail": "src.prairielearn.python.traverse_test",
        "documentation": {}
    },
    {
        "label": "test_traverse_and_replace_leading_trailing_recursive_4",
        "kind": 2,
        "importPath": "src.prairielearn.python.traverse_test",
        "description": "src.prairielearn.python.traverse_test",
        "peekOfCode": "def test_traverse_and_replace_leading_trailing_recursive_4() -> None:\n    def replace(e) -> ElementReplacement:\n        if e.tag == \"i\":\n            return \"really <em>beautiful</em> green\"\n        if e.tag == \"em\":\n            return \"beautiful\"\n        return e\n    html = traverse_and_replace(\"<div>Hello <i>cruel</i> world</div>\", replace)\n    assert html == \"<div>Hello really beautiful green world</div>\"\ndef test_traverse_and_replace_leading_trailing_recursive_5() -> None:",
        "detail": "src.prairielearn.python.traverse_test",
        "documentation": {}
    },
    {
        "label": "test_traverse_and_replace_leading_trailing_recursive_5",
        "kind": 2,
        "importPath": "src.prairielearn.python.traverse_test",
        "description": "src.prairielearn.python.traverse_test",
        "peekOfCode": "def test_traverse_and_replace_leading_trailing_recursive_5() -> None:\n    def replace(e) -> ElementReplacement:\n        if e.tag == \"em\":\n            return \"big\"\n        if e.tag == \"i\":\n            return \"beautiful\"\n        return e\n    html = traverse_and_replace(\n        \"<div>Hello <em>small</em> and <i>cruel</i> world</div>\", replace\n    )",
        "detail": "src.prairielearn.python.traverse_test",
        "documentation": {}
    },
    {
        "label": "test_traverse_and_replace_leading_trailing_recursive_6",
        "kind": 2,
        "importPath": "src.prairielearn.python.traverse_test",
        "description": "src.prairielearn.python.traverse_test",
        "peekOfCode": "def test_traverse_and_replace_leading_trailing_recursive_6() -> None:\n    def replace(e) -> ElementReplacement:\n        if e.tag == \"em\":\n            return \"<strong>big</strong>\"\n        if e.tag == \"i\":\n            return \"beautiful\"\n        return e\n    html = traverse_and_replace(\n        \"<div>Hello <em>small</em> and <i>cruel</i> world</div>\", replace\n    )",
        "detail": "src.prairielearn.python.traverse_test",
        "documentation": {}
    },
    {
        "label": "test_traverse_and_replace_leading_trailing_recursive_7",
        "kind": 2,
        "importPath": "src.prairielearn.python.traverse_test",
        "description": "src.prairielearn.python.traverse_test",
        "peekOfCode": "def test_traverse_and_replace_leading_trailing_recursive_7() -> None:\n    def replace(e) -> ElementReplacement:\n        if e.tag == \"em\":\n            return \"<strong>big</strong>, green,\"\n        if e.tag == \"i\":\n            return \"beautiful\"\n        return e\n    html = traverse_and_replace(\n        \"<div>Hello <em>small</em> and <i>cruel</i> world</div>\", replace\n    )",
        "detail": "src.prairielearn.python.traverse_test",
        "documentation": {}
    },
    {
        "label": "test_traverse_and_replace_leading_trailing_recursive_8",
        "kind": 2,
        "importPath": "src.prairielearn.python.traverse_test",
        "description": "src.prairielearn.python.traverse_test",
        "peekOfCode": "def test_traverse_and_replace_leading_trailing_recursive_8() -> None:\n    def replace(e) -> ElementReplacement:\n        if e.tag == \"em\":\n            return \"green, <strong>big</strong>\"\n        if e.tag == \"i\":\n            return \"beautiful\"\n        return e\n    html = traverse_and_replace(\n        \"<div>Hello <em>small</em> and <i>cruel</i> world</div>\", replace\n    )",
        "detail": "src.prairielearn.python.traverse_test",
        "documentation": {}
    },
    {
        "label": "test_traverse_indentation",
        "kind": 2,
        "importPath": "src.prairielearn.python.traverse_test",
        "description": "src.prairielearn.python.traverse_test",
        "peekOfCode": "def test_traverse_indentation() -> None:\n    original_html = \"<div><pre><code>def hello(msg):\\n    print(msg)</code></pre></div>\"\n    html = traverse_and_replace(\n        original_html,\n        lambda e: e,\n    )\n    assert html == original_html\ndef test_traverse_and_replace_attribute_quotes() -> None:\n    def replace(e) -> ElementReplacement:\n        if e.tag == \"span\":",
        "detail": "src.prairielearn.python.traverse_test",
        "documentation": {}
    },
    {
        "label": "test_traverse_and_replace_attribute_quotes",
        "kind": 2,
        "importPath": "src.prairielearn.python.traverse_test",
        "description": "src.prairielearn.python.traverse_test",
        "peekOfCode": "def test_traverse_and_replace_attribute_quotes() -> None:\n    def replace(e) -> ElementReplacement:\n        if e.tag == \"span\":\n            return \"<strong attr1='a\\\"b' attr2=\\\"a'b\\\">Goodbye</strong>\"\n        return e\n    html = traverse_and_replace(\n        \"<div><span>Hello</span></div>\",\n        replace,\n    )\n    assert html == '<div><strong attr1=\"a&quot;b\" attr2=\"a\\'b\">Goodbye</strong></div>'",
        "detail": "src.prairielearn.python.traverse_test",
        "documentation": {}
    },
    {
        "label": "test_traverse_and_replace_attribute_nbsp",
        "kind": 2,
        "importPath": "src.prairielearn.python.traverse_test",
        "description": "src.prairielearn.python.traverse_test",
        "peekOfCode": "def test_traverse_and_replace_attribute_nbsp() -> None:\n    def replace(e) -> ElementReplacement:\n        if e.tag == \"div\":\n            return '<span attr=\"foo &nbsp; bar\">Goodbye</span>'\n        return e\n    html = traverse_and_replace(\n        \"<div>Hello</div>\",\n        replace,\n    )\n    assert html == '<span attr=\"foo &nbsp; bar\">Goodbye</span>'",
        "detail": "src.prairielearn.python.traverse_test",
        "documentation": {}
    },
    {
        "label": "test_traverse_and_replace_attribute_ampersand",
        "kind": 2,
        "importPath": "src.prairielearn.python.traverse_test",
        "description": "src.prairielearn.python.traverse_test",
        "peekOfCode": "def test_traverse_and_replace_attribute_ampersand() -> None:\n    def replace(e) -> ElementReplacement:\n        if e.tag == \"div\":\n            return '<span attr=\"foo & bar\">Goodbye</span>'\n        return e\n    html = traverse_and_replace(\n        \"<div>Hello</div>\",\n        replace,\n    )\n    assert html == '<span attr=\"foo &amp; bar\">Goodbye</span>'",
        "detail": "src.prairielearn.python.traverse_test",
        "documentation": {}
    },
    {
        "label": "test_traverse_and_replace_void_elements",
        "kind": 2,
        "importPath": "src.prairielearn.python.traverse_test",
        "description": "src.prairielearn.python.traverse_test",
        "peekOfCode": "def test_traverse_and_replace_void_elements() -> None:\n    def replace(e) -> ElementReplacement:\n        return e\n    html = traverse_and_replace('<div><br><input name=\"input\"</div>', replace)\n    assert html == '<div><br><input name=\"input\"></div>'\ndef test_traverse_and_replace_angle_brackets() -> None:\n    def replace(e) -> ElementReplacement:\n        if e.tag == \"pl-code\":\n            return \"<pre><code>&lt;div&gt;</code></pre>\"\n        return e",
        "detail": "src.prairielearn.python.traverse_test",
        "documentation": {}
    },
    {
        "label": "test_traverse_and_replace_angle_brackets",
        "kind": 2,
        "importPath": "src.prairielearn.python.traverse_test",
        "description": "src.prairielearn.python.traverse_test",
        "peekOfCode": "def test_traverse_and_replace_angle_brackets() -> None:\n    def replace(e) -> ElementReplacement:\n        if e.tag == \"pl-code\":\n            return \"<pre><code>&lt;div&gt;</code></pre>\"\n        return e\n    html = traverse_and_replace(\"<pl-code></pl-code>\", replace)\n    assert html == \"<pre><code>&lt;div&gt;</code></pre>\"\ndef test_traverse_and_replace_xml_processing_instruction() -> None:\n    def replace(e) -> ElementReplacement:\n        return e",
        "detail": "src.prairielearn.python.traverse_test",
        "documentation": {}
    },
    {
        "label": "test_traverse_and_replace_xml_processing_instruction",
        "kind": 2,
        "importPath": "src.prairielearn.python.traverse_test",
        "description": "src.prairielearn.python.traverse_test",
        "peekOfCode": "def test_traverse_and_replace_xml_processing_instruction() -> None:\n    def replace(e) -> ElementReplacement:\n        return e\n    html = traverse_and_replace('hello <?xml version=\"1.0\"?> world', replace)\n    assert html == 'hello <!--?xml version=\"1.0\"?--> world'\ndef test_traverse_and_replace_empty_paragraph() -> None:\n    def replace(e) -> ElementReplacement:\n        return e\n    html = traverse_and_replace(\"<p></p>\", replace)\n    assert html == \"<p></p>\"",
        "detail": "src.prairielearn.python.traverse_test",
        "documentation": {}
    },
    {
        "label": "test_traverse_and_replace_empty_paragraph",
        "kind": 2,
        "importPath": "src.prairielearn.python.traverse_test",
        "description": "src.prairielearn.python.traverse_test",
        "peekOfCode": "def test_traverse_and_replace_empty_paragraph() -> None:\n    def replace(e) -> ElementReplacement:\n        return e\n    html = traverse_and_replace(\"<p></p>\", replace)\n    assert html == \"<p></p>\"\ndef test_traverse_and_replace_script() -> None:\n    def replace(e) -> ElementReplacement:\n        return e\n    html = traverse_and_replace('<script>\"\"</script>', replace)\n    assert html == '<script>\"\"</script>'",
        "detail": "src.prairielearn.python.traverse_test",
        "documentation": {}
    },
    {
        "label": "test_traverse_and_replace_script",
        "kind": 2,
        "importPath": "src.prairielearn.python.traverse_test",
        "description": "src.prairielearn.python.traverse_test",
        "peekOfCode": "def test_traverse_and_replace_script() -> None:\n    def replace(e) -> ElementReplacement:\n        return e\n    html = traverse_and_replace('<script>\"\"</script>', replace)\n    assert html == '<script>\"\"</script>'\ndef test_traverse_and_replace_script_complex() -> None:\n    def replace(e) -> ElementReplacement:\n        return e\n    test_str = (\n        '<script>const test = \"&quot;\";</script>'",
        "detail": "src.prairielearn.python.traverse_test",
        "documentation": {}
    },
    {
        "label": "test_traverse_and_replace_script_complex",
        "kind": 2,
        "importPath": "src.prairielearn.python.traverse_test",
        "description": "src.prairielearn.python.traverse_test",
        "peekOfCode": "def test_traverse_and_replace_script_complex() -> None:\n    def replace(e) -> ElementReplacement:\n        return e\n    test_str = (\n        '<script>const test = \"&quot;\";</script>'\n        '<style>.class-a > .class-b::before { content: \"a &gt; b\"; }</style>'\n    )\n    html = traverse_and_replace(test_str, replace)\n    assert html == test_str",
        "detail": "src.prairielearn.python.traverse_test",
        "documentation": {}
    },
    {
        "label": "ForbidModuleMetaPathFinder",
        "kind": 6,
        "importPath": "src.prairielearn.python.zygote",
        "description": "src.prairielearn.python.zygote",
        "peekOfCode": "class ForbidModuleMetaPathFinder(MetaPathFinder):\n    def __init__(self) -> None:\n        self.forbidden_modules: set[str] = set()\n    def forbid_modules(self, forbidden_module: Iterable[str]) -> None:\n        self.forbidden_modules.update(forbidden_module)\n    def reset_forbidden_modules(self) -> None:\n        self.forbidden_modules.clear()\n    def find_spec(\n        self,\n        fullname: str,",
        "detail": "src.prairielearn.python.zygote",
        "documentation": {}
    },
    {
        "label": "try_dumps",
        "kind": 2,
        "importPath": "src.prairielearn.python.zygote",
        "description": "src.prairielearn.python.zygote",
        "peekOfCode": "def try_dumps(obj: Any, sort_keys=False, allow_nan=False):\n    try:\n        zu.assert_all_integers_within_limits(obj)\n        return json.dumps(obj, sort_keys=sort_keys, allow_nan=allow_nan)\n    except Exception:\n        print(f\"Error converting this object to json:\\n{obj}\\n\")\n        raise\ndef worker_loop() -> None:\n    # Whether the PRNGs have already been seeded in this worker_loop() call\n    seeded = False",
        "detail": "src.prairielearn.python.zygote",
        "documentation": {}
    },
    {
        "label": "worker_loop",
        "kind": 2,
        "importPath": "src.prairielearn.python.zygote",
        "description": "src.prairielearn.python.zygote",
        "peekOfCode": "def worker_loop() -> None:\n    # Whether the PRNGs have already been seeded in this worker_loop() call\n    seeded = False\n    path_finder = ForbidModuleMetaPathFinder()\n    sys.meta_path.insert(0, path_finder)\n    # file descriptor 3 is for output data\n    with open(3, \"w\", encoding=\"utf-8\") as outf:\n        # Infinite loop where we wait for an input command, do it, and\n        # return the results. The caller should terminate us with a\n        # SIGTERM.",
        "detail": "src.prairielearn.python.zygote",
        "documentation": {}
    },
    {
        "label": "terminate_worker",
        "kind": 2,
        "importPath": "src.prairielearn.python.zygote",
        "description": "src.prairielearn.python.zygote",
        "peekOfCode": "def terminate_worker(signum: int, stack: types.FrameType | None) -> None:\n    if worker_pid > 0:\n        os.kill(worker_pid, signal.SIGKILL)\n    os._exit(0)\nsignal.signal(signal.SIGTERM, terminate_worker)\nsignal.signal(signal.SIGINT, terminate_worker)  # Ctrl-C case\nwith open(4, \"w\", encoding=\"utf-8\") as exitf:\n    while True:\n        worker_pid = os.fork()\n        if worker_pid == 0:",
        "detail": "src.prairielearn.python.zygote",
        "documentation": {}
    },
    {
        "label": "saved_path",
        "kind": 5,
        "importPath": "src.prairielearn.python.zygote",
        "description": "src.prairielearn.python.zygote",
        "peekOfCode": "saved_path = copy.copy(sys.path)\ndrop_privileges = os.environ.get(\"DROP_PRIVILEGES\", False)\n# If we're configured to drop privileges (that is, if we're running in a\n# Docker container), various tools like matplotlib and fontconfig will be\n# unable to write to their default config/cache directories. This is because\n# the `$HOME` environment variable still points to `/root`, which is not\n# writable by the `executor` user.\n#\n# To work around this, we'll set `$XDG_CONFIG_HOME` and `$XDG_CACHE_HOME` to\n# directories created in `/tmp` that are world-writable. matplotlib and",
        "detail": "src.prairielearn.python.zygote",
        "documentation": {}
    },
    {
        "label": "drop_privileges",
        "kind": 5,
        "importPath": "src.prairielearn.python.zygote",
        "description": "src.prairielearn.python.zygote",
        "peekOfCode": "drop_privileges = os.environ.get(\"DROP_PRIVILEGES\", False)\n# If we're configured to drop privileges (that is, if we're running in a\n# Docker container), various tools like matplotlib and fontconfig will be\n# unable to write to their default config/cache directories. This is because\n# the `$HOME` environment variable still points to `/root`, which is not\n# writable by the `executor` user.\n#\n# To work around this, we'll set `$XDG_CONFIG_HOME` and `$XDG_CACHE_HOME` to\n# directories created in `/tmp` that are world-writable. matplotlib and\n# fontconfig should respect these environment variables; other tools should as",
        "detail": "src.prairielearn.python.zygote",
        "documentation": {}
    },
    {
        "label": "logging.getLogger(\"matplotlib.font_manager\").disabled",
        "kind": 5,
        "importPath": "src.prairielearn.python.zygote",
        "description": "src.prairielearn.python.zygote",
        "peekOfCode": "logging.getLogger(\"matplotlib.font_manager\").disabled = True\n# Pre-load commonly used modules\nsys.path.insert(0, os.path.abspath(\"../question-servers/freeformPythonLib\"))\nimport html\nimport math\nimport random\nimport chevron\nimport lxml.html\nimport matplotlib\nimport matplotlib.font_manager",
        "detail": "src.prairielearn.python.zygote",
        "documentation": {}
    },
    {
        "label": "worker_pid",
        "kind": 5,
        "importPath": "src.prairielearn.python.zygote",
        "description": "src.prairielearn.python.zygote",
        "peekOfCode": "worker_pid = 0\ndef terminate_worker(signum: int, stack: types.FrameType | None) -> None:\n    if worker_pid > 0:\n        os.kill(worker_pid, signal.SIGKILL)\n    os._exit(0)\nsignal.signal(signal.SIGTERM, terminate_worker)\nsignal.signal(signal.SIGINT, terminate_worker)  # Ctrl-C case\nwith open(4, \"w\", encoding=\"utf-8\") as exitf:\n    while True:\n        worker_pid = os.fork()",
        "detail": "src.prairielearn.python.zygote",
        "documentation": {}
    },
    {
        "label": "safe_parse_int",
        "kind": 2,
        "importPath": "src.prairielearn.python.zygote_utils",
        "description": "src.prairielearn.python.zygote_utils",
        "peekOfCode": "def safe_parse_int(int_str: str) -> int | float:\n    \"\"\"\n    Parses a JSON string. If the string contains an integer that is too large,\n    it will be parsed as a float instead. This ensures that we don't error out\n    if the number is later re-serialized back to JSON.\n    \"\"\"\n    equiv_int = int(int_str)\n    if pl.is_int_json_serializable(equiv_int):\n        return equiv_int\n    return float(int_str)",
        "detail": "src.prairielearn.python.zygote_utils",
        "documentation": {}
    },
    {
        "label": "assert_all_integers_within_limits",
        "kind": 2,
        "importPath": "src.prairielearn.python.zygote_utils",
        "description": "src.prairielearn.python.zygote_utils",
        "peekOfCode": "def assert_all_integers_within_limits(item: Any) -> None:\n    \"\"\"\n    Raise an exception if the input item contains any oversized integers.\n    We consider an integer to be oversized if it cannot be losslessly parsed\n    from JSON into a JavaScript number.\n    \"\"\"\n    item_stack = [item]\n    while item_stack:\n        next_item = item_stack.pop()\n        if isinstance(next_item, int):",
        "detail": "src.prairielearn.python.zygote_utils",
        "documentation": {}
    },
    {
        "label": "test_safe_parse_int_small_ints",
        "kind": 2,
        "importPath": "src.prairielearn.python.zygote_utils_test",
        "description": "src.prairielearn.python.zygote_utils_test",
        "peekOfCode": "def test_safe_parse_int_small_ints(item: str) -> None:\n    loaded_item = json.loads(item, parse_int=zu.safe_parse_int)\n    assert isinstance(loaded_item, int)\n    assert int(item) == loaded_item\n@pytest.mark.parametrize(\n    \"item\",\n    [\n        \"-2.8e16\",\n        \"28000000000000000\",\n        \"-9007199254740992\",",
        "detail": "src.prairielearn.python.zygote_utils_test",
        "documentation": {}
    },
    {
        "label": "test_safe_parse_int_large_ints",
        "kind": 2,
        "importPath": "src.prairielearn.python.zygote_utils_test",
        "description": "src.prairielearn.python.zygote_utils_test",
        "peekOfCode": "def test_safe_parse_int_large_ints(item: str) -> None:\n    loaded_item = json.loads(item, parse_int=zu.safe_parse_int)\n    assert isinstance(loaded_item, float)\n    assert float(item) == loaded_item\n@pytest.mark.parametrize(\n    \"item\",\n    [\n        1,\n        [1, 2, [3, 4, {\"thing\": 5}]],\n        [1, 2, \"999999999999999999999\"],",
        "detail": "src.prairielearn.python.zygote_utils_test",
        "documentation": {}
    },
    {
        "label": "test_all_integers_within_limits_no_exception",
        "kind": 2,
        "importPath": "src.prairielearn.python.zygote_utils_test",
        "description": "src.prairielearn.python.zygote_utils_test",
        "peekOfCode": "def test_all_integers_within_limits_no_exception(item: Any) -> None:\n    try:\n        zu.assert_all_integers_within_limits(item)\n    except Exception as err:\n        assert False, err\n@pytest.mark.parametrize(\n    \"item\",\n    [\n        999999999999999999999,\n        [1, 2, [1, 2, {999999999999999999999: \"4\"}]],",
        "detail": "src.prairielearn.python.zygote_utils_test",
        "documentation": {}
    },
    {
        "label": "test_all_integers_within_limits_raise_exception",
        "kind": 2,
        "importPath": "src.prairielearn.python.zygote_utils_test",
        "description": "src.prairielearn.python.zygote_utils_test",
        "peekOfCode": "def test_all_integers_within_limits_raise_exception(item: Any) -> None:\n    with pytest.raises(ValueError):\n        zu.assert_all_integers_within_limits(item)",
        "detail": "src.prairielearn.python.zygote_utils_test",
        "documentation": {}
    },
    {
        "label": "load_module_from_path",
        "kind": 2,
        "importPath": "src.process_prairielearn.dynamic_loader",
        "description": "src.process_prairielearn.dynamic_loader",
        "peekOfCode": "def load_module_from_path(module_name: str, file_path: str):\n    \"\"\"\n    Dynamically loads a module from the specified file path and handles dependencies by \n    adding the package root to sys.path if not already present.\n    Args:\n        module_name (str): The name to assign to the loaded module.\n        file_path (str): The full file path to the module.\n    Returns:\n        Module: The loaded module object.\n    \"\"\"",
        "detail": "src.process_prairielearn.dynamic_loader",
        "documentation": {}
    },
    {
        "label": "load_controllers",
        "kind": 2,
        "importPath": "src.process_prairielearn.dynamic_loader",
        "description": "src.process_prairielearn.dynamic_loader",
        "peekOfCode": "def load_controllers(element_info: dict[str, dict], elements_to_call: set[str]) -> dict[str, object]:\n    \"\"\"\n    Loads the controller modules for the specified elements by dynamically loading the \n    modules based on the information provided in `element_info`.\n    Args:\n        element_info (dict[str, dict]): A dictionary containing element information, including paths and controllers.\n        elements_to_call (set[str]): A set of element names to load their corresponding controllers.\n    Returns:\n        dict[str, object]: A dictionary mapping element names to their loaded controller modules.\n    Logs:",
        "detail": "src.process_prairielearn.dynamic_loader",
        "documentation": {}
    },
    {
        "label": "run_controller",
        "kind": 2,
        "importPath": "src.process_prairielearn.dynamic_loader",
        "description": "src.process_prairielearn.dynamic_loader",
        "peekOfCode": "def run_controller(module: types.ModuleType, function_name: str, *args, **kwargs):\n    \"\"\"\n    Executes a function from the given module if it exists and is callable.\n    :param module: The module containing the function.\n    :param function_name: The name of the function to execute.\n    :param *args: Positional arguments to pass to the function.\n    :param **kwargs: Keyword arguments to pass to the function.\n    :return: The result of the function execution, or None if the function doesn't exist or an error occurs.\n    \"\"\"\n    try:",
        "detail": "src.process_prairielearn.dynamic_loader",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.process_prairielearn.dynamic_loader",
        "description": "src.process_prairielearn.dynamic_loader",
        "peekOfCode": "logger = get_logger(__name__)\ndef load_module_from_path(module_name: str, file_path: str):\n    \"\"\"\n    Dynamically loads a module from the specified file path and handles dependencies by \n    adding the package root to sys.path if not already present.\n    Args:\n        module_name (str): The name to assign to the loaded module.\n        file_path (str): The full file path to the module.\n    Returns:\n        Module: The loaded module object.",
        "detail": "src.process_prairielearn.dynamic_loader",
        "documentation": {}
    },
    {
        "label": "generate_mat",
        "kind": 2,
        "importPath": "src.process_prairielearn.extract",
        "description": "src.process_prairielearn.extract",
        "peekOfCode": "def generate_mat(n: int) -> str:\n        \"\"\"\n        Generates a random matrix of size n x n and converts it to JSON format.\n        Args:\n            n (int): Size of the matrix (n x n).\n        Returns:\n            str: JSON representation of the matrix.\n        \"\"\"\n        mat = np.random.random((n, n))\n        return pl.to_json(mat) # type: ignore",
        "detail": "src.process_prairielearn.extract",
        "documentation": {}
    },
    {
        "label": "generate_sym",
        "kind": 2,
        "importPath": "src.process_prairielearn.extract",
        "description": "src.process_prairielearn.extract",
        "peekOfCode": "def generate_sym() -> str:\n    \"\"\"\n    Generates a simple symbolic expression and converts it to JSON format.\n    Returns:\n        str: JSON representation of the symbolic expression.\n    \"\"\"\n    x, y = sympy.symbols(\"x y\")\n    z = x + y + 1\n    return pl.to_json(z) # type: ignore\ndef gather_element_info(base_dir: str, valid_elements: list[str] = VALID_ELEMENTS) -> dict[str, dict]:",
        "detail": "src.process_prairielearn.extract",
        "documentation": {}
    },
    {
        "label": "gather_element_info",
        "kind": 2,
        "importPath": "src.process_prairielearn.extract",
        "description": "src.process_prairielearn.extract",
        "peekOfCode": "def gather_element_info(base_dir: str, valid_elements: list[str] = VALID_ELEMENTS) -> dict[str, dict]:\n    \"\"\"\n    Gathers information about available elements from JSON files within the specified directory structure.\n    This function traverses through a directory, checks for valid element directories, \n    and attempts to load a corresponding `info.json` file for each element. \n    The loaded JSON data is returned in a dictionary where the keys are the element names \n    and the values are the loaded JSON content, with the directory path added.\n    Args:\n        base_dir (str): The base directory path where the \"elements\" folder is located.\n        valid_elements (list[str], optional): A list of valid element names. Defaults to VALID_ELEMENTS.",
        "detail": "src.process_prairielearn.extract",
        "documentation": {}
    },
    {
        "label": "find_elements_to_load",
        "kind": 2,
        "importPath": "src.process_prairielearn.extract",
        "description": "src.process_prairielearn.extract",
        "peekOfCode": "def find_elements_to_load(html_str: str, element_info: dict[str, dict[str, str]], extracted_elements=None):\n    \"\"\"\n    Function to find and extract valid elements from the HTML, add them to a set, and modify the DOM.\n    Args:\n        html (str): The HTML fragment to process.\n        element_info (dict[str, dict[str, str]]): Information about each valid element.\n        extracted_elements (set): Set of extracted elements (to avoid duplication).\n    \"\"\"\n    # Initialize the set if not passed\n    if extracted_elements is None:",
        "detail": "src.process_prairielearn.extract",
        "documentation": {}
    },
    {
        "label": "process_extracted_elements",
        "kind": 2,
        "importPath": "src.process_prairielearn.extract",
        "description": "src.process_prairielearn.extract",
        "peekOfCode": "def process_extracted_elements(\n    html_str: str, \n    filtering_elements: list[str], \n    data: 'pl.QuestionData', \n    controllers: dict, \n    custom_component=None\n) -> str:\n    \"\"\"\n    Process HTML string recursively, iterate through elements, apply controllers, \n    and replace valid elements with rendered content. Optionally wrap the rendered",
        "detail": "src.process_prairielearn.extract",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.process_prairielearn.extract",
        "description": "src.process_prairielearn.extract",
        "peekOfCode": "def main():\n    current_dir = os.getcwd()\n    # Gather element information\n    element_info = gather_element_info(current_dir)\n    print(\"Element Information Gathered:\")\n    for element, info in element_info.items():\n        print(f\"Element: {element}\\nInfo: {info}\\n\")\n    # Define the HTML content for the quiz (html_content)\n    html_content = r\"\"\"\n    <pl-card>",
        "detail": "src.process_prairielearn.extract",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.process_prairielearn.extract",
        "description": "src.process_prairielearn.extract",
        "peekOfCode": "logger = get_logger(__name__)\n# Define valid elements\nVALID_ELEMENTS: list[str] = [\n    \"pl-question-panel\", \"pl-number-input\", \"pl-checkbox\", \"pl-figure\", \n    \"pl-integer-input\", \"pl-matching\", \"pl-matrix-component-input\", \n    \"pl-matrix-input\", \"pl-multiple-choice\", \"pl-order-blocks\", \n    \"pl-symbolic-input\", \"pl-units-input\",\"pl-matrix-latex\",\"pl-card\",\"pl-answer-panel\"\n]\n## These are just functions for generating stuff for the correct answers to test the matrix input\ndef generate_mat(n: int) -> str:",
        "detail": "src.process_prairielearn.extract",
        "documentation": {}
    },
    {
        "label": "run_controller",
        "kind": 2,
        "importPath": "src.process_prairielearn.load_valid_elements",
        "description": "src.process_prairielearn.load_valid_elements",
        "peekOfCode": "def run_controller(module: types.ModuleType, function_name: str, *args, **kwargs):\n    \"\"\"\n    Executes a function from the given module if it exists and is callable.\n    :param module: The module containing the function.\n    :param function_name: The name of the function to execute.\n    :param *args: Positional arguments to pass to the function.\n    :param **kwargs: Keyword arguments to pass to the function.\n    :return: The result of the function execution, or None if the function doesn't exist or an error occurs.\n    \"\"\"\n    try:",
        "detail": "src.process_prairielearn.load_valid_elements",
        "documentation": {}
    },
    {
        "label": "format_question_html",
        "kind": 2,
        "importPath": "src.process_prairielearn.load_valid_elements",
        "description": "src.process_prairielearn.load_valid_elements",
        "peekOfCode": "def format_question_html(html_string: str, question_data: pl.QuestionData, valid_elements: list[str] = VALID_ELEMENTS) -> str:\n    formatted_html = \"\"\n    current_directory = os.getcwd()\n    # Load all available element controllers from the specified directory\n    element_controllers = load_element_info(current_directory, valid_elements)\n    # Extract HTML elements that match the valid elements from the given HTML string\n    extracted_elements = extract_valid_elements_from_html(valid_elements=valid_elements, html=html_string)\n    # Filter out specific question panel elements\n    question_panel_keys = [\"pl-question-panel\"]\n    filtered_question_panels = {}",
        "detail": "src.process_prairielearn.load_valid_elements",
        "documentation": {}
    },
    {
        "label": "process_extracted_elements",
        "kind": 2,
        "importPath": "src.process_prairielearn.load_valid_elements",
        "description": "src.process_prairielearn.load_valid_elements",
        "peekOfCode": "def process_extracted_elements(base_html: str, question_data: pl.QuestionData, element_controllers: dict, extracted_elements: dict, custom_component: str = None) -> str:\n    # Determine which elements from the HTML are both extracted and have corresponding controllers\n    extracted_element_keys = set(extracted_elements.keys())\n    available_controller_keys = set(element_controllers.keys())\n    formatted_html = \"\"\n    for element_key in extracted_element_keys:\n        if element_key in available_controller_keys:\n            element_info = element_controllers[element_key]\n            print(f\"This is the element info {element_info}\")\n            controller = element_info.get(\"module\", \"\")",
        "detail": "src.process_prairielearn.load_valid_elements",
        "documentation": {}
    },
    {
        "label": "generate_mat",
        "kind": 2,
        "importPath": "src.process_prairielearn.load_valid_elements",
        "description": "src.process_prairielearn.load_valid_elements",
        "peekOfCode": "def generate_mat(n):\n    # Generate a random 3x3 matrix\n    mat = np.random.random((n, n))\n    # Answer to each matrix entry converted to JSON\n    return pl.to_json(mat)\nimport sympy\ndef generate_sym():\n    # Declare math symbols\n    x, y = sympy.symbols(\"x y\")\n    # Describe the equation",
        "detail": "src.process_prairielearn.load_valid_elements",
        "documentation": {}
    },
    {
        "label": "generate_sym",
        "kind": 2,
        "importPath": "src.process_prairielearn.load_valid_elements",
        "description": "src.process_prairielearn.load_valid_elements",
        "peekOfCode": "def generate_sym():\n    # Declare math symbols\n    x, y = sympy.symbols(\"x y\")\n    # Describe the equation\n    z = x + y + 1\n    # Answer to fill in the blank input stored as JSON.\n    return pl.to_json(z)\ncorrect_answers = {\n    \"distance\": \"5\",  # Check if the system expects string or numeric values\n    \"time\": \"10\",     # Same here: ensure consistency with the expected data type",
        "detail": "src.process_prairielearn.load_valid_elements",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.process_prairielearn.load_valid_elements",
        "description": "src.process_prairielearn.load_valid_elements",
        "peekOfCode": "logger = get_logger(__name__)\nVALID_ELEMENTS: list[str] = [\"pl-question-panel\", \"pl-number-input\", \"pl-checkbox\", \"pl-figure\", \"pl-integer-input\",\"pl-matching\",\"pl-matrix-component-input\",\"pl-matrix-input\",\"pl-multiple-choice\",\"pl-order-blocks\",\"pl-symbolic-input\",\"pl-units-input\"]\ntest_htmls = [\n    r\"\"\"<pl-question-panel>\n  <p>A ball is thrown horizontally from the top of a building with a height of {{params.height}} {{params.unitsDist}} with an initial speed of {{params.initialSpeed}} {{params.unitsSpeed}}. </p>\n  <p>Assuming there is no air resistance, calculate the time it takes for the ball to reach the ground.</p>\n</pl-question-panel>\n<pl-number-input answers-name=\"t\" comparison=\"sigfig\" digits=\"3\" label=\"Time (in seconds)\"></pl-number-input>\n<pl-number-input answers-name=\"w\" comparison=\"sigfig\" digits=\"3\" label=\"Time (in seconds)\"></pl-number-input>\n<pl-number-input answers-name=\"z\" comparison=\"sigfig\" digits=\"3\" label=\"Time (in seconds)\"></pl-number-input>",
        "detail": "src.process_prairielearn.load_valid_elements",
        "documentation": {}
    },
    {
        "label": "test_htmls",
        "kind": 5,
        "importPath": "src.process_prairielearn.load_valid_elements",
        "description": "src.process_prairielearn.load_valid_elements",
        "peekOfCode": "test_htmls = [\n    r\"\"\"<pl-question-panel>\n  <p>A ball is thrown horizontally from the top of a building with a height of {{params.height}} {{params.unitsDist}} with an initial speed of {{params.initialSpeed}} {{params.unitsSpeed}}. </p>\n  <p>Assuming there is no air resistance, calculate the time it takes for the ball to reach the ground.</p>\n</pl-question-panel>\n<pl-number-input answers-name=\"t\" comparison=\"sigfig\" digits=\"3\" label=\"Time (in seconds)\"></pl-number-input>\n<pl-number-input answers-name=\"w\" comparison=\"sigfig\" digits=\"3\" label=\"Time (in seconds)\"></pl-number-input>\n<pl-number-input answers-name=\"z\" comparison=\"sigfig\" digits=\"3\" label=\"Time (in seconds)\"></pl-number-input>\n    \"\"\",\n    r\"\"\"<pl-question-panel>",
        "detail": "src.process_prairielearn.load_valid_elements",
        "documentation": {}
    },
    {
        "label": "free_fall_question",
        "kind": 5,
        "importPath": "src.process_prairielearn.load_valid_elements",
        "description": "src.process_prairielearn.load_valid_elements",
        "peekOfCode": "free_fall_question = r\"\"\"\n<pl-question-panel>\n  <p>A ball is dropped from a height of {{params.height}} meters. Assume that the ball falls freely under gravity (g = 9.8 m/s) with no air resistance.</p>\n  <ol>\n    <li>Calculate the time it takes for the ball to reach the ground.</li>\n    <li>Determine the velocity of the ball when it hits the ground.</li>\n    <li>Calculate the potential energy lost during the fall.</li>\n  </ol>\n  <pl-figure file-name=\"free_fall.png\"></pl-figure>\n</pl-question-panel>",
        "detail": "src.process_prairielearn.load_valid_elements",
        "documentation": {}
    },
    {
        "label": "pendulum_question",
        "kind": 5,
        "importPath": "src.process_prairielearn.load_valid_elements",
        "description": "src.process_prairielearn.load_valid_elements",
        "peekOfCode": "pendulum_question = r\"\"\"\n<pl-question-panel>\n  <p>A pendulum with a length of {{params.length}} meters swings with a small amplitude. Assume that the motion is simple harmonic and the gravitational acceleration is \\( g = 9.8 \\, \\text{m/s}^2 \\).</p>\n  <ol>\n    <li>Calculate the period of the pendulum.</li>\n    <li>Determine the maximum speed of the pendulum at the lowest point.</li>\n    <li>Calculate the maximum potential energy of the pendulum at its highest point.</li>\n  </ol>\n  <pl-figure file-name=\"pendulum_motion.png\"></pl-figure>\n</pl-question-panel>",
        "detail": "src.process_prairielearn.load_valid_elements",
        "documentation": {}
    },
    {
        "label": "ideal_gas_question",
        "kind": 5,
        "importPath": "src.process_prairielearn.load_valid_elements",
        "description": "src.process_prairielearn.load_valid_elements",
        "peekOfCode": "ideal_gas_question = r\"\"\"\n<pl-question-panel>\n  <p>A gas is contained in a sealed cylinder with a volume of {{params.volume}} liters at a temperature of {{params.temperature}} Kelvin and a pressure of {{params.pressure}} atm. Assume the gas behaves ideally.</p>\n  <ol>\n    <li>Calculate the number of moles of gas in the cylinder using the ideal gas law \\( PV = nRT \\).</li>\n    <li>Determine the volume of the gas if the pressure is doubled and temperature remains constant.</li>\n    <li>Calculate the change in internal energy if the temperature is increased by 100 K.</li>\n  </ol>\n  <pl-figure file-name=\"ideal_gas.png\"></pl-figure>\n</pl-question-panel>",
        "detail": "src.process_prairielearn.load_valid_elements",
        "documentation": {}
    },
    {
        "label": "forces_and_friction_question",
        "kind": 5,
        "importPath": "src.process_prairielearn.load_valid_elements",
        "description": "src.process_prairielearn.load_valid_elements",
        "peekOfCode": "forces_and_friction_question = r\"\"\"\n<pl-question-panel>\n  <p>A block is placed on a rough horizontal surface. The block is pushed with a force of {{params.force}} N at an angle of {{params.angle}} degrees with the horizontal.</p>\n  <p>The coefficient of kinetic friction between the block and the surface is {{params.frictionCoeff}}. Answer the following questions:</p>\n  <ol>\n    <li>Calculate the frictional force acting on the block.</li>\n    <li>Determine the net force acting on the block in the horizontal direction.</li>\n    <li>Calculate the acceleration of the block.</li>\n  </ol>\n  <pl-figure file-name=\"block_on_surface.png\"></pl-figure>",
        "detail": "src.process_prairielearn.load_valid_elements",
        "documentation": {}
    },
    {
        "label": "projectile_motion_question",
        "kind": 5,
        "importPath": "src.process_prairielearn.load_valid_elements",
        "description": "src.process_prairielearn.load_valid_elements",
        "peekOfCode": "projectile_motion_question = r\"\"\"\n<pl-question-panel>\n  <p>A projectile is launched with an initial velocity of {{params.velocity}} m/s at an angle of {{params.angle}} degrees above the horizontal.</p>\n  <p>Assume no air resistance and a gravitational acceleration of 9.8 m/s. Answer the following questions:</p>\n  <ol>\n    <li>Calculate the maximum height reached by the projectile.</li>\n    <li>Determine the total time the projectile spends in the air.</li>\n    <li>Calculate the horizontal range of the projectile.</li>\n  </ol>\n  <pl-figure file-name=\"projectile_motion.png\"></pl-figure>",
        "detail": "src.process_prairielearn.load_valid_elements",
        "documentation": {}
    },
    {
        "label": "circular_motion_question",
        "kind": 5,
        "importPath": "src.process_prairielearn.load_valid_elements",
        "description": "src.process_prairielearn.load_valid_elements",
        "peekOfCode": "circular_motion_question = r\"\"\"\n<pl-question-panel>\n  <p>A car is moving in a circular path with a radius of {{params.radius}} meters at a constant speed of {{params.speed}} m/s. Assume the car experiences a centripetal force.</p>\n  <p>Answer the following questions about the car's circular motion:</p>\n  <ol>\n    <li>Calculate the centripetal acceleration of the car.</li>\n    <li>Determine the force acting on the car if its mass is {{params.mass}} kg.</li>\n    <li>Calculate the time it takes for the car to complete one full revolution.</li>\n  </ol>\n  <pl-figure file-name=\"circular_motion.png\"></pl-figure>",
        "detail": "src.process_prairielearn.load_valid_elements",
        "documentation": {}
    },
    {
        "label": "new_question_html",
        "kind": 5,
        "importPath": "src.process_prairielearn.load_valid_elements",
        "description": "src.process_prairielearn.load_valid_elements",
        "peekOfCode": "new_question_html = r\"\"\"\n<pl-question-panel>\n  <p>A car starts from rest at the top of a frictionless incline with an angle of {{params.angle}} degrees and a height of {{params.height}} meters.</p>\n  <p>Assuming there is no friction, answer the following questions about the car's motion as it slides down the incline:</p>\n  <ol>\n    <li>Calculate the time it takes for the car to reach the bottom of the incline.</li>\n    <li>Determine the velocity of the car when it reaches the bottom of the incline.</li>\n    <li>Calculate the acceleration of the car along the incline.</li>\n  </ol>\n  <pl-figure file-name=\"inclined_plane.png\"></pl-figure>",
        "detail": "src.process_prairielearn.load_valid_elements",
        "documentation": {}
    },
    {
        "label": "all_htmls",
        "kind": 5,
        "importPath": "src.process_prairielearn.load_valid_elements",
        "description": "src.process_prairielearn.load_valid_elements",
        "peekOfCode": "all_htmls = []\nimport numpy as np\nfrom ..prairielearn.python import prairielearn as pl\ndef generate_mat(n):\n    # Generate a random 3x3 matrix\n    mat = np.random.random((n, n))\n    # Answer to each matrix entry converted to JSON\n    return pl.to_json(mat)\nimport sympy\ndef generate_sym():",
        "detail": "src.process_prairielearn.load_valid_elements",
        "documentation": {}
    },
    {
        "label": "correct_answers",
        "kind": 5,
        "importPath": "src.process_prairielearn.load_valid_elements",
        "description": "src.process_prairielearn.load_valid_elements",
        "peekOfCode": "correct_answers = {\n    \"distance\": \"5\",  # Check if the system expects string or numeric values\n    \"time\": \"10\",     # Same here: ensure consistency with the expected data type\n    \"finalSpeed\": \"25\", \n    \"forceComponents\": generate_mat(3),  # Ensure generate_mat() returns a valid matrix format\n    \"matrixB\": generate_mat(2),          # Same for this matrix\n    \"symbolic_math\": generate_sym()    # Ensure generate_sym() returns a valid symbolic expression\n  # Correct units are used here, ensure the system expects this format\n}\ndata: pl.QuestionData = {",
        "detail": "src.process_prairielearn.load_valid_elements",
        "documentation": {}
    },
    {
        "label": "formatted_html",
        "kind": 5,
        "importPath": "src.process_prairielearn.load_valid_elements",
        "description": "src.process_prairielearn.load_valid_elements",
        "peekOfCode": "formatted_html = format_question_html(new_question_html, data)\nprint(f\"Final html \\n{formatted_html}\")\ntest_html_path =   r\"C:\\Users\\lberm\\OneDrive\\Desktop\\GitHub_Repository\\mechedu1.0\\mechedu1\\src\\process_prairielearn\\test_html.html\"\nwith open(test_html_path, \"w\") as f:\n    f.write(formatted_html)",
        "detail": "src.process_prairielearn.load_valid_elements",
        "documentation": {}
    },
    {
        "label": "test_html_path",
        "kind": 5,
        "importPath": "src.process_prairielearn.load_valid_elements",
        "description": "src.process_prairielearn.load_valid_elements",
        "peekOfCode": "test_html_path =   r\"C:\\Users\\lberm\\OneDrive\\Desktop\\GitHub_Repository\\mechedu1.0\\mechedu1\\src\\process_prairielearn\\test_html.html\"\nwith open(test_html_path, \"w\") as f:\n    f.write(formatted_html)",
        "detail": "src.process_prairielearn.load_valid_elements",
        "documentation": {}
    },
    {
        "label": "escape_jinja_in_latex",
        "kind": 2,
        "importPath": "src.process_prairielearn.load_ver3",
        "description": "src.process_prairielearn.load_ver3",
        "peekOfCode": "def escape_jinja_in_latex(template: str) -> str:\n    \"\"\"\n    Escapes Jinja2 curly braces within LaTeX math mode in an HTML template.\n    Args:\n        template (str): The HTML template string containing Jinja2 and LaTeX code.\n    Returns:\n        str: The modified template with Jinja2 expressions properly escaped within LaTeX math mode.\n    \"\"\"\n    # Regex to find Jinja2 expressions within LaTeX math mode (\\(...\\) or \\[...\\])\n    pattern = r'\\\\\\((.*?)\\\\\\)|\\\\\\[(.*?)\\\\\\]'",
        "detail": "src.process_prairielearn.load_ver3",
        "documentation": {}
    },
    {
        "label": "extract_valid_elements_from_html",
        "kind": 2,
        "importPath": "src.process_prairielearn.load_ver3",
        "description": "src.process_prairielearn.load_ver3",
        "peekOfCode": "def extract_valid_elements_from_html(html: str, valid_elements: list[str]=VALID_ELEMENTS) -> dict[str, list]:\n    \"\"\"\n    Extract valid HTML elements and their children from an HTML string based on a list of allowed tags.\n    This function parses the given HTML string, checks if each element belongs to the list of valid elements,\n    and extracts both the element and its children (if applicable). If valid child elements are found, \n    they are recursively extracted and removed from the parent before the parent is converted to a string.\n    Args:\n        html (str): The HTML string to process.\n        valid_elements (list[str]): A list of valid HTML element tags to extract.\n    Returns:",
        "detail": "src.process_prairielearn.load_ver3",
        "documentation": {}
    },
    {
        "label": "gather_element_info",
        "kind": 2,
        "importPath": "src.process_prairielearn.load_ver3",
        "description": "src.process_prairielearn.load_ver3",
        "peekOfCode": "def gather_element_info(base_dir: str, valid_elements: list[str] = VALID_ELEMENTS) -> dict[str, dict]:\n    \"\"\"\n    Gathers information about available elements from JSON files within the specified directory structure.\n    This function traverses through a directory, checks for valid element directories, \n    and attempts to load a corresponding `info.json` file for each element. \n    The loaded JSON data is returned in a dictionary where the keys are the element names \n    and the values are the loaded JSON content, with the directory path added.\n    Args:\n        base_dir (str): The base directory path where the \"elements\" folder is located.\n        valid_elements (list[str], optional): A list of valid element names. Defaults to VALID_ELEMENTS.",
        "detail": "src.process_prairielearn.load_ver3",
        "documentation": {}
    },
    {
        "label": "find_elements_to_load",
        "kind": 2,
        "importPath": "src.process_prairielearn.load_ver3",
        "description": "src.process_prairielearn.load_ver3",
        "peekOfCode": "def find_elements_to_load(html: str,extracted_elements:dict,element_info: dict[str, dict[str,str]]) -> set[str]:\n    \"\"\"\n    Determines which elements from the HTML should be loaded by comparing them \n    with available elements in the provided element information.\n    The function extracts valid elements from the provided HTML, collects unique \n    element instances into a set, and compares them with the keys from `element_info`.\n    It returns a set of element names that exist in both the HTML and the element information.\n    Args:\n        html (str): The HTML string from which elements are extracted.\n        element_info (dict[str, dict]): A dictionary containing information about available elements.",
        "detail": "src.process_prairielearn.load_ver3",
        "documentation": {}
    },
    {
        "label": "load_module_from_path",
        "kind": 2,
        "importPath": "src.process_prairielearn.load_ver3",
        "description": "src.process_prairielearn.load_ver3",
        "peekOfCode": "def load_module_from_path(module_name: str, file_path: str):\n    \"\"\"\n    Dynamically loads a module from the specified file path and handles dependencies by \n    adding the package root to sys.path if not already present.\n    Args:\n        module_name (str): The name to assign to the loaded module.\n        file_path (str): The full file path to the module.\n    Returns:\n        Module: The loaded module object.\n    \"\"\"",
        "detail": "src.process_prairielearn.load_ver3",
        "documentation": {}
    },
    {
        "label": "load_controllers",
        "kind": 2,
        "importPath": "src.process_prairielearn.load_ver3",
        "description": "src.process_prairielearn.load_ver3",
        "peekOfCode": "def load_controllers(element_info: dict[str, dict], elements_to_call: set[str]) -> dict[str, object]:\n    \"\"\"\n    Loads the controller modules for the specified elements by dynamically loading the \n    modules based on the information provided in `element_info`.\n    Args:\n        element_info (dict[str, dict]): A dictionary containing element information, including paths and controllers.\n        elements_to_call (set[str]): A set of element names to load their corresponding controllers.\n    Returns:\n        dict[str, object]: A dictionary mapping element names to their loaded controller modules.\n    Logs:",
        "detail": "src.process_prairielearn.load_ver3",
        "documentation": {}
    },
    {
        "label": "run_controller",
        "kind": 2,
        "importPath": "src.process_prairielearn.load_ver3",
        "description": "src.process_prairielearn.load_ver3",
        "peekOfCode": "def run_controller(module: types.ModuleType, function_name: str, *args, **kwargs):\n    \"\"\"\n    Executes a function from the given module if it exists and is callable.\n    :param module: The module containing the function.\n    :param function_name: The name of the function to execute.\n    :param *args: Positional arguments to pass to the function.\n    :param **kwargs: Keyword arguments to pass to the function.\n    :return: The result of the function execution, or None if the function doesn't exist or an error occurs.\n    \"\"\"\n    try:",
        "detail": "src.process_prairielearn.load_ver3",
        "documentation": {}
    },
    {
        "label": "process_extracted_elements",
        "kind": 2,
        "importPath": "src.process_prairielearn.load_ver3",
        "description": "src.process_prairielearn.load_ver3",
        "peekOfCode": "def process_extracted_elements(\n    html_str: str, \n    filtering_elements: list[str], \n    data: 'pl.QuestionData', \n    controllers: dict, \n    custom_component: str = None\n) -> str:\n    \"\"\"\n    Process HTML string recursively, iterate through elements, apply controllers, \n    and replace valid elements with rendered content. Optionally wrap the rendered",
        "detail": "src.process_prairielearn.load_ver3",
        "documentation": {}
    },
    {
        "label": "format_question_html",
        "kind": 2,
        "importPath": "src.process_prairielearn.load_ver3",
        "description": "src.process_prairielearn.load_ver3",
        "peekOfCode": "def format_question_html(html: str, data: pl.QuestionData,isTesting:bool=False) -> str:\n    \"\"\"\n    Formats a given question HTML by extracting relevant elements, loading controllers, and creating a \n    question panel and form area. The final output is a full HTML document with Bootstrap and MathJax support.\n    Args:\n        html (str): The HTML string representing the question structure.\n        data (pl.QuestionData): The data associated with the question, including parameters and correct answers.\n    Returns:\n        str: A fully formatted HTML string containing the question panel and form area.\n    \"\"\"",
        "detail": "src.process_prairielearn.load_ver3",
        "documentation": {}
    },
    {
        "label": "format_question_html2",
        "kind": 2,
        "importPath": "src.process_prairielearn.load_ver3",
        "description": "src.process_prairielearn.load_ver3",
        "peekOfCode": "def format_question_html2(html: str, data: pl.QuestionData,isTesting:bool=False) -> str:\n    # Extract valid elements from the provided HTML\n    extracted_elements = extract_valid_elements_from_html(html)\n    # Load element info and gather the elements that need to be called\n    current_directory = os.getcwd()\n    element_info = gather_element_info(current_directory)\n    elements_to_call = find_elements_to_load(html, extracted_elements, element_info)\n    question_panel_keys = [\"pl-question-panel\",\"pl-matrix-latex\", \"pl-figure\", \"pl-card\"]\ndef main(html: str,data:pl.QuestionData,isTesting=True):\n    # Extracted elements is needed as this will be the original order of the html ",
        "detail": "src.process_prairielearn.load_ver3",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.process_prairielearn.load_ver3",
        "description": "src.process_prairielearn.load_ver3",
        "peekOfCode": "def main(html: str,data:pl.QuestionData,isTesting=True):\n    # Extracted elements is needed as this will be the original order of the html \n    extracted_elements = extract_valid_elements_from_html(html, valid_elements=VALID_ELEMENTS)\n    print(extracted_elements)\n    current_directory = os.getcwd()\n    element_info = gather_element_info(current_directory)\n    # Print extracted elements with better formatting\n    print(\"\\n--- Extracted Elements from HTML ---\")\n    for tag, content in extracted_elements.items():\n        print(f\"Tag: {tag}\")",
        "detail": "src.process_prairielearn.load_ver3",
        "documentation": {}
    },
    {
        "label": "generate_mat",
        "kind": 2,
        "importPath": "src.process_prairielearn.load_ver3",
        "description": "src.process_prairielearn.load_ver3",
        "peekOfCode": "def generate_mat(n: int) -> str:\n        \"\"\"\n        Generates a random matrix of size n x n and converts it to JSON format.\n        Args:\n            n (int): Size of the matrix (n x n).\n        Returns:\n            str: JSON representation of the matrix.\n        \"\"\"\n        mat = np.random.random((n, n))\n        return pl.to_json(mat) # type: ignore",
        "detail": "src.process_prairielearn.load_ver3",
        "documentation": {}
    },
    {
        "label": "generate_sym",
        "kind": 2,
        "importPath": "src.process_prairielearn.load_ver3",
        "description": "src.process_prairielearn.load_ver3",
        "peekOfCode": "def generate_sym() -> str:\n    \"\"\"\n    Generates a simple symbolic expression and converts it to JSON format.\n    Returns:\n        str: JSON representation of the symbolic expression.\n    \"\"\"\n    x, y = sympy.symbols(\"x y\")\n    z = x + y + 1\n    return pl.to_json(z) # type: ignore\nif __name__ == \"__main__\":",
        "detail": "src.process_prairielearn.load_ver3",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.process_prairielearn.load_ver3",
        "description": "src.process_prairielearn.load_ver3",
        "peekOfCode": "logger = get_logger(__name__)\n# Helper Function used to escape Jinja \n## Not sure if this is the best way to do this \ndef escape_jinja_in_latex(template: str) -> str:\n    \"\"\"\n    Escapes Jinja2 curly braces within LaTeX math mode in an HTML template.\n    Args:\n        template (str): The HTML template string containing Jinja2 and LaTeX code.\n    Returns:\n        str: The modified template with Jinja2 expressions properly escaped within LaTeX math mode.",
        "detail": "src.process_prairielearn.load_ver3",
        "documentation": {}
    },
    {
        "label": "escape_jinja_in_latex",
        "kind": 2,
        "importPath": "src.process_prairielearn.load_ver4",
        "description": "src.process_prairielearn.load_ver4",
        "peekOfCode": "def escape_jinja_in_latex(template: str) -> str:\n    \"\"\"\n    Escapes Jinja2 curly braces within LaTeX math mode in an HTML template.\n    Args:\n        template (str): The HTML template string containing Jinja2 and LaTeX code.\n    Returns:\n        str: The modified template with Jinja2 expressions properly escaped within LaTeX math mode.\n    \"\"\"\n    # Regex to find Jinja2 expressions within LaTeX math mode (\\(...\\) or \\[...\\])\n    pattern = r'\\\\\\((.*?)\\\\\\)|\\\\\\[(.*?)\\\\\\]'",
        "detail": "src.process_prairielearn.load_ver4",
        "documentation": {}
    },
    {
        "label": "generate_mat",
        "kind": 2,
        "importPath": "src.process_prairielearn.load_ver4",
        "description": "src.process_prairielearn.load_ver4",
        "peekOfCode": "def generate_mat(n: int) -> str:\n        \"\"\"\n        Generates a random matrix of size n x n and converts it to JSON format.\n        Args:\n            n (int): Size of the matrix (n x n).\n        Returns:\n            str: JSON representation of the matrix.\n        \"\"\"\n        mat = np.random.random((n, n))\n        return pl.to_json(mat) # type: ignore",
        "detail": "src.process_prairielearn.load_ver4",
        "documentation": {}
    },
    {
        "label": "generate_sym",
        "kind": 2,
        "importPath": "src.process_prairielearn.load_ver4",
        "description": "src.process_prairielearn.load_ver4",
        "peekOfCode": "def generate_sym() -> str:\n    \"\"\"\n    Generates a simple symbolic expression and converts it to JSON format.\n    Returns:\n        str: JSON representation of the symbolic expression.\n    \"\"\"\n    x, y = sympy.symbols(\"x y\")\n    z = x + y + 1\n    return pl.to_json(z) # type: ignore\n# def gather_element_info(base_dir: str, valid_elements: list[str] = VALID_ELEMENTS) -> dict[str, dict]:",
        "detail": "src.process_prairielearn.load_ver4",
        "documentation": {}
    },
    {
        "label": "process_extracted_elements",
        "kind": 2,
        "importPath": "src.process_prairielearn.load_ver4",
        "description": "src.process_prairielearn.load_ver4",
        "peekOfCode": "def process_extracted_elements(\n    html_str: str, \n    filtering_elements: list[str], \n    data: 'pl.QuestionData', \n    controllers: dict, \n    custom_component=None\n) -> str:\n    \"\"\"\n    Process HTML string recursively, iterate through elements, apply controllers, \n    and replace valid elements with rendered content. Optionally wrap the rendered",
        "detail": "src.process_prairielearn.load_ver4",
        "documentation": {}
    },
    {
        "label": "format_question_html",
        "kind": 2,
        "importPath": "src.process_prairielearn.load_ver4",
        "description": "src.process_prairielearn.load_ver4",
        "peekOfCode": "def format_question_html(html: str, data: 'pl.QuestionData', isTesting: bool = False) -> str:\n    \"\"\"\n    Formats a given question HTML by extracting relevant elements, loading controllers, and processing \n    all the necessary elements in one pass. The final output is a full HTML document with Bootstrap and \n    MathJax support.\n    Args:\n        html (str): The HTML string representing the question structure.\n        data (pl.QuestionData): The data associated with the question, including parameters and correct answers.\n        isTesting (bool): Flag to determine if testing mode is active. Adds full HTML headers if True.\n    Returns:",
        "detail": "src.process_prairielearn.load_ver4",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.process_prairielearn.load_ver4",
        "description": "src.process_prairielearn.load_ver4",
        "peekOfCode": "def main(html: str,data:pl.QuestionData,isTesting=True):\n    # Load element info and gather the elements that need to be called\n    # curss_extracted_elements(filtered_input_panels, controllers, data, custom_component=custom_input)rent_directory = os.getcwd()\n    # element_info = gather_element_info(current_directory)\n    # extracted_elements = set()\n    # element_call,extracted_elements = find_elements_to_load(html,element_info,extracted_elements) # type: ignore\n    return format_question_html(html = html, data=data,isTesting=True)\nif __name__ == \"__main__\":\n    # HTML template for the projectile motion question\n    projectile_motion_question = r\"\"\"",
        "detail": "src.process_prairielearn.load_ver4",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.process_prairielearn.load_ver4",
        "description": "src.process_prairielearn.load_ver4",
        "peekOfCode": "logger = get_logger(__name__)\n# Define valid elements\nVALID_ELEMENTS: list[str] = [\n    \"pl-question-panel\", \"pl-number-input\", \"pl-checkbox\", \"pl-figure\", \n    \"pl-integer-input\", \"pl-matching\", \"pl-matrix-component-input\", \n    \"pl-matrix-input\", \"pl-multiple-choice\", \"pl-order-blocks\", \n    \"pl-symbolic-input\", \"pl-units-input\",\"pl-matrix-latex\",\"pl-card\",\"pl-answer-panel\"\n]\n# Helper Function used to escape Jinja \n## Not sure if this is the best way to do this ",
        "detail": "src.process_prairielearn.load_ver4",
        "documentation": {}
    },
    {
        "label": "escape_jinja_in_latex",
        "kind": 2,
        "importPath": "src.process_prairielearn.process_prairielearn",
        "description": "src.process_prairielearn.process_prairielearn",
        "peekOfCode": "def escape_jinja_in_latex(template: str) -> str:\n    \"\"\"\n    Escapes Jinja2 curly braces within LaTeX math mode in an HTML template.\n    Args:\n        template (str): The HTML template string containing Jinja2 and LaTeX code.\n    Returns:\n        str: The modified template with Jinja2 expressions properly escaped within LaTeX math mode.\n    \"\"\"\n    # Regex to find Jinja2 expressions within LaTeX math mode (\\(...\\) or \\[...\\])\n    pattern = r'\\\\\\((.*?)\\\\\\)|\\\\\\[(.*?)\\\\\\]'",
        "detail": "src.process_prairielearn.process_prairielearn",
        "documentation": {}
    },
    {
        "label": "format_question_html",
        "kind": 2,
        "importPath": "src.process_prairielearn.process_prairielearn",
        "description": "src.process_prairielearn.process_prairielearn",
        "peekOfCode": "def format_question_html(html_content: str, data: 'pl.QuestionData', isTesting: bool = False) -> str:\n    current_directory = os.getcwd()\n    element_info = gather_element_info(current_directory,valid_elements=VALID_ELEMENTS)\n    elements_to_call, extracted_elements = find_elements_to_load(html_str=html_content, element_info=element_info)\n    controllers = load_controllers(element_info, elements_to_call)\n    submitted_answers = data.get(\"submitted_answers\",{})\n    if (data.get('panel')==\"answer\") and (submitted_answers):\n        answers = \"\"\n        for k, v in submitted_answers.items():\n            print(k,v)",
        "detail": "src.process_prairielearn.process_prairielearn",
        "documentation": {}
    },
    {
        "label": "import_module_from_path",
        "kind": 2,
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "peekOfCode": "def import_module_from_path(path):\n    \"\"\"imports a module and returs a module\n    Args:\n        path (str): path to module\n    Returns:\n        <class 'module'>: returns a module that i can run. \n    \"\"\"\n    # The function of interest is generate\n    spec = importlib.util.spec_from_file_location(\"generate\",path)\n    # Load the module from the created spec",
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "run_generate_py",
        "kind": 2,
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "peekOfCode": "def run_generate_py(path:str)->dict:\n    \"\"\"Imports a server.py module from a path, then we run the function generate found inside the function \n    Args:\n        path (str): path to the module\n    Returns:\n        dict: A dictionary containing params for question \n    \"\"\"\n    module = import_module_from_path(path)\n    data = module.generate()\n    return data",
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "run_generate_js",
        "kind": 2,
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "peekOfCode": "def run_generate_js(path):\n    with open(path, 'r') as file:\n        js_code = file.read()\n    context = execjs.compile(js_code)\n    return context.call(\"generate\")\ndef run_generate(path:str):\n    generators = {\n        \"server.js\": run_generate_js,\n        \"server.py\": run_generate_py\n    }",
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "run_generate",
        "kind": 2,
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "peekOfCode": "def run_generate(path:str):\n    generators = {\n        \"server.js\": run_generate_js,\n        \"server.py\": run_generate_py\n    }\n    if not os.path.isfile(path):\n        return ({\"error\": \"File not found\"}), 404\n    base_name = os.path.basename(path)\n    try:\n        if base_name in generators.keys():",
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "file_exist",
        "kind": 2,
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "peekOfCode": "def file_exist(file_path:str)->bool:\n    return os.path.exists(file_path)\ndef read_file(file_path:str):\n    file_exist(file_path)\n    with open(file_path,\"r\") as file:\n        return file.read()\ndef generateAdaptive(quiz_path:str,code_lang:str=\"python\"):\n    files_to_check = [\"question.html\", \"server.js\",\"server.py\",\"info.json\",\"solutions.html\"]\n    valid_files = {file:os.path.join(quiz_path, file) for file in files_to_check if file_exist(os.path.join(quiz_path, file))}\n    print(valid_files)",
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "read_file",
        "kind": 2,
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "peekOfCode": "def read_file(file_path:str):\n    file_exist(file_path)\n    with open(file_path,\"r\") as file:\n        return file.read()\ndef generateAdaptive(quiz_path:str,code_lang:str=\"python\"):\n    files_to_check = [\"question.html\", \"server.js\",\"server.py\",\"info.json\",\"solutions.html\"]\n    valid_files = {file:os.path.join(quiz_path, file) for file in files_to_check if file_exist(os.path.join(quiz_path, file))}\n    print(valid_files)\n    quiz_name = os.path.basename(quiz_path)\n    server_file = None",
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "generateAdaptive",
        "kind": 2,
        "importPath": "src.run_quizzes.run_module",
        "description": "src.run_quizzes.run_module",
        "peekOfCode": "def generateAdaptive(quiz_path:str,code_lang:str=\"python\"):\n    files_to_check = [\"question.html\", \"server.js\",\"server.py\",\"info.json\",\"solutions.html\"]\n    valid_files = {file:os.path.join(quiz_path, file) for file in files_to_check if file_exist(os.path.join(quiz_path, file))}\n    print(valid_files)\n    quiz_name = os.path.basename(quiz_path)\n    server_file = None\n    if code_lang.lower()==\"python\":\n        server_file = valid_files.get(\"server.py\")\n    elif code_lang.lower() == \"javascript\":\n        server_file = valid_files.get(\"server.js\")",
        "detail": "src.run_quizzes.run_module",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "src.utils.data_extraction",
        "description": "src.utils.data_extraction",
        "peekOfCode": "path = r\"C:\\Users\\lberm\\OneDrive\\Desktop\\GitHub_Repository\\mechedu\\website\\quizzes\"\nall_files = []\nunique_tags = []\n# Step 1: Collect all valid file paths\nfor root, dirs, files in os.walk(path):\n    valid_file_names = [\"question.html\"]\n    for file in files:\n        if file in valid_file_names:\n            all_files.append(os.path.join(root, file))\nprint(len(all_files))",
        "detail": "src.utils.data_extraction",
        "documentation": {}
    },
    {
        "label": "all_files",
        "kind": 5,
        "importPath": "src.utils.data_extraction",
        "description": "src.utils.data_extraction",
        "peekOfCode": "all_files = []\nunique_tags = []\n# Step 1: Collect all valid file paths\nfor root, dirs, files in os.walk(path):\n    valid_file_names = [\"question.html\"]\n    for file in files:\n        if file in valid_file_names:\n            all_files.append(os.path.join(root, file))\nprint(len(all_files))\nvalid_tags = [\"pl-question-panel\",\"pl-number-input\",\"pl-multiple-choice\",\"pl-answer\",\"pl-choice\",\"pl-checkbox\"]",
        "detail": "src.utils.data_extraction",
        "documentation": {}
    },
    {
        "label": "unique_tags",
        "kind": 5,
        "importPath": "src.utils.data_extraction",
        "description": "src.utils.data_extraction",
        "peekOfCode": "unique_tags = []\n# Step 1: Collect all valid file paths\nfor root, dirs, files in os.walk(path):\n    valid_file_names = [\"question.html\"]\n    for file in files:\n        if file in valid_file_names:\n            all_files.append(os.path.join(root, file))\nprint(len(all_files))\nvalid_tags = [\"pl-question-panel\",\"pl-number-input\",\"pl-multiple-choice\",\"pl-answer\",\"pl-choice\",\"pl-checkbox\"]\n# Step 2: Process each file and collect tags",
        "detail": "src.utils.data_extraction",
        "documentation": {}
    },
    {
        "label": "valid_tags",
        "kind": 5,
        "importPath": "src.utils.data_extraction",
        "description": "src.utils.data_extraction",
        "peekOfCode": "valid_tags = [\"pl-question-panel\",\"pl-number-input\",\"pl-multiple-choice\",\"pl-answer\",\"pl-choice\",\"pl-checkbox\"]\n# Step 2: Process each file and collect tags\ncount = 0\nfor file in all_files:\n    with open(file, encoding=\"utf-8\") as f:\n        soup = BeautifulSoup(f.read(), \"html.parser\")\n        all_tags = soup.find_all(True)\n        set_tags = set()\n        for tag in all_tags:\n            if tag.name.startswith(\"pl\"):",
        "detail": "src.utils.data_extraction",
        "documentation": {}
    },
    {
        "label": "count",
        "kind": 5,
        "importPath": "src.utils.data_extraction",
        "description": "src.utils.data_extraction",
        "peekOfCode": "count = 0\nfor file in all_files:\n    with open(file, encoding=\"utf-8\") as f:\n        soup = BeautifulSoup(f.read(), \"html.parser\")\n        all_tags = soup.find_all(True)\n        set_tags = set()\n        for tag in all_tags:\n            if tag.name.startswith(\"pl\"):\n                # Check if the tag already exists in the unique_tags list\n                existing_tag = next((entry for entry in unique_tags if entry[\"tag_name\"] == tag.name), None)",
        "detail": "src.utils.data_extraction",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "src.utils.data_extraction",
        "description": "src.utils.data_extraction",
        "peekOfCode": "df = pd.DataFrame(unique_tags, columns=[\"tag_name\", \"html\", \"file_ref\", \"count\"])\nprint(df.sort_values(\"count\",ascending=False))\n# Step 4: Print or save the DataFrame\n# df.to_csv(\"unique_tags.csv\")",
        "detail": "src.utils.data_extraction",
        "documentation": {}
    },
    {
        "label": "save_files_temp",
        "kind": 2,
        "importPath": "src.utils.file_handler",
        "description": "src.utils.file_handler",
        "peekOfCode": "def save_files_temp(question_title: str, files: Dict[str, Any]) -> str:\n    \"\"\"\n    Saves files with their respective content to a temporary directory.\n    This function creates a temporary directory, saves the provided files with their content \n    under a subdirectory named after `question_title`, and returns the path to the created directory.\n    Args:\n        question_title (str): The title of the question, which will be used as the name of the subdirectory.\n        files (Dict[str, Any]): A dictionary where the keys are filenames (str) and the values are the corresponding file contents. \n                                The content can be either a string or a dictionary.\n    Returns:",
        "detail": "src.utils.file_handler",
        "documentation": {}
    },
    {
        "label": "create_zip_file",
        "kind": 2,
        "importPath": "src.utils.file_handler",
        "description": "src.utils.file_handler",
        "peekOfCode": "def create_zip_file(file_paths: List[str]) -> io.BytesIO:\n    \"\"\"\n    Creates an in-memory ZIP file from the list of file paths, storing only the basename of each file in the archive.\n    Args:\n        file_paths (List[str]): A list of file paths to include in the ZIP archive.\n    Returns:\n        io.BytesIO: A BytesIO object containing the ZIP file data.\n    \"\"\"\n    memory_file = io.BytesIO()\n    with zipfile.ZipFile(memory_file, 'w') as zipf:",
        "detail": "src.utils.file_handler",
        "documentation": {}
    },
    {
        "label": "save_temp_dir_as_zip",
        "kind": 2,
        "importPath": "src.utils.file_handler",
        "description": "src.utils.file_handler",
        "peekOfCode": "def save_temp_dir_as_zip(temp_dir: str) -> io.BytesIO:\n    \"\"\"\n    Saves the contents of the temporary directory to a zip file and returns it as a BytesIO object.\n    Args:\n        temp_dir (str): The path to the temporary directory.\n    Returns:\n        io.BytesIO: A BytesIO object containing the zipped content of the temporary directory.\n    \"\"\"\n    # Verify if temp_dir exists and list its contents\n    if not os.path.exists(temp_dir):",
        "detail": "src.utils.file_handler",
        "documentation": {}
    },
    {
        "label": "pl_multiple_choice",
        "kind": 2,
        "importPath": "src.utils.plutilities",
        "description": "src.utils.plutilities",
        "peekOfCode": "def pl_multiple_choice(soup, tag_name, data):\n    if not isinstance(soup, BeautifulSoup):\n        raise TypeError(\"The 'soup' argument must be a BeautifulSoup object.\")\n    # Find all old tags that match the provided tag name\n    old_tags = soup.find_all(tag_name)\n    for old_tag in old_tags:\n        attributes = old_tag.attrs\n        name = attributes.get(\"answers-name\", \"\")\n        choices = old_tag.find_all(\"choice\", recursive=False)\n        indices = list(range(len(choices)))",
        "detail": "src.utils.plutilities",
        "documentation": {}
    },
    {
        "label": "wrap_inputs_with_fieldset",
        "kind": 2,
        "importPath": "src.utils.plutilities",
        "description": "src.utils.plutilities",
        "peekOfCode": "def wrap_inputs_with_fieldset(soup, name, class_):\n    \"\"\"\n    Wraps each <input> field with class 'response' in a <fieldset> tag and its corresponding hidden input.\n    Also adds a <label> for each input.\n    Args:\n        soup (BeautifulSoup): A BeautifulSoup object containing the HTML to modify.\n    Returns:\n        BeautifulSoup: The modified BeautifulSoup object with input fields wrapped in a fieldset tag.\n    Raises:\n        TypeError: If the 'soup' argument is not a BeautifulSoup object.",
        "detail": "src.utils.plutilities",
        "documentation": {}
    },
    {
        "label": "process_prairielearn_html",
        "kind": 2,
        "importPath": "src.utils.plutilities",
        "description": "src.utils.plutilities",
        "peekOfCode": "def process_prairielearn_html(question_html: str, solution_html: str, qdata: dict, qname: str):\n    \"\"\"\n    Processes the PrairieLearn HTML by wrapping inputs, adding fieldsets and labels, changing question panels,\n    and adding images.\n    Args:\n        question_html (str): The input HTML string for the question.\n        solution_html (str): The input HTML string for the solution.\n        qdata (dict): The dictionary containing the question data and additional data for template rendering.\n        qname (str): The question name to construct the image file path.\n    Returns:",
        "detail": "src.utils.plutilities",
        "documentation": {}
    },
    {
        "label": "escape_jinja_in_latex",
        "kind": 2,
        "importPath": "src.utils.plutilities",
        "description": "src.utils.plutilities",
        "peekOfCode": "def escape_jinja_in_latex(template: str) -> str:\n    \"\"\"\n    Escapes Jinja2 curly braces within LaTeX math mode in an HTML template.\n    Args:\n        template (str): The HTML template string containing Jinja2 and LaTeX code.\n    Returns:\n        str: The modified template with Jinja2 expressions properly escaped within LaTeX math mode.\n    \"\"\"\n    # Regex to find Jinja2 expressions within LaTeX math mode (\\(...\\) or \\[...\\])\n    pattern = r'\\\\\\((.*?)\\\\\\)|\\\\\\[(.*?)\\\\\\]'",
        "detail": "src.utils.plutilities",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "src.utils.plutilities",
        "description": "src.utils.plutilities",
        "peekOfCode": "test = \"\"\"\n<pl-question-panel>\n  <pl-figure file-name=\"gas_laws.png\"></pl-figure>\n</p>\n<p>The figure above illustrates concepts related to gases under certain conditions. Which of the following is the ideal gas law equation?\n</p>\n<pl-checkbox answers-name=\"idealGas\" weight=\"1\" inline=\"true\">\n  <pl-answer correct=\"true\">\\( PV = nRT \\)</pl-answer>\n  <pl-answer correct=\"false\">\\( P = \\rho RT \\)</pl-answer>\n  <pl-answer correct=\"false\">\\( P = \\frac{m}{V} \\)</pl-answer>",
        "detail": "src.utils.plutilities",
        "documentation": {}
    },
    {
        "label": "TagReplacer",
        "kind": 6,
        "importPath": "src.utils.plutilities_new",
        "description": "src.utils.plutilities_new",
        "peekOfCode": "class TagReplacer:\n    html: str\n    target_tag: str\n    replacement_tag: str\n    attributes: Optional[Dict[str, str]] = field(default_factory=dict)\n    mapping: Optional[Dict[str, str]] = field(default_factory=dict)\n    def __post_init__(self):\n        self.soup = BeautifulSoup(self.html, \"html.parser\")\n    def replace_tag(self) -> BeautifulSoup:\n        target_tags = self.soup.find_all(self.target_tag)",
        "detail": "src.utils.plutilities_new",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.utils.plutilities_new",
        "description": "src.utils.plutilities_new",
        "peekOfCode": "def main():\n    html_string = r\"\"\"\n    <pl-question-panel>\n      <pl-figure file-name=\"gas_laws.png\"></pl-figure>\n    <p>The figure above illustrates concepts related to gases under certain conditions. Which of the following is the ideal gas law equation?\n    </p>\n    </pl-question-panel>\n    <pl-checkbox answers-name=\"idealGas\" weight=\"1\" inline=\"true\">\n      <pl-answer correct=\"true\">\\( PV = nRT \\)</pl-answer>\n      <pl-answer correct=\"false\">\\( P = \\rho RT \\)</pl-answer>",
        "detail": "src.utils.plutilities_new",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.utils.plutilities_new",
        "description": "src.utils.plutilities_new",
        "peekOfCode": "logger = get_logger(__name__)\nfrom bs4 import BeautifulSoup\nfrom dataclasses import dataclass, field\nfrom typing import Optional, Dict\nfrom ..logging_config.logging_config import get_logger\nlogger = get_logger(__name__)\n@dataclass\nclass TagReplacer:\n    html: str\n    target_tag: str",
        "detail": "src.utils.plutilities_new",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.utils.plutilities_new",
        "description": "src.utils.plutilities_new",
        "peekOfCode": "logger = get_logger(__name__)\n@dataclass\nclass TagReplacer:\n    html: str\n    target_tag: str\n    replacement_tag: str\n    attributes: Optional[Dict[str, str]] = field(default_factory=dict)\n    mapping: Optional[Dict[str, str]] = field(default_factory=dict)\n    def __post_init__(self):\n        self.soup = BeautifulSoup(self.html, \"html.parser\")",
        "detail": "src.utils.plutilities_new",
        "documentation": {}
    },
    {
        "label": "create_tag_replacers",
        "kind": 2,
        "importPath": "src.utils.process_prairilearn",
        "description": "src.utils.process_prairilearn",
        "peekOfCode": "def create_tag_replacers(html_string: str, config: Dict[str, Dict]) -> List[TagReplacer]:\n    replacers = []\n    for name, cfg in config.items():\n        replacer = TagReplacer(\n            html=html_string,\n            target_tag=cfg[\"target_tag\"],\n            replacement_tag=cfg[\"replacement_tag\"],\n            attributes=cfg[\"attributes\"],\n            mapping=cfg.get(\"mapping\",{})\n        )",
        "detail": "src.utils.process_prairilearn",
        "documentation": {}
    },
    {
        "label": "apply_tag_replacers",
        "kind": 2,
        "importPath": "src.utils.process_prairilearn",
        "description": "src.utils.process_prairilearn",
        "peekOfCode": "def apply_tag_replacers(html_string: str, replacers: List[TagReplacer]) -> str:\n    soup = BeautifulSoup(html_string, \"html.parser\")\n    for replacer in replacers:\n        print(f\"Soup Before \\n{soup}\\n\")\n        replacer.update_soup(str(soup))\n        soup = replacer.auto_replace()\n        print(f\"Soup After \\n{soup}\\n\")\n    return soup.prettify()\ndef run(html:str)->bool:\n    replacers = create_tag_replacers(html, tag_replacer_configs)",
        "detail": "src.utils.process_prairilearn",
        "documentation": {}
    },
    {
        "label": "run",
        "kind": 2,
        "importPath": "src.utils.process_prairilearn",
        "description": "src.utils.process_prairilearn",
        "peekOfCode": "def run(html:str)->bool:\n    replacers = create_tag_replacers(html, tag_replacer_configs)\n    modified_html = apply_tag_replacers(html, replacers)\n    print(modified_html)\n    soup = BeautifulSoup(modified_html, \"html.parser\")\n    all_tags = soup.find_all(True)\n    for tag in all_tags:\n            if tag.name.startswith(\"pl\"):\n                return True\n    return False",
        "detail": "src.utils.process_prairilearn",
        "documentation": {}
    },
    {
        "label": "process_prairielearn_html",
        "kind": 2,
        "importPath": "src.utils.process_prairilearn",
        "description": "src.utils.process_prairilearn",
        "peekOfCode": "def process_prairielearn_html(question_html: str, solution_html: str, qdata: dict, qname: str):\n    pass\ndef main():\n    path = r\"C:\\Users\\lberm\\OneDrive\\Desktop\\GitHub_Repository\\mechedu1.0\\mechedu1\\src\\utils\\unique_tags.csv\"\n    df = pd.read_csv(path)\n    print(df.head())\n    for index, value in df[\"html\"].items():\n        print(run(value))\n    df_to_fix = df[df[\"html\"].apply(run)]\n    print(\"This is the current df\\n\", df_to_fix[\"html\"].iloc[0])",
        "detail": "src.utils.process_prairilearn",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.utils.process_prairilearn",
        "description": "src.utils.process_prairilearn",
        "peekOfCode": "def main():\n    path = r\"C:\\Users\\lberm\\OneDrive\\Desktop\\GitHub_Repository\\mechedu1.0\\mechedu1\\src\\utils\\unique_tags.csv\"\n    df = pd.read_csv(path)\n    print(df.head())\n    for index, value in df[\"html\"].items():\n        print(run(value))\n    df_to_fix = df[df[\"html\"].apply(run)]\n    print(\"This is the current df\\n\", df_to_fix[\"html\"].iloc[0])\n    print(df_to_fix[\"tag_name\"])\n    # # Create replacers from the config",
        "detail": "src.utils.process_prairilearn",
        "documentation": {}
    },
    {
        "label": "tag_replacer_configs",
        "kind": 5,
        "importPath": "src.utils.process_prairilearn",
        "description": "src.utils.process_prairilearn",
        "peekOfCode": "tag_replacer_configs = {\n    \"pl_question_panel\": {\n        \"target_tag\": \"pl-question-panel\",\n        \"replacement_tag\": \"div\",\n        \"attributes\": {\n            \"class\": \"card mb-4 p-3 bg-light\"\n        },\n        \"css_descriptions\": [\n            {\n                \"name\": \"card\",",
        "detail": "src.utils.process_prairilearn",
        "documentation": {}
    },
    {
        "label": "file_exist",
        "kind": 2,
        "importPath": "src.utils.run_modules",
        "description": "src.utils.run_modules",
        "peekOfCode": "def file_exist(file_path:str)->bool:\n    return os.path.exists(file_path)\ndef read_file(file_path:str):\n    file_exist(file_path)\n    with open(file_path,\"r\") as file:\n        return file.read()\ndef import_module_from_path(path:str):\n    # We are looking for the generate module in the python file\n    spec = importlib.util.spec_from_file_location(\"generate\",path)\n    # Load the module",
        "detail": "src.utils.run_modules",
        "documentation": {}
    },
    {
        "label": "read_file",
        "kind": 2,
        "importPath": "src.utils.run_modules",
        "description": "src.utils.run_modules",
        "peekOfCode": "def read_file(file_path:str):\n    file_exist(file_path)\n    with open(file_path,\"r\") as file:\n        return file.read()\ndef import_module_from_path(path:str):\n    # We are looking for the generate module in the python file\n    spec = importlib.util.spec_from_file_location(\"generate\",path)\n    # Load the module\n    module = importlib.util.module_from_spec(spec)  \n    # Execute the moduel to make attribute accessible",
        "detail": "src.utils.run_modules",
        "documentation": {}
    },
    {
        "label": "import_module_from_path",
        "kind": 2,
        "importPath": "src.utils.run_modules",
        "description": "src.utils.run_modules",
        "peekOfCode": "def import_module_from_path(path:str):\n    # We are looking for the generate module in the python file\n    spec = importlib.util.spec_from_file_location(\"generate\",path)\n    # Load the module\n    module = importlib.util.module_from_spec(spec)  \n    # Execute the moduel to make attribute accessible\n    spec.loader.exec_module(module)\n    # Return the imported module\n    return module\ndef run_generate_py(path_server_py:str):",
        "detail": "src.utils.run_modules",
        "documentation": {}
    },
    {
        "label": "run_generate_py",
        "kind": 2,
        "importPath": "src.utils.run_modules",
        "description": "src.utils.run_modules",
        "peekOfCode": "def run_generate_py(path_server_py:str):\n    \"\"\"Run the server.py module\n    Args:\n        path_server_py (str): path to server.py file\n    Returns:\n        module.generate(): Should be a dictionary containing valus, not sure need to check\n    \"\"\"\n    module = import_module_from_path(path_server_py)\n    return module.generate()\ndef run_generate_js(path):",
        "detail": "src.utils.run_modules",
        "documentation": {}
    },
    {
        "label": "run_generate_js",
        "kind": 2,
        "importPath": "src.utils.run_modules",
        "description": "src.utils.run_modules",
        "peekOfCode": "def run_generate_js(path):\n    with open(path, 'r') as file:\n        js_code = file.read()\n    context = execjs.compile(js_code)\n    return context.call(\"generate\")\ndef run_generate(path:str):\n    generators = {\n        \"server.js\": run_generate_js,\n        \"server.py\": run_generate_py\n    }",
        "detail": "src.utils.run_modules",
        "documentation": {}
    },
    {
        "label": "run_generate",
        "kind": 2,
        "importPath": "src.utils.run_modules",
        "description": "src.utils.run_modules",
        "peekOfCode": "def run_generate(path:str):\n    generators = {\n        \"server.js\": run_generate_js,\n        \"server.py\": run_generate_py\n    }\n    if not os.path.isfile(path):\n        return ({\"error\": \"File not found\"}), 404\n    base_name = os.path.basename(path)\n    try:\n        if base_name in generators.keys():",
        "detail": "src.utils.run_modules",
        "documentation": {}
    },
    {
        "label": "generateAdaptive",
        "kind": 2,
        "importPath": "src.utils.run_modules",
        "description": "src.utils.run_modules",
        "peekOfCode": "def generateAdaptive(quiz_path:str,code_lang:str=\"python\"):\n    files_to_check = [\"question.html\", \"server.js\",\"server.py\",\"info.json\",\"solution.html\"]\n    valid_files = {file:os.path.join(quiz_path, file) for file in files_to_check if file_exist(os.path.join(quiz_path, file))}\n    print(valid_files)\n    quiz_name = os.path.basename(quiz_path)\n    server_file = None\n    if code_lang.lower()==\"python\":\n        server_file = valid_files.get(\"server.py\")\n    elif code_lang.lower() == \"javascript\":\n        server_file = valid_files.get(\"server.js\")",
        "detail": "src.utils.run_modules",
        "documentation": {}
    },
    {
        "label": "double_curly_brackets",
        "kind": 2,
        "importPath": "src.utils.string_parser",
        "description": "src.utils.string_parser",
        "peekOfCode": "def double_curly_brackets(text):\n    text = re.sub(r\"{\", \"{{\",text)\n    text = re.sub(r\"}\", \"}}\",text)\n    return text\ndef extract_code_block(text, language):\n    pattern = re.compile(rf'```{language}\\n(.*?)\\n```', re.DOTALL)\n    matches = pattern.findall(text)\n    return matches[0]\ndef extract_triple_quotes(text:str)->str:\n    pattern = re.compile(r'```.*?\\n(.*?)\\n```', re.DOTALL)",
        "detail": "src.utils.string_parser",
        "documentation": {}
    },
    {
        "label": "extract_code_block",
        "kind": 2,
        "importPath": "src.utils.string_parser",
        "description": "src.utils.string_parser",
        "peekOfCode": "def extract_code_block(text, language):\n    pattern = re.compile(rf'```{language}\\n(.*?)\\n```', re.DOTALL)\n    matches = pattern.findall(text)\n    return matches[0]\ndef extract_triple_quotes(text:str)->str:\n    pattern = re.compile(r'```.*?\\n(.*?)\\n```', re.DOTALL)\n    matches = pattern.findall(text)\n    for match in matches:\n        if match:\n            return match",
        "detail": "src.utils.string_parser",
        "documentation": {}
    },
    {
        "label": "extract_triple_quotes",
        "kind": 2,
        "importPath": "src.utils.string_parser",
        "description": "src.utils.string_parser",
        "peekOfCode": "def extract_triple_quotes(text:str)->str:\n    pattern = re.compile(r'```.*?\\n(.*?)\\n```', re.DOTALL)\n    matches = pattern.findall(text)\n    for match in matches:\n        if match:\n            return match",
        "detail": "src.utils.string_parser",
        "documentation": {}
    },
    {
        "label": "api_key",
        "kind": 5,
        "importPath": "src.credentials",
        "description": "src.credentials",
        "peekOfCode": "api_key = os.environ.get('OPENAI_API_KEY')\nif not api_key:\n    raise ValueError(\"No API key found. Set the API_KEY environment variable.\")",
        "detail": "src.credentials",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "src.test",
        "description": "src.test",
        "peekOfCode": "path = r\"C:\\Users\\lberm\\OneDrive\\Desktop\\GitHub_Repository\\mechedu1.0\\mechedu1\\src\\prairielearn\\elements\"\n# Get the absolute path to the 'src' directory relative to the current working directory\ncurrent_working_directory = os.getcwd()\nsrc_dir = os.path.join(current_working_directory, 'src')\n# Add the 'src' directory to sys.path so Python can find the modules\nif src_dir not in sys.path:\n    sys.path.insert(0, src_dir)\n# List of valid elements (controllers)\nvalid_elements = [\"pl-answer-panel.py\", \"pl-number-input.py\",\"pl-multiple-choice.py\"]\n# html_string = r\"\"\"",
        "detail": "src.test",
        "documentation": {}
    },
    {
        "label": "current_working_directory",
        "kind": 5,
        "importPath": "src.test",
        "description": "src.test",
        "peekOfCode": "current_working_directory = os.getcwd()\nsrc_dir = os.path.join(current_working_directory, 'src')\n# Add the 'src' directory to sys.path so Python can find the modules\nif src_dir not in sys.path:\n    sys.path.insert(0, src_dir)\n# List of valid elements (controllers)\nvalid_elements = [\"pl-answer-panel.py\", \"pl-number-input.py\",\"pl-multiple-choice.py\"]\n# html_string = r\"\"\"\n# <pl-multiple-choice answers-name=\"pressureSurfaceTensionRelation\" weight=\"1\" inline=\"true\">\n# \"\"\"",
        "detail": "src.test",
        "documentation": {}
    },
    {
        "label": "src_dir",
        "kind": 5,
        "importPath": "src.test",
        "description": "src.test",
        "peekOfCode": "src_dir = os.path.join(current_working_directory, 'src')\n# Add the 'src' directory to sys.path so Python can find the modules\nif src_dir not in sys.path:\n    sys.path.insert(0, src_dir)\n# List of valid elements (controllers)\nvalid_elements = [\"pl-answer-panel.py\", \"pl-number-input.py\",\"pl-multiple-choice.py\"]\n# html_string = r\"\"\"\n# <pl-multiple-choice answers-name=\"pressureSurfaceTensionRelation\" weight=\"1\" inline=\"true\">\n# \"\"\"\n# html_string = r\"\"\"",
        "detail": "src.test",
        "documentation": {}
    },
    {
        "label": "valid_elements",
        "kind": 5,
        "importPath": "src.test",
        "description": "src.test",
        "peekOfCode": "valid_elements = [\"pl-answer-panel.py\", \"pl-number-input.py\",\"pl-multiple-choice.py\"]\n# html_string = r\"\"\"\n# <pl-multiple-choice answers-name=\"pressureSurfaceTensionRelation\" weight=\"1\" inline=\"true\">\n# \"\"\"\n# html_string = r\"\"\"\n# <pl-multiple-choice answers-name=\"acc\" weight=\"1\">\n#   <pl-answer correct=\"false\">positive</pl-answer>\n#   <pl-answer correct=\"true\">negative</pl-answer>\n#   <pl-answer correct=\"false\">zero</pl-answer>\n# </pl-multiple-choice>\"\"\"",
        "detail": "src.test",
        "documentation": {}
    },
    {
        "label": "html_string",
        "kind": 5,
        "importPath": "src.test",
        "description": "src.test",
        "peekOfCode": "html_string = r\"\"\"<pl-number-input answers-name=\"ans_rtol\" label=\"$x =$\"> </pl-number-input>\"\"\"\ndata: pl.QuestionData = {\n    \"params\": {\"test\": 5},\n    \"correct_answers\": {\"ans_rtol\": 5},\n    \"submitted_answers\": {\"ans_rtol\":5},  # Make sure the key matches the input name\n    \"format_errors\": {},\n    \"partial_scores\": {},\n    \"score\": 100,\n    \"feedback\": {\"comment\": \"Great job\"},\n    \"variant_seed\": \"seed123\",",
        "detail": "src.test",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "app = create_app()\n#Checks if the run.py file has executed directly and not imported\nif __name__ == '__main__':\n    print(\" Starting app...\")\n    app.run(debug=True)",
        "detail": "main",
        "documentation": {}
    }
]